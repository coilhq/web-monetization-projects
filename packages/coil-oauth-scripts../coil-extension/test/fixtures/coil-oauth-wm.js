;(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory()
  else if (typeof define === 'function' && define.amd) define([], factory)
  else {
    var a = factory()
    for (var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i]
  }
})(window, function() {
  return /******/ (function(modules) {
    // webpackBootstrap
    /******/ // The module cache
    /******/ var installedModules = {} // The require function
    /******/
    /******/ /******/ function __webpack_require__(moduleId) {
      /******/
      /******/ // Check if module is in cache
      /******/ if (installedModules[moduleId]) {
        /******/ return installedModules[moduleId].exports
        /******/
      } // Create a new module (and put it into the cache)
      /******/ /******/ var module = (installedModules[moduleId] = {
        /******/ i: moduleId,
        /******/ l: false,
        /******/ exports: {}
        /******/
      }) // Execute the module function
      /******/
      /******/ /******/ modules[moduleId].call(
        module.exports,
        module,
        module.exports,
        __webpack_require__
      ) // Flag the module as loaded
      /******/
      /******/ /******/ module.l = true // Return the exports of the module
      /******/
      /******/ /******/ return module.exports
      /******/
    } // expose the modules object (__webpack_modules__)
    /******/
    /******/
    /******/ /******/ __webpack_require__.m = modules // expose the module cache
    /******/
    /******/ /******/ __webpack_require__.c = installedModules // define getter function for harmony exports
    /******/
    /******/ /******/ __webpack_require__.d = function(exports, name, getter) {
      /******/ if (!__webpack_require__.o(exports, name)) {
        /******/ Object.defineProperty(exports, name, {
          enumerable: true,
          get: getter
        })
        /******/
      }
      /******/
    } // define __esModule on exports
    /******/
    /******/ /******/ __webpack_require__.r = function(exports) {
      /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module'
        })
        /******/
      }
      /******/ Object.defineProperty(exports, '__esModule', { value: true })
      /******/
    } // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
    /******/
    /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function(
      value,
      mode
    ) {
      /******/ if (mode & 1) value = __webpack_require__(value)
      /******/ if (mode & 8) return value
      /******/ if (
        mode & 4 &&
        typeof value === 'object' &&
        value &&
        value.__esModule
      )
        return value
      /******/ var ns = Object.create(null)
      /******/ __webpack_require__.r(ns)
      /******/ Object.defineProperty(ns, 'default', {
        enumerable: true,
        value: value
      })
      /******/ if (mode & 2 && typeof value != 'string')
        for (var key in value)
          __webpack_require__.d(
            ns,
            key,
            function(key) {
              return value[key]
            }.bind(null, key)
          )
      /******/ return ns
      /******/
    } // getDefaultExport function for compatibility with non-harmony modules
    /******/
    /******/ /******/ __webpack_require__.n = function(module) {
      /******/ var getter =
        module && module.__esModule
          ? /******/ function getDefault() {
              return module['default']
            }
          : /******/ function getModuleExports() {
              return module
            }
      /******/ __webpack_require__.d(getter, 'a', getter)
      /******/ return getter
      /******/
    } // Object.prototype.hasOwnProperty.call
    /******/
    /******/ /******/ __webpack_require__.o = function(object, property) {
      return Object.prototype.hasOwnProperty.call(object, property)
    } // __webpack_public_path__
    /******/
    /******/ /******/ __webpack_require__.p = '' // Load entry module and return exports
    /******/
    /******/
    /******/ /******/ return __webpack_require__((__webpack_require__.s = 0))
    /******/
  })(
    /************************************************************************/
    /******/ {
      /***/ '../../node_modules/assert/assert.js':
        /*!***************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/assert/assert.js ***!
  \***************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(global) {\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"../../node_modules/object-assign/index.js\");\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = __webpack_require__(/*! util/ */ \"../../node_modules/util/util.js\");\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"../../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/assert/assert.js?"
          )

          /***/
        },

      /***/ '../../node_modules/base64-js/index.js':
        /*!*****************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/base64-js/index.js ***!
  \*****************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/base64-js/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/btp-packet/dist/index.js':
        /*!***********************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/btp-packet/dist/index.js ***!
  \***********************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst oer_utils_1 = __webpack_require__(/*! oer-utils */ \"../../node_modules/oer-utils/dist/src/index.js\");\nconst dateFormat = __webpack_require__(/*! dateformat */ \"../../node_modules/dateformat/lib/dateformat.js\");\nvar Type;\n(function (Type) {\n    Type[Type[\"TYPE_RESPONSE\"] = 1] = \"TYPE_RESPONSE\";\n    Type[Type[\"TYPE_ERROR\"] = 2] = \"TYPE_ERROR\";\n    Type[Type[\"TYPE_MESSAGE\"] = 6] = \"TYPE_MESSAGE\";\n    Type[Type[\"TYPE_TRANSFER\"] = 7] = \"TYPE_TRANSFER\";\n})(Type = exports.Type || (exports.Type = {}));\nexports.TYPE_RESPONSE = Type.TYPE_RESPONSE;\nexports.TYPE_ERROR = Type.TYPE_ERROR;\nexports.TYPE_MESSAGE = Type.TYPE_MESSAGE;\nexports.TYPE_TRANSFER = Type.TYPE_TRANSFER;\nexports.MIME_APPLICATION_OCTET_STREAM = 0;\nexports.MIME_TEXT_PLAIN_UTF8 = 1;\nexports.MIME_APPLICATION_JSON = 2;\nfunction typeToString(type) {\n    switch (type) {\n        case Type.TYPE_RESPONSE: return 'TYPE_RESPONSE';\n        case Type.TYPE_ERROR: return 'TYPE_ERROR';\n        case Type.TYPE_MESSAGE: return 'TYPE_MESSAGE';\n        case Type.TYPE_TRANSFER: return 'TYPE_TRANSFER';\n        default: throw new Error('Unrecognized BTP packet type');\n    }\n}\nexports.typeToString = typeToString;\nconst GENERALIZED_TIME_REGEX = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2}\\.[0-9]{3}Z)$/;\nconst protocolNameCache = {};\nregisterProtocolNames([\n    'ilp',\n    'auth',\n    'auth_username',\n    'auth_token',\n    'channel',\n    'channel_signature',\n    'claim',\n    'fund_channel',\n    'info',\n    'last_claim'\n]);\nfunction registerProtocolNames(names) {\n    for (const protocolName of names) {\n        protocolNameCache[protocolName] = Buffer.from(protocolName, 'ascii');\n    }\n}\nexports.registerProtocolNames = registerProtocolNames;\nfunction base64url(input) {\n    return input.toString('base64')\n        .replace(/=/g, '')\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_');\n}\nexports.base64url = base64url;\nfunction toGeneralizedTimeBuffer(date) {\n    return Buffer.from(dateFormat(date, \"UTC:yyyymmddHHMMss.l'Z'\"));\n}\nfunction readGeneralizedTime(reader) {\n    const generalizedTime = reader.readVarOctetString().toString();\n    const date = generalizedTime.replace(GENERALIZED_TIME_REGEX, '$1-$2-$3T$4:$5:$6');\n    return new Date(date);\n}\nfunction writeProtocolData(writer, protocolData) {\n    if (!Array.isArray(protocolData)) {\n        throw new Error('protocolData must be an array');\n    }\n    const lengthPrefix = protocolData.length;\n    const lengthPrefixLengthPrefix = Math.max(1, Math.ceil((Math.log(protocolData.length + 1) / Math.log(2)) / 8));\n    writer.writeUInt8(lengthPrefixLengthPrefix);\n    writer.writeUInt(lengthPrefix, lengthPrefixLengthPrefix);\n    for (const p of protocolData) {\n        writer.writeVarOctetString(protocolNameCache[p.protocolName] ||\n            Buffer.from(p.protocolName, 'ascii'));\n        writer.writeUInt8(p.contentType);\n        writer.writeVarOctetString(p.data);\n    }\n}\nfunction readProtocolData(reader) {\n    const lengthPrefixPrefix = reader.readUInt8Number();\n    const lengthPrefix = reader.readUIntNumber(lengthPrefixPrefix);\n    const protocolData = [];\n    for (let i = 0; i < lengthPrefix; ++i) {\n        const protocolName = reader.readVarOctetString().toString('ascii');\n        const contentType = reader.readUInt8Number();\n        const data = reader.readVarOctetString();\n        protocolData.push({\n            protocolName,\n            contentType,\n            data\n        });\n    }\n    return protocolData;\n}\nfunction writeTransfer(writer, data) {\n    writer.writeUInt64(data.amount);\n    writeProtocolData(writer, data.protocolData);\n}\nfunction writeError(writer, data) {\n    if (data.code.length !== 3) {\n        throw new Error(`error code must be 3 characters, got: \"${data.code}\"`);\n    }\n    const codeBuffer = Buffer.from(data.code, 'ascii');\n    const nameBuffer = Buffer.from(data.name, 'ascii');\n    const triggeredAtBuffer = toGeneralizedTimeBuffer(data.triggeredAt);\n    const dataBuffer = Buffer.from(data.data, 'utf8');\n    writer.write(codeBuffer);\n    writer.writeVarOctetString(nameBuffer);\n    writer.writeVarOctetString(triggeredAtBuffer);\n    writer.writeVarOctetString(dataBuffer);\n    writeProtocolData(writer, data.protocolData);\n}\nfunction writeContents(writer, obj) {\n    switch (obj.type) {\n        case Type.TYPE_RESPONSE:\n        case Type.TYPE_MESSAGE:\n            writeProtocolData(writer, obj.data.protocolData);\n            break;\n        case Type.TYPE_TRANSFER:\n            writeTransfer(writer, obj.data);\n            break;\n        case Type.TYPE_ERROR:\n            writeError(writer, obj.data);\n            break;\n        default:\n            throw new Error('Unrecognized type');\n    }\n}\nfunction serialize(obj) {\n    const contentsPredictor = new oer_utils_1.Predictor();\n    writeContents(contentsPredictor, obj);\n    const envelopeSize = 1 + 4 +\n        oer_utils_1.Predictor.measureVarOctetString(contentsPredictor.length);\n    const envelopeWriter = new oer_utils_1.Writer(envelopeSize);\n    envelopeWriter.writeUInt8(obj.type);\n    envelopeWriter.writeUInt32(obj.requestId);\n    const contentsWriter = envelopeWriter.createVarOctetString(contentsPredictor.length);\n    writeContents(contentsWriter, obj);\n    return envelopeWriter.getBuffer();\n}\nexports.serialize = serialize;\nfunction readTransfer(reader) {\n    const amount = reader.readUInt64();\n    const protocolData = readProtocolData(reader);\n    return { amount, protocolData };\n}\nfunction readError(reader) {\n    const code = reader.read(3).toString('ascii');\n    const name = reader.readVarOctetString().toString('ascii');\n    const triggeredAt = readGeneralizedTime(reader);\n    const data = reader.readVarOctetString().toString('utf8');\n    const protocolData = readProtocolData(reader);\n    return { code, name, triggeredAt, data, protocolData };\n}\nfunction deserialize(buffer) {\n    const envelopeReader = oer_utils_1.Reader.from(buffer);\n    const type = envelopeReader.readUInt8Number();\n    const requestId = envelopeReader.readUInt32Number();\n    const dataBuff = envelopeReader.readVarOctetString();\n    const reader = new oer_utils_1.Reader(dataBuff);\n    let data;\n    switch (type) {\n        case Type.TYPE_RESPONSE:\n        case Type.TYPE_MESSAGE:\n            data = { protocolData: readProtocolData(reader) };\n            break;\n        case Type.TYPE_TRANSFER:\n            data = readTransfer(reader);\n            break;\n        case Type.TYPE_ERROR:\n            data = readError(reader);\n            break;\n        default:\n            throw new Error('Unrecognized type');\n    }\n    return { type, requestId, data };\n}\nexports.deserialize = deserialize;\nexports.serializeResponse = (requestId, protocolData) => {\n    return serialize({\n        type: Type.TYPE_RESPONSE,\n        requestId,\n        data: { protocolData }\n    });\n};\nexports.serializeError = (error, requestId, protocolData) => {\n    let dataFields;\n    const { code, name, triggeredAt, data } = error;\n    dataFields = { code, name, triggeredAt, data, protocolData };\n    return serialize({\n        type: Type.TYPE_ERROR,\n        requestId,\n        data: dataFields\n    });\n};\nexports.serializeMessage = (requestId, protocolData) => {\n    return serialize({\n        type: Type.TYPE_MESSAGE,\n        requestId,\n        data: { protocolData }\n    });\n};\nexports.serializeTransfer = (transfer, requestId, protocolData) => {\n    const { amount } = transfer;\n    return serialize({\n        type: Type.TYPE_TRANSFER,\n        requestId,\n        data: {\n            amount,\n            protocolData\n        }\n    });\n};\n//# sourceMappingURL=index.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"../../node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/btp-packet/dist/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/buffer/index.js':
        /*!**************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/buffer/index.js ***!
  \**************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"../../node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"../../node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"../../node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"../../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/buffer/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/console-browserify/index.js':
        /*!**************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/console-browserify/index.js ***!
  \**************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            '/* WEBPACK VAR INJECTION */(function(global) {/*global window, global*/\nvar util = __webpack_require__(/*! util */ "../../node_modules/util/util.js")\nvar assert = __webpack_require__(/*! assert */ "../../node_modules/assert/assert.js")\nfunction now() { return new Date().getTime() }\n\nvar slice = Array.prototype.slice\nvar console\nvar times = {}\n\nif (typeof global !== "undefined" && global.console) {\n    console = global.console\n} else if (typeof window !== "undefined" && window.console) {\n    console = window.console\n} else {\n    console = {}\n}\n\nvar functions = [\n    [log, "log"],\n    [info, "info"],\n    [warn, "warn"],\n    [error, "error"],\n    [time, "time"],\n    [timeEnd, "timeEnd"],\n    [trace, "trace"],\n    [dir, "dir"],\n    [consoleAssert, "assert"]\n]\n\nfor (var i = 0; i < functions.length; i++) {\n    var tuple = functions[i]\n    var f = tuple[0]\n    var name = tuple[1]\n\n    if (!console[name]) {\n        console[name] = f\n    }\n}\n\nmodule.exports = console\n\nfunction log() {}\n\nfunction info() {\n    console.log.apply(console, arguments)\n}\n\nfunction warn() {\n    console.log.apply(console, arguments)\n}\n\nfunction error() {\n    console.warn.apply(console, arguments)\n}\n\nfunction time(label) {\n    times[label] = now()\n}\n\nfunction timeEnd(label) {\n    var time = times[label]\n    if (!time) {\n        throw new Error("No such label: " + label)\n    }\n\n    delete times[label]\n    var duration = now() - time\n    console.log(label + ": " + duration + "ms")\n}\n\nfunction trace() {\n    var err = new Error()\n    err.name = "Trace"\n    err.message = util.format.apply(null, arguments)\n    console.error(err.stack)\n}\n\nfunction dir(object) {\n    console.log(util.inspect(object) + "\\n")\n}\n\nfunction consoleAssert(expression) {\n    if (!expression) {\n        var arr = slice.call(arguments, 1)\n        assert.ok(false, util.format.apply(null, arr))\n    }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/console-browserify/index.js?'
          )

          /***/
        },

      /***/ '../../node_modules/core-util-is/lib/util.js':
        /*!***********************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/core-util-is/lib/util.js ***!
  \***********************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            "/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"../../node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/core-util-is/lib/util.js?"
          )

          /***/
        },

      /***/ '../../node_modules/dateformat/lib/dateformat.js':
        /*!***************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/dateformat/lib/dateformat.js ***!
  \***************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            "var __WEBPACK_AMD_DEFINE_RESULT__;/*\n * Date Format 1.2.3\n * (c) 2007-2009 Steven Levithan <stevenlevithan.com>\n * MIT license\n *\n * Includes enhancements by Scott Trenda <scott.trenda.net>\n * and Kris Kowal <cixar.com/~kris.kowal/>\n *\n * Accepts a date, a mask, or a date and a mask.\n * Returns a formatted version of the given date.\n * The date defaults to the current date/time.\n * The mask defaults to dateFormat.masks.default.\n */\n\n(function(global) {\n  'use strict';\n\n  var dateFormat = (function() {\n      var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\\1?|[LloSZWN]|\"[^\"]*\"|'[^']*'/g;\n      var timezone = /\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d{4})?)\\b/g;\n      var timezoneClip = /[^-+\\dA-Z]/g;\n  \n      // Regexes and supporting functions are cached through closure\n      return function (date, mask, utc, gmt) {\n  \n        // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)\n        if (arguments.length === 1 && kindOf(date) === 'string' && !/\\d/.test(date)) {\n          mask = date;\n          date = undefined;\n        }\n  \n        date = date || new Date;\n  \n        if(!(date instanceof Date)) {\n          date = new Date(date);\n        }\n  \n        if (isNaN(date)) {\n          throw TypeError('Invalid date');\n        }\n  \n        mask = String(dateFormat.masks[mask] || mask || dateFormat.masks['default']);\n  \n        // Allow setting the utc/gmt argument via the mask\n        var maskSlice = mask.slice(0, 4);\n        if (maskSlice === 'UTC:' || maskSlice === 'GMT:') {\n          mask = mask.slice(4);\n          utc = true;\n          if (maskSlice === 'GMT:') {\n            gmt = true;\n          }\n        }\n  \n        var _ = utc ? 'getUTC' : 'get';\n        var d = date[_ + 'Date']();\n        var D = date[_ + 'Day']();\n        var m = date[_ + 'Month']();\n        var y = date[_ + 'FullYear']();\n        var H = date[_ + 'Hours']();\n        var M = date[_ + 'Minutes']();\n        var s = date[_ + 'Seconds']();\n        var L = date[_ + 'Milliseconds']();\n        var o = utc ? 0 : date.getTimezoneOffset();\n        var W = getWeek(date);\n        var N = getDayOfWeek(date);\n        var flags = {\n          d:    d,\n          dd:   pad(d),\n          ddd:  dateFormat.i18n.dayNames[D],\n          dddd: dateFormat.i18n.dayNames[D + 7],\n          m:    m + 1,\n          mm:   pad(m + 1),\n          mmm:  dateFormat.i18n.monthNames[m],\n          mmmm: dateFormat.i18n.monthNames[m + 12],\n          yy:   String(y).slice(2),\n          yyyy: y,\n          h:    H % 12 || 12,\n          hh:   pad(H % 12 || 12),\n          H:    H,\n          HH:   pad(H),\n          M:    M,\n          MM:   pad(M),\n          s:    s,\n          ss:   pad(s),\n          l:    pad(L, 3),\n          L:    pad(Math.round(L / 10)),\n          t:    H < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1],\n          tt:   H < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3],\n          T:    H < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5],\n          TT:   H < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7],\n          Z:    gmt ? 'GMT' : utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),\n          o:    (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),\n          S:    ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],\n          W:    W,\n          N:    N\n        };\n  \n        return mask.replace(token, function (match) {\n          if (match in flags) {\n            return flags[match];\n          }\n          return match.slice(1, match.length - 1);\n        });\n      };\n    })();\n\n  dateFormat.masks = {\n    'default':               'ddd mmm dd yyyy HH:MM:ss',\n    'shortDate':             'm/d/yy',\n    'mediumDate':            'mmm d, yyyy',\n    'longDate':              'mmmm d, yyyy',\n    'fullDate':              'dddd, mmmm d, yyyy',\n    'shortTime':             'h:MM TT',\n    'mediumTime':            'h:MM:ss TT',\n    'longTime':              'h:MM:ss TT Z',\n    'isoDate':               'yyyy-mm-dd',\n    'isoTime':               'HH:MM:ss',\n    'isoDateTime':           'yyyy-mm-dd\\'T\\'HH:MM:sso',\n    'isoUtcDateTime':        'UTC:yyyy-mm-dd\\'T\\'HH:MM:ss\\'Z\\'',\n    'expiresHeaderFormat':   'ddd, dd mmm yyyy HH:MM:ss Z'\n  };\n\n  // Internationalization strings\n  dateFormat.i18n = {\n    dayNames: [\n      'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',\n      'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'\n    ],\n    monthNames: [\n      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',\n      'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'\n    ],\n    timeNames: [\n      'a', 'p', 'am', 'pm', 'A', 'P', 'AM', 'PM'\n    ]\n  };\n\nfunction pad(val, len) {\n  val = String(val);\n  len = len || 2;\n  while (val.length < len) {\n    val = '0' + val;\n  }\n  return val;\n}\n\n/**\n * Get the ISO 8601 week number\n * Based on comments from\n * http://techblog.procurios.nl/k/n618/news/view/33796/14863/Calculate-ISO-8601-week-and-year-in-javascript.html\n *\n * @param  {Object} `date`\n * @return {Number}\n */\nfunction getWeek(date) {\n  // Remove time components of date\n  var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());\n\n  // Change date to Thursday same week\n  targetThursday.setDate(targetThursday.getDate() - ((targetThursday.getDay() + 6) % 7) + 3);\n\n  // Take January 4th as it is always in week 1 (see ISO 8601)\n  var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);\n\n  // Change date to Thursday same week\n  firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);\n\n  // Check if daylight-saving-time-switch occurred and correct for it\n  var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();\n  targetThursday.setHours(targetThursday.getHours() - ds);\n\n  // Number of weeks between target Thursday and first Thursday\n  var weekDiff = (targetThursday - firstThursday) / (86400000*7);\n  return 1 + Math.floor(weekDiff);\n}\n\n/**\n * Get ISO-8601 numeric representation of the day of the week\n * 1 (for Monday) through 7 (for Sunday)\n * \n * @param  {Object} `date`\n * @return {Number}\n */\nfunction getDayOfWeek(date) {\n  var dow = date.getDay();\n  if(dow === 0) {\n    dow = 7;\n  }\n  return dow;\n}\n\n/**\n * kind-of shortcut\n * @param  {*} val\n * @return {String}\n */\nfunction kindOf(val) {\n  if (val === null) {\n    return 'null';\n  }\n\n  if (val === undefined) {\n    return 'undefined';\n  }\n\n  if (typeof val !== 'object') {\n    return typeof val;\n  }\n\n  if (Array.isArray(val)) {\n    return 'array';\n  }\n\n  return {}.toString.call(val)\n    .slice(8, -1).toLowerCase();\n};\n\n\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return dateFormat;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this);\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/dateformat/lib/dateformat.js?"
          )

          /***/
        },

      /***/ '../../node_modules/debug/src/browser.js':
        /*!*******************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/debug/src/browser.js ***!
  \*******************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            "/* WEBPACK VAR INJECTION */(function(console, process) {/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"../../node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../console-browserify/index.js */ \"../../node_modules/console-browserify/index.js\"), __webpack_require__(/*! ./../../process/browser.js */ \"../../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/debug/src/browser.js?"
          )

          /***/
        },

      /***/ '../../node_modules/debug/src/common.js':
        /*!******************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/debug/src/common.js ***!
  \******************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            "\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"../../node_modules/ms/index.js\");\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/debug/src/common.js?"
          )

          /***/
        },

      /***/ '../../node_modules/eventemitter2/lib/eventemitter2.js':
        /*!*********************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/eventemitter2/lib/eventemitter2.js ***!
  \*********************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            "/* WEBPACK VAR INJECTION */(function(process, console) {var __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * EventEmitter2\r\n * https://github.com/hij1nx/EventEmitter2\r\n *\r\n * Copyright (c) 2013 hij1nx\r\n * Licensed under the MIT license.\r\n */\r\n;!function(undefined) {\r\n\r\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\r\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\r\n  };\r\n  var defaultMaxListeners = 10;\r\n\r\n  function init() {\r\n    this._events = {};\r\n    if (this._conf) {\r\n      configure.call(this, this._conf);\r\n    }\r\n  }\r\n\r\n  function configure(conf) {\r\n    if (conf) {\r\n      this._conf = conf;\r\n\r\n      conf.delimiter && (this.delimiter = conf.delimiter);\r\n      this._maxListeners = conf.maxListeners !== undefined ? conf.maxListeners : defaultMaxListeners;\r\n\r\n      conf.wildcard && (this.wildcard = conf.wildcard);\r\n      conf.newListener && (this._newListener = conf.newListener);\r\n      conf.removeListener && (this._removeListener = conf.removeListener);\r\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\r\n\r\n      if (this.wildcard) {\r\n        this.listenerTree = {};\r\n      }\r\n    } else {\r\n      this._maxListeners = defaultMaxListeners;\r\n    }\r\n  }\r\n\r\n  function logPossibleMemoryLeak(count, eventName) {\r\n    var errorMsg = '(node) warning: possible EventEmitter memory ' +\r\n        'leak detected. ' + count + ' listeners added. ' +\r\n        'Use emitter.setMaxListeners() to increase limit.';\r\n\r\n    if(this.verboseMemoryLeak){\r\n      errorMsg += ' Event name: ' + eventName + '.';\r\n    }\r\n\r\n    if(typeof process !== 'undefined' && process.emitWarning){\r\n      var e = new Error(errorMsg);\r\n      e.name = 'MaxListenersExceededWarning';\r\n      e.emitter = this;\r\n      e.count = count;\r\n      process.emitWarning(e);\r\n    } else {\r\n      console.error(errorMsg);\r\n\r\n      if (console.trace){\r\n        console.trace();\r\n      }\r\n    }\r\n  }\r\n\r\n  function EventEmitter(conf) {\r\n    this._events = {};\r\n    this._newListener = false;\r\n    this._removeListener = false;\r\n    this.verboseMemoryLeak = false;\r\n    configure.call(this, conf);\r\n  }\r\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\r\n\r\n  //\r\n  // Attention, function return type now is array, always !\r\n  // It has zero elements if no any matches found and one or more\r\n  // elements (leafs) if there are matches\r\n  //\r\n  function searchListenerTree(handlers, type, tree, i) {\r\n    if (!tree) {\r\n      return [];\r\n    }\r\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\r\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\r\n    if (i === typeLength && tree._listeners) {\r\n      //\r\n      // If at the end of the event(s) list and the tree has listeners\r\n      // invoke those listeners.\r\n      //\r\n      if (typeof tree._listeners === 'function') {\r\n        handlers && handlers.push(tree._listeners);\r\n        return [tree];\r\n      } else {\r\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\r\n          handlers && handlers.push(tree._listeners[leaf]);\r\n        }\r\n        return [tree];\r\n      }\r\n    }\r\n\r\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\r\n      //\r\n      // If the event emitted is '*' at this part\r\n      // or there is a concrete match at this patch\r\n      //\r\n      if (currentType === '*') {\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\r\n          }\r\n        }\r\n        return listeners;\r\n      } else if(currentType === '**') {\r\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\r\n        if(endReached && tree._listeners) {\r\n          // The next element has a _listeners, add it to the handlers.\r\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\r\n        }\r\n\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            if(branch === '*' || branch === '**') {\r\n              if(tree[branch]._listeners && !endReached) {\r\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\r\n              }\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            } else if(branch === nextType) {\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\r\n            } else {\r\n              // No match on this one, shift into the tree but not in the type array.\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            }\r\n          }\r\n        }\r\n        return listeners;\r\n      }\r\n\r\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\r\n    }\r\n\r\n    xTree = tree['*'];\r\n    if (xTree) {\r\n      //\r\n      // If the listener tree will allow any match for this part,\r\n      // then recursively explore all branches of the tree\r\n      //\r\n      searchListenerTree(handlers, type, xTree, i+1);\r\n    }\r\n\r\n    xxTree = tree['**'];\r\n    if(xxTree) {\r\n      if(i < typeLength) {\r\n        if(xxTree._listeners) {\r\n          // If we have a listener on a '**', it will catch all, so add its handler.\r\n          searchListenerTree(handlers, type, xxTree, typeLength);\r\n        }\r\n\r\n        // Build arrays of matching next branches and others.\r\n        for(branch in xxTree) {\r\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\r\n            if(branch === nextType) {\r\n              // We know the next element will match, so jump twice.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\r\n            } else if(branch === currentType) {\r\n              // Current node matches, move into the tree.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\r\n            } else {\r\n              isolatedBranch = {};\r\n              isolatedBranch[branch] = xxTree[branch];\r\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\r\n            }\r\n          }\r\n        }\r\n      } else if(xxTree._listeners) {\r\n        // We have reached the end and still on a '**'\r\n        searchListenerTree(handlers, type, xxTree, typeLength);\r\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\r\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\r\n      }\r\n    }\r\n\r\n    return listeners;\r\n  }\r\n\r\n  function growListenerTree(type, listener) {\r\n\r\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n\r\n    //\r\n    // Looks for two consecutive '**', if so, don't add the event at all.\r\n    //\r\n    for(var i = 0, len = type.length; i+1 < len; i++) {\r\n      if(type[i] === '**' && type[i+1] === '**') {\r\n        return;\r\n      }\r\n    }\r\n\r\n    var tree = this.listenerTree;\r\n    var name = type.shift();\r\n\r\n    while (name !== undefined) {\r\n\r\n      if (!tree[name]) {\r\n        tree[name] = {};\r\n      }\r\n\r\n      tree = tree[name];\r\n\r\n      if (type.length === 0) {\r\n\r\n        if (!tree._listeners) {\r\n          tree._listeners = listener;\r\n        }\r\n        else {\r\n          if (typeof tree._listeners === 'function') {\r\n            tree._listeners = [tree._listeners];\r\n          }\r\n\r\n          tree._listeners.push(listener);\r\n\r\n          if (\r\n            !tree._listeners.warned &&\r\n            this._maxListeners > 0 &&\r\n            tree._listeners.length > this._maxListeners\r\n          ) {\r\n            tree._listeners.warned = true;\r\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      name = type.shift();\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // By default EventEmitters will print a warning if more than\r\n  // 10 listeners are added to it. This is a useful default which\r\n  // helps finding memory leaks.\r\n  //\r\n  // Obviously not all Emitters should be limited to 10. This function allows\r\n  // that to be increased. Set to zero for unlimited.\r\n\r\n  EventEmitter.prototype.delimiter = '.';\r\n\r\n  EventEmitter.prototype.setMaxListeners = function(n) {\r\n    if (n !== undefined) {\r\n      this._maxListeners = n;\r\n      if (!this._conf) this._conf = {};\r\n      this._conf.maxListeners = n;\r\n    }\r\n  };\r\n\r\n  EventEmitter.prototype.event = '';\r\n\r\n\r\n  EventEmitter.prototype.once = function(event, fn) {\r\n    return this._once(event, fn, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependOnceListener = function(event, fn) {\r\n    return this._once(event, fn, true);\r\n  };\r\n\r\n  EventEmitter.prototype._once = function(event, fn, prepend) {\r\n    this._many(event, 1, fn, prepend);\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.many = function(event, ttl, fn) {\r\n    return this._many(event, ttl, fn, false);\r\n  }\r\n\r\n  EventEmitter.prototype.prependMany = function(event, ttl, fn) {\r\n    return this._many(event, ttl, fn, true);\r\n  }\r\n\r\n  EventEmitter.prototype._many = function(event, ttl, fn, prepend) {\r\n    var self = this;\r\n\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('many only accepts instances of Function');\r\n    }\r\n\r\n    function listener() {\r\n      if (--ttl === 0) {\r\n        self.off(event, listener);\r\n      }\r\n      return fn.apply(this, arguments);\r\n    }\r\n\r\n    listener._origin = fn;\r\n\r\n    this._on(event, listener, prepend);\r\n\r\n    return self;\r\n  };\r\n\r\n  EventEmitter.prototype.emit = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this._newListener) {\r\n      if (!this._events.newListener) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    var al = arguments.length;\r\n    var args,l,i,j;\r\n    var handler;\r\n\r\n    if (this._all && this._all.length) {\r\n      handler = this._all.slice();\r\n      if (al > 3) {\r\n        args = new Array(al);\r\n        for (j = 0; j < al; j++) args[j] = arguments[j];\r\n      }\r\n\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler[i].call(this, type);\r\n          break;\r\n        case 2:\r\n          handler[i].call(this, type, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler[i].call(this, type, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          handler[i].apply(this, args);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    } else {\r\n      handler = this._events[type];\r\n      if (typeof handler === 'function') {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler.call(this);\r\n          break;\r\n        case 2:\r\n          handler.call(this, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler.call(this, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          args = new Array(al - 1);\r\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n          handler.apply(this, args);\r\n        }\r\n        return true;\r\n      } else if (handler) {\r\n        // need to make copy of handlers because list can change in the middle\r\n        // of emit call\r\n        handler = handler.slice();\r\n      }\r\n    }\r\n\r\n    if (handler && handler.length) {\r\n      if (al > 3) {\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n      }\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler[i].call(this);\r\n          break;\r\n        case 2:\r\n          handler[i].call(this, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler[i].call(this, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          handler[i].apply(this, args);\r\n        }\r\n      }\r\n      return true;\r\n    } else if (!this._all && type === 'error') {\r\n      if (arguments[1] instanceof Error) {\r\n        throw arguments[1]; // Unhandled 'error' event\r\n      } else {\r\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n      return false;\r\n    }\r\n\r\n    return !!this._all;\r\n  };\r\n\r\n  EventEmitter.prototype.emitAsync = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this._newListener) {\r\n        if (!this._events.newListener) { return Promise.resolve([false]); }\r\n    }\r\n\r\n    var promises= [];\r\n\r\n    var al = arguments.length;\r\n    var args,l,i,j;\r\n    var handler;\r\n\r\n    if (this._all) {\r\n      if (al > 3) {\r\n        args = new Array(al);\r\n        for (j = 1; j < al; j++) args[j] = arguments[j];\r\n      }\r\n      for (i = 0, l = this._all.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          promises.push(this._all[i].call(this, type));\r\n          break;\r\n        case 2:\r\n          promises.push(this._all[i].call(this, type, arguments[1]));\r\n          break;\r\n        case 3:\r\n          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\r\n          break;\r\n        default:\r\n          promises.push(this._all[i].apply(this, args));\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    } else {\r\n      handler = this._events[type];\r\n    }\r\n\r\n    if (typeof handler === 'function') {\r\n      this.event = type;\r\n      switch (al) {\r\n      case 1:\r\n        promises.push(handler.call(this));\r\n        break;\r\n      case 2:\r\n        promises.push(handler.call(this, arguments[1]));\r\n        break;\r\n      case 3:\r\n        promises.push(handler.call(this, arguments[1], arguments[2]));\r\n        break;\r\n      default:\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n        promises.push(handler.apply(this, args));\r\n      }\r\n    } else if (handler && handler.length) {\r\n      handler = handler.slice();\r\n      if (al > 3) {\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n      }\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          promises.push(handler[i].call(this));\r\n          break;\r\n        case 2:\r\n          promises.push(handler[i].call(this, arguments[1]));\r\n          break;\r\n        case 3:\r\n          promises.push(handler[i].call(this, arguments[1], arguments[2]));\r\n          break;\r\n        default:\r\n          promises.push(handler[i].apply(this, args));\r\n        }\r\n      }\r\n    } else if (!this._all && type === 'error') {\r\n      if (arguments[1] instanceof Error) {\r\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\r\n      } else {\r\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n    }\r\n\r\n    return Promise.all(promises);\r\n  };\r\n\r\n  EventEmitter.prototype.on = function(type, listener) {\r\n    return this._on(type, listener, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependListener = function(type, listener) {\r\n    return this._on(type, listener, true);\r\n  };\r\n\r\n  EventEmitter.prototype.onAny = function(fn) {\r\n    return this._onAny(fn, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependAny = function(fn) {\r\n    return this._onAny(fn, true);\r\n  };\r\n\r\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\r\n  EventEmitter.prototype._onAny = function(fn, prepend){\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('onAny only accepts instances of Function');\r\n    }\r\n\r\n    if (!this._all) {\r\n      this._all = [];\r\n    }\r\n\r\n    // Add the function to the event listener collection.\r\n    if(prepend){\r\n      this._all.unshift(fn);\r\n    }else{\r\n      this._all.push(fn);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  EventEmitter.prototype._on = function(type, listener, prepend) {\r\n    if (typeof type === 'function') {\r\n      this._onAny(type, listener);\r\n      return this;\r\n    }\r\n\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('on only accepts instances of Function');\r\n    }\r\n    this._events || init.call(this);\r\n\r\n    // To avoid recursion in the case that type == \"newListeners\"! Before\r\n    // adding it to the listeners, first emit \"newListeners\".\r\n    if (this._newListener)\r\n       this.emit('newListener', type, listener);\r\n\r\n    if (this.wildcard) {\r\n      growListenerTree.call(this, type, listener);\r\n      return this;\r\n    }\r\n\r\n    if (!this._events[type]) {\r\n      // Optimize the case of one listener. Don't need the extra array object.\r\n      this._events[type] = listener;\r\n    }\r\n    else {\r\n      if (typeof this._events[type] === 'function') {\r\n        // Change to array.\r\n        this._events[type] = [this._events[type]];\r\n      }\r\n\r\n      // If we've already got an array, just add\r\n      if(prepend){\r\n        this._events[type].unshift(listener);\r\n      }else{\r\n        this._events[type].push(listener);\r\n      }\r\n\r\n      // Check for listener leak\r\n      if (\r\n        !this._events[type].warned &&\r\n        this._maxListeners > 0 &&\r\n        this._events[type].length > this._maxListeners\r\n      ) {\r\n        this._events[type].warned = true;\r\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  EventEmitter.prototype.off = function(type, listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('removeListener only takes instances of Function');\r\n    }\r\n\r\n    var handlers,leafs=[];\r\n\r\n    if(this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n    }\r\n    else {\r\n      // does not use listeners(), so no side effect of creating _events[type]\r\n      if (!this._events[type]) return this;\r\n      handlers = this._events[type];\r\n      leafs.push({_listeners:handlers});\r\n    }\r\n\r\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n      var leaf = leafs[iLeaf];\r\n      handlers = leaf._listeners;\r\n      if (isArray(handlers)) {\r\n\r\n        var position = -1;\r\n\r\n        for (var i = 0, length = handlers.length; i < length; i++) {\r\n          if (handlers[i] === listener ||\r\n            (handlers[i].listener && handlers[i].listener === listener) ||\r\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\r\n            position = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (position < 0) {\r\n          continue;\r\n        }\r\n\r\n        if(this.wildcard) {\r\n          leaf._listeners.splice(position, 1);\r\n        }\r\n        else {\r\n          this._events[type].splice(position, 1);\r\n        }\r\n\r\n        if (handlers.length === 0) {\r\n          if(this.wildcard) {\r\n            delete leaf._listeners;\r\n          }\r\n          else {\r\n            delete this._events[type];\r\n          }\r\n        }\r\n        if (this._removeListener)\r\n          this.emit(\"removeListener\", type, listener);\r\n\r\n        return this;\r\n      }\r\n      else if (handlers === listener ||\r\n        (handlers.listener && handlers.listener === listener) ||\r\n        (handlers._origin && handlers._origin === listener)) {\r\n        if(this.wildcard) {\r\n          delete leaf._listeners;\r\n        }\r\n        else {\r\n          delete this._events[type];\r\n        }\r\n        if (this._removeListener)\r\n          this.emit(\"removeListener\", type, listener);\r\n      }\r\n    }\r\n\r\n    function recursivelyGarbageCollect(root) {\r\n      if (root === undefined) {\r\n        return;\r\n      }\r\n      var keys = Object.keys(root);\r\n      for (var i in keys) {\r\n        var key = keys[i];\r\n        var obj = root[key];\r\n        if ((obj instanceof Function) || (typeof obj !== \"object\") || (obj === null))\r\n          continue;\r\n        if (Object.keys(obj).length > 0) {\r\n          recursivelyGarbageCollect(root[key]);\r\n        }\r\n        if (Object.keys(obj).length === 0) {\r\n          delete root[key];\r\n        }\r\n      }\r\n    }\r\n    recursivelyGarbageCollect(this.listenerTree);\r\n\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.offAny = function(fn) {\r\n    var i = 0, l = 0, fns;\r\n    if (fn && this._all && this._all.length > 0) {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++) {\r\n        if(fn === fns[i]) {\r\n          fns.splice(i, 1);\r\n          if (this._removeListener)\r\n            this.emit(\"removeListenerAny\", fn);\r\n          return this;\r\n        }\r\n      }\r\n    } else {\r\n      fns = this._all;\r\n      if (this._removeListener) {\r\n        for(i = 0, l = fns.length; i < l; i++)\r\n          this.emit(\"removeListenerAny\", fns[i]);\r\n      }\r\n      this._all = [];\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\r\n\r\n  EventEmitter.prototype.removeAllListeners = function(type) {\r\n    if (type === undefined) {\r\n      !this._events || init.call(this);\r\n      return this;\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n\r\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n        var leaf = leafs[iLeaf];\r\n        leaf._listeners = null;\r\n      }\r\n    }\r\n    else if (this._events) {\r\n      this._events[type] = null;\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.listeners = function(type) {\r\n    if (this.wildcard) {\r\n      var handlers = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\r\n      return handlers;\r\n    }\r\n\r\n    this._events || init.call(this);\r\n\r\n    if (!this._events[type]) this._events[type] = [];\r\n    if (!isArray(this._events[type])) {\r\n      this._events[type] = [this._events[type]];\r\n    }\r\n    return this._events[type];\r\n  };\r\n\r\n  EventEmitter.prototype.eventNames = function(){\r\n    return Object.keys(this._events);\r\n  }\r\n\r\n  EventEmitter.prototype.listenerCount = function(type) {\r\n    return this.listeners(type).length;\r\n  };\r\n\r\n  EventEmitter.prototype.listenersAny = function() {\r\n\r\n    if(this._all) {\r\n      return this._all;\r\n    }\r\n    else {\r\n      return [];\r\n    }\r\n\r\n  };\r\n\r\n  if (true) {\r\n     // AMD. Register as an anonymous module.\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\r\n      return EventEmitter;\r\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n  } else {}\r\n}();\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"../../node_modules/process/browser.js\"), __webpack_require__(/*! ./../../console-browserify/index.js */ \"../../node_modules/console-browserify/index.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/eventemitter2/lib/eventemitter2.js?"
          )

          /***/
        },

      /***/ '../../node_modules/events/events.js':
        /*!***************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/events/events.js ***!
  \***************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(console) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../console-browserify/index.js */ \"../../node_modules/console-browserify/index.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/events/events.js?"
          )

          /***/
        },

      /***/ '../../node_modules/extensible-error/dist/src/index.js':
        /*!*********************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/extensible-error/dist/src/index.js ***!
  \*********************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nclass ExtensibleError extends Error {\n    constructor(message) {\n        super();\n        Object.defineProperty(this, 'message', {\n            configurable: true,\n            enumerable: false,\n            value: message !== undefined ? String(message) : ''\n        });\n        Object.defineProperty(this, 'name', {\n            configurable: true,\n            enumerable: false,\n            value: this.constructor.name\n        });\n        if (typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n}\nmodule.exports = ExtensibleError;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/extensible-error/dist/src/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ieee754/index.js':
        /*!***************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ieee754/index.js ***!
  \***************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            'exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ieee754/index.js?'
          )

          /***/
        },

      /***/ '../../node_modules/ilp-logger/build/index.js':
        /*!************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-logger/build/index.js ***!
  \************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst debug = __webpack_require__(/*! debug */ \"../../node_modules/debug/src/browser.js\");\nclass Logger {\n    constructor(namespace) {\n        this.info = debug(namespace + ':info');\n        this.warn = debug(namespace + ':warn');\n        this.error = debug(namespace + ':error');\n        this.debug = debug(namespace + ':debug');\n        this.trace = debug(namespace + ':trace');\n    }\n}\nexports.Logger = Logger;\nexports.formatters = debug.formatters;\nconst createLogger = function (namespace) {\n    return new Logger(namespace);\n};\ncreateLogger.default = createLogger;\ncreateLogger.Logger = Logger;\ncreateLogger.formatters = debug.formatters;\nexports.default = createLogger;\nmodule.exports = createLogger;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-logger/build/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-packet/dist/index.js':
        /*!***********************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-packet/dist/index.js ***!
  \***********************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst oer_utils_1 = __webpack_require__(/*! oer-utils */ \"../../node_modules/oer-utils/dist/src/index.js\");\nconst date_1 = __webpack_require__(/*! ./src/utils/date */ \"../../node_modules/ilp-packet/dist/src/utils/date.js\");\nconst assert = __webpack_require__(/*! assert */ \"../../node_modules/assert/assert.js\");\nconst errors = __webpack_require__(/*! ./src/errors */ \"../../node_modules/ilp-packet/dist/src/errors.js\");\nexports.Errors = errors;\nvar Type;\n(function (Type) {\n    Type[Type[\"TYPE_ILP_PREPARE\"] = 12] = \"TYPE_ILP_PREPARE\";\n    Type[Type[\"TYPE_ILP_FULFILL\"] = 13] = \"TYPE_ILP_FULFILL\";\n    Type[Type[\"TYPE_ILP_REJECT\"] = 14] = \"TYPE_ILP_REJECT\";\n})(Type = exports.Type || (exports.Type = {}));\nexports.errorToReject = (address, error) => {\n    return exports.serializeIlpReject({\n        code: error.ilpErrorCode || 'F00',\n        triggeredBy: address,\n        message: error.message || '',\n        data: error.ilpErrorData || Buffer.alloc(0)\n    });\n};\nexports.deserializeEnvelope = (binary) => {\n    const envelopeReader = oer_utils_1.Reader.from(binary);\n    const type = envelopeReader.readUInt8Number();\n    const contents = envelopeReader.readVarOctetString();\n    return { type, contents };\n};\nexports.serializeIlpPrepare = (json) => {\n    assert(json.amount && typeof json.amount === 'string', 'amount must be a string');\n    assert(Buffer.isBuffer(json.executionCondition) &&\n        json.executionCondition.length === 32, 'executionCondition must be a 32-byte buffer');\n    assert(json.expiresAt && json.expiresAt instanceof Date, 'expiresAt must be a Date');\n    assert(typeof json.destination === 'string', 'destination is required');\n    assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer');\n    const expiresAt = Buffer.from(date_1.dateToInterledgerTime(json.expiresAt), 'ascii');\n    const destination = Buffer.from(json.destination, 'ascii');\n    const contentSize = 8 +\n        date_1.INTERLEDGER_TIME_LENGTH +\n        32 +\n        oer_utils_1.Predictor.measureVarOctetString(destination.length) +\n        oer_utils_1.Predictor.measureVarOctetString(json.data.length);\n    const envelopeSize = 1 + oer_utils_1.Predictor.measureVarOctetString(contentSize);\n    const envelope = new oer_utils_1.Writer(envelopeSize);\n    envelope.writeUInt8(Type.TYPE_ILP_PREPARE);\n    const content = envelope.createVarOctetString(contentSize);\n    content.writeUInt64(json.amount);\n    content.write(expiresAt);\n    content.write(json.executionCondition);\n    content.writeVarOctetString(destination);\n    content.writeVarOctetString(json.data);\n    return envelope.getBuffer();\n};\nexports.deserializeIlpPrepare = (binary) => {\n    const { type, contents } = exports.deserializeEnvelope(binary);\n    if (+type !== Type.TYPE_ILP_PREPARE) {\n        throw new Error('Packet has incorrect type');\n    }\n    const reader = oer_utils_1.Reader.from(contents);\n    const amount = reader.readUInt64();\n    const expiresAt = date_1.interledgerTimeToDate(reader.read(date_1.INTERLEDGER_TIME_LENGTH).toString('ascii'));\n    const executionCondition = reader.read(32);\n    const destination = reader.readVarOctetString().toString('ascii');\n    const data = reader.readVarOctetString();\n    return {\n        amount,\n        executionCondition,\n        expiresAt,\n        destination,\n        data\n    };\n};\nexports.serializeIlpFulfill = (json) => {\n    assert(Buffer.isBuffer(json.fulfillment) &&\n        json.fulfillment.length === 32, 'fulfillment must be a 32-byte buffer');\n    assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer');\n    const contentSize = 32 + oer_utils_1.Predictor.measureVarOctetString(json.data.length);\n    const envelopeSize = 1 + oer_utils_1.Predictor.measureVarOctetString(contentSize);\n    const envelope = new oer_utils_1.Writer(envelopeSize);\n    envelope.writeUInt8(Type.TYPE_ILP_FULFILL);\n    const content = envelope.createVarOctetString(contentSize);\n    content.write(json.fulfillment);\n    content.writeVarOctetString(json.data);\n    return envelope.getBuffer();\n};\nexports.deserializeIlpFulfill = (binary) => {\n    const { type, contents } = exports.deserializeEnvelope(binary);\n    if (+type !== Type.TYPE_ILP_FULFILL) {\n        throw new Error('Packet has incorrect type');\n    }\n    const reader = oer_utils_1.Reader.from(contents);\n    const fulfillment = reader.read(32);\n    const data = reader.readVarOctetString();\n    return {\n        fulfillment,\n        data\n    };\n};\nconst ILP_ERROR_CODE_LENGTH = 3;\nconst EMPTY_BUFFER = Buffer.alloc(0);\nexports.serializeIlpReject = (json) => {\n    assert(json.code && typeof json.code === 'string', 'code must be a string');\n    assert(typeof json.triggeredBy === 'string', 'triggeredBy must be a string');\n    assert(typeof json.message === 'string', 'message must be a string');\n    assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer');\n    const codeBuffer = Buffer.from(json.code, 'ascii');\n    if (codeBuffer.length !== ILP_ERROR_CODE_LENGTH) {\n        throw new Error('ILP error codes must be three bytes long, received: ' + json.code);\n    }\n    const triggeredBy = Buffer.from(json.triggeredBy, 'ascii');\n    const message = Buffer.from(json.message, 'utf8');\n    const data = json.data || EMPTY_BUFFER;\n    const contentSize = ILP_ERROR_CODE_LENGTH +\n        oer_utils_1.Predictor.measureVarOctetString(triggeredBy.length) +\n        oer_utils_1.Predictor.measureVarOctetString(message.length) +\n        oer_utils_1.Predictor.measureVarOctetString(data.length);\n    const envelopeSize = 1 + oer_utils_1.Predictor.measureVarOctetString(contentSize);\n    const envelope = new oer_utils_1.Writer(envelopeSize);\n    envelope.writeUInt8(Type.TYPE_ILP_REJECT);\n    const content = envelope.createVarOctetString(contentSize);\n    content.write(codeBuffer);\n    content.writeVarOctetString(triggeredBy);\n    content.writeVarOctetString(message);\n    content.writeVarOctetString(data);\n    return envelope.getBuffer();\n};\nexports.deserializeIlpReject = (binary) => {\n    const { type, contents } = exports.deserializeEnvelope(binary);\n    if (+type !== Type.TYPE_ILP_REJECT) {\n        throw new Error('Packet has incorrect type');\n    }\n    const reader = oer_utils_1.Reader.from(contents);\n    const code = reader.read(ILP_ERROR_CODE_LENGTH).toString('ascii');\n    const triggeredBy = reader.readVarOctetString().toString('ascii');\n    const message = reader.readVarOctetString().toString('utf8');\n    const data = reader.readVarOctetString();\n    return {\n        code,\n        triggeredBy,\n        message,\n        data\n    };\n};\nexports.serializeIlpPacket = (obj) => {\n    switch (obj.type) {\n        case Type.TYPE_ILP_PREPARE: return exports.serializeIlpPrepare(obj.data);\n        case Type.TYPE_ILP_FULFILL: return exports.serializeIlpFulfill(obj.data);\n        case Type.TYPE_ILP_REJECT: return exports.serializeIlpReject(obj.data);\n        default: throw new Error('Object has invalid type');\n    }\n};\nexports.deserializeIlpPacket = (binary) => {\n    if (binary[0] === Type.TYPE_ILP_PREPARE) {\n        return {\n            type: binary[0],\n            typeString: 'ilp_prepare',\n            data: exports.deserializeIlpPrepare(binary)\n        };\n    }\n    else if (binary[0] === Type.TYPE_ILP_FULFILL) {\n        return {\n            type: binary[0],\n            typeString: 'ilp_fulfill',\n            data: exports.deserializeIlpFulfill(binary)\n        };\n    }\n    else if (binary[0] === Type.TYPE_ILP_REJECT) {\n        return {\n            type: binary[0],\n            typeString: 'ilp_reject',\n            data: exports.deserializeIlpReject(binary)\n        };\n    }\n    else {\n        throw new Error('Packet has invalid type');\n    }\n};\nfunction deserializeIlpReply(data) {\n    return exports.deserializeIlpPacket(data).data;\n}\nexports.deserializeIlpReply = deserializeIlpReply;\nfunction serializeIlpReply(packet) {\n    return isFulfill(packet) ? exports.serializeIlpFulfill(packet) : exports.serializeIlpReject(packet);\n}\nexports.serializeIlpReply = serializeIlpReply;\nexports.errorToIlpReject = (address, error) => {\n    return {\n        code: error.ilpErrorCode || 'F00',\n        triggeredBy: address,\n        message: error.message || '',\n        data: error.ilpErrorData || Buffer.alloc(0)\n    };\n};\nfunction isPrepare(packet) {\n    return typeof packet['amount'] === 'string' &&\n        typeof packet['expiresAt'] !== 'undefined' &&\n        typeof packet['destination'] === 'string' &&\n        Buffer.isBuffer(packet['executionCondition']) &&\n        Buffer.isBuffer(packet['data']);\n}\nexports.isPrepare = isPrepare;\nfunction isFulfill(packet) {\n    return Buffer.isBuffer(packet['fulfillment']) &&\n        Buffer.isBuffer(packet['data']);\n}\nexports.isFulfill = isFulfill;\nfunction isReject(packet) {\n    return typeof packet['code'] === 'string' &&\n        typeof packet['triggeredBy'] === 'string' &&\n        typeof packet['message'] === 'string' &&\n        Buffer.isBuffer(packet['data']);\n}\nexports.isReject = isReject;\n//# sourceMappingURL=index.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"../../node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-packet/dist/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-packet/dist/src/errors.js':
        /*!****************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-packet/dist/src/errors.js ***!
  \****************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst oer_utils_1 = __webpack_require__(/*! oer-utils */ \"../../node_modules/oer-utils/dist/src/index.js\");\nconst BaseError = __webpack_require__(/*! extensible-error */ \"../../node_modules/extensible-error/dist/src/index.js\");\nexports.codes = {\n    F00_BAD_REQUEST: 'F00',\n    F01_INVALID_PACKET: 'F01',\n    F02_UNREACHABLE: 'F02',\n    F03_INVALID_AMOUNT: 'F03',\n    F04_INSUFFICIENT_DESTINATION_AMOUNT: 'F04',\n    F05_WRONG_CONDITION: 'F05',\n    F06_UNEXPECTED_PAYMENT: 'F06',\n    F07_CANNOT_RECEIVE: 'F07',\n    F08_AMOUNT_TOO_LARGE: 'F08',\n    F99_APPLICATION_ERROR: 'F99',\n    T00_INTERNAL_ERROR: 'T00',\n    T01_PEER_UNREACHABLE: 'T01',\n    T02_PEER_BUSY: 'T02',\n    T03_CONNECTOR_BUSY: 'T03',\n    T04_INSUFFICIENT_LIQUIDITY: 'T04',\n    T05_RATE_LIMITED: 'T05',\n    T99_APPLICATION_ERROR: 'T99',\n    R00_TRANSFER_TIMED_OUT: 'R00',\n    R01_INSUFFICIENT_SOURCE_AMOUNT: 'R01',\n    R02_INSUFFICIENT_TIMEOUT: 'R02',\n    R99_APPLICATION_ERROR: 'R99'\n};\nclass BadRequestError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.F00_BAD_REQUEST;\n    }\n}\nexports.BadRequestError = BadRequestError;\nclass InvalidPacketError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.F01_INVALID_PACKET;\n    }\n}\nexports.InvalidPacketError = InvalidPacketError;\nclass UnreachableError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.F02_UNREACHABLE;\n    }\n}\nexports.UnreachableError = UnreachableError;\nclass InvalidAmountError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.F03_INVALID_AMOUNT;\n    }\n}\nexports.InvalidAmountError = InvalidAmountError;\nclass InsufficientDestinationAmountError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.F04_INSUFFICIENT_DESTINATION_AMOUNT;\n    }\n}\nexports.InsufficientDestinationAmountError = InsufficientDestinationAmountError;\nclass WrongConditionError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.F05_WRONG_CONDITION;\n    }\n}\nexports.WrongConditionError = WrongConditionError;\nclass UnexpectedPaymentError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.F06_UNEXPECTED_PAYMENT;\n    }\n}\nexports.UnexpectedPaymentError = UnexpectedPaymentError;\nclass CannotReceiveError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.F07_CANNOT_RECEIVE;\n    }\n}\nexports.CannotReceiveError = CannotReceiveError;\nclass AmountTooLargeError extends BaseError {\n    constructor(message, opts) {\n        super(message);\n        this.ilpErrorCode = exports.codes.F08_AMOUNT_TOO_LARGE;\n        const writer = new oer_utils_1.Writer(8 + 8);\n        writer.writeUInt64(opts.receivedAmount);\n        writer.writeUInt64(opts.maximumAmount);\n        this.ilpErrorData = writer.getBuffer();\n    }\n}\nexports.AmountTooLargeError = AmountTooLargeError;\nclass FinalApplicationError extends BaseError {\n    constructor(message, data) {\n        super(message);\n        this.ilpErrorCode = exports.codes.F99_APPLICATION_ERROR;\n        this.ilpErrorData = data;\n    }\n}\nexports.FinalApplicationError = FinalApplicationError;\nclass InternalError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.T00_INTERNAL_ERROR;\n    }\n}\nexports.InternalError = InternalError;\nclass PeerUnreachableError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.T01_PEER_UNREACHABLE;\n    }\n}\nexports.PeerUnreachableError = PeerUnreachableError;\nclass PeerBusyError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.T02_PEER_BUSY;\n    }\n}\nexports.PeerBusyError = PeerBusyError;\nclass ConnectorBusyError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.T03_CONNECTOR_BUSY;\n    }\n}\nexports.ConnectorBusyError = ConnectorBusyError;\nclass InsufficientLiquidityError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.T04_INSUFFICIENT_LIQUIDITY;\n    }\n}\nexports.InsufficientLiquidityError = InsufficientLiquidityError;\nclass RateLimitedError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.T05_RATE_LIMITED;\n    }\n}\nexports.RateLimitedError = RateLimitedError;\nclass TemporaryApplicationError extends BaseError {\n    constructor(message, data) {\n        super(message);\n        this.ilpErrorCode = exports.codes.T99_APPLICATION_ERROR;\n        this.ilpErrorData = data;\n    }\n}\nexports.TemporaryApplicationError = TemporaryApplicationError;\nclass TransferTimedOutError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.R00_TRANSFER_TIMED_OUT;\n    }\n}\nexports.TransferTimedOutError = TransferTimedOutError;\nclass InsufficientSourceAmountError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.R01_INSUFFICIENT_SOURCE_AMOUNT;\n    }\n}\nexports.InsufficientSourceAmountError = InsufficientSourceAmountError;\nclass InsufficientTimeoutError extends BaseError {\n    constructor(message) {\n        super(message);\n        this.ilpErrorCode = exports.codes.R02_INSUFFICIENT_TIMEOUT;\n    }\n}\nexports.InsufficientTimeoutError = InsufficientTimeoutError;\nclass RelativeApplicationError extends BaseError {\n    constructor(message, data) {\n        super(message);\n        this.ilpErrorCode = exports.codes.R99_APPLICATION_ERROR;\n        this.ilpErrorData = data;\n    }\n}\nexports.RelativeApplicationError = RelativeApplicationError;\n//# sourceMappingURL=errors.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-packet/dist/src/errors.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-packet/dist/src/utils/date.js':
        /*!********************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-packet/dist/src/utils/date.js ***!
  \********************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction pad(n) {\n    return n < 10\n        ? '0' + n\n        : String(n);\n}\nexports.dateToInterledgerTime = (date) => {\n    return date.getUTCFullYear() +\n        pad(date.getUTCMonth() + 1) +\n        pad(date.getUTCDate()) +\n        pad(date.getUTCHours()) +\n        pad(date.getUTCMinutes()) +\n        pad(date.getUTCSeconds()) +\n        (date.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5);\n};\nexports.INTERLEDGER_TIME_LENGTH = 17;\nexports.interledgerTimeToDate = (interledgerTime) => {\n    const date = new Date(Date.UTC(+interledgerTime.slice(0, 4), +interledgerTime.slice(4, 6) - 1, +interledgerTime.slice(6, 8), +interledgerTime.slice(8, 10), +interledgerTime.slice(10, 12), +interledgerTime.slice(12, 14), +interledgerTime.slice(14, 17)));\n    if (!date.valueOf()) {\n        throw new Error('invalid date');\n    }\n    return date;\n};\nexports.dateToGeneralizedTime = (date) => {\n    return date.toISOString().replace(/[\\-T:]/g, '');\n};\nexports.GENERALIZED_TIME_REGEX = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2}\\.[0-9]{3}Z)$/;\nexports.generalizedTimeToDate = (generalizedTime) => {\n    const isoTimestamp = generalizedTime.replace(exports.GENERALIZED_TIME_REGEX, '$1-$2-$3T$4:$5:$6');\n    const date = new Date(isoTimestamp);\n    if (!date.valueOf()) {\n        throw new Error('invalid date');\n    }\n    return date;\n};\n//# sourceMappingURL=date.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-packet/dist/src/utils/date.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-plugin-btp/build/browser/crypto.js':
        /*!*************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/build/browser/crypto.js ***!
  \*************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, "__esModule", { value: true });\nconst { crypto } = window;\nfunction randomBytes(size, callback) {\n    const randArray = new Uint8Array(size);\n    const randValues = crypto.getRandomValues(randArray);\n    callback(null, Buffer.from(randValues));\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=crypto.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "../../node_modules/buffer/index.js").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/build/browser/crypto.js?'
          )

          /***/
        },

      /***/ '../../node_modules/ilp-plugin-btp/build/browser/ws.js':
        /*!*********************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/build/browser/ws.js ***!
  \*********************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(Buffer, process) {\nconst events_1 = __webpack_require__(/*! events */ \"../../node_modules/events/events.js\");\nclass WebSocketPolyfill extends events_1.EventEmitter {\n    constructor(uri) {\n        super();\n        this._ws = new WebSocket(uri);\n        this._ws.binaryType = 'arraybuffer';\n        this._ws.onerror = this.emit.bind(this, 'error');\n        this._ws.onopen = this.emit.bind(this, 'open');\n        this._ws.onclose = this.emit.bind(this, 'close');\n        this._ws.onmessage = (msg) => {\n            this.emit('message', Buffer.from(msg.data));\n        };\n    }\n    send(msg, cb) {\n        if (this._ws.readyState === WebSocket.CONNECTING || this._ws.readyState === WebSocket.OPEN) {\n            this._ws.send(msg.buffer);\n            process.nextTick(cb);\n        }\n        else {\n            process.nextTick(cb, new Error('already closed'));\n        }\n    }\n    ping() { }\n    close() {\n        this._ws.close();\n    }\n}\nmodule.exports = WebSocketPolyfill;\n//# sourceMappingURL=ws.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ \"../../node_modules/buffer/index.js\").Buffer, __webpack_require__(/*! ./../../../process/browser.js */ \"../../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/build/browser/ws.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-plugin-btp/build/index.js':
        /*!****************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/build/index.js ***!
  \****************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = __webpack_require__(/*! assert */ \"../../node_modules/assert/assert.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"../../node_modules/ilp-plugin-btp/build/browser/crypto.js\");\nconst Debug = __webpack_require__(/*! debug */ \"../../node_modules/ilp-plugin-btp/node_modules/debug/src/browser.js\");\nconst WebSocket = __webpack_require__(/*! ws */ \"../../node_modules/ilp-plugin-btp/build/browser/ws.js\");\nconst ws_reconnect_1 = __webpack_require__(/*! ./ws-reconnect */ \"../../node_modules/ilp-plugin-btp/build/ws-reconnect.js\");\nconst eventemitter2_1 = __webpack_require__(/*! eventemitter2 */ \"../../node_modules/eventemitter2/lib/eventemitter2.js\");\nconst protocol_data_converter_1 = __webpack_require__(/*! ./protocol-data-converter */ \"../../node_modules/ilp-plugin-btp/build/protocol-data-converter.js\");\nconst BtpPacket = __webpack_require__(/*! btp-packet */ \"../../node_modules/btp-packet/dist/index.js\");\nconst debug = __webpack_require__(/*! ilp-logger */ \"../../node_modules/ilp-logger/build/index.js\")('ilp-plugin-btp');\nvar ReadyState;\n(function (ReadyState) {\n    ReadyState[ReadyState[\"INITIAL\"] = 0] = \"INITIAL\";\n    ReadyState[ReadyState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    ReadyState[ReadyState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n    ReadyState[ReadyState[\"DISCONNECTED\"] = 3] = \"DISCONNECTED\";\n    ReadyState[ReadyState[\"READY_TO_EMIT\"] = 4] = \"READY_TO_EMIT\";\n})(ReadyState || (ReadyState = {}));\nconst DEFAULT_TIMEOUT = 35000;\nconst namesToCodes = {\n    'UnreachableError': 'T00',\n    'NotAcceptedError': 'F00',\n    'InvalidFieldsError': 'F01',\n    'TransferNotFoundError': 'F03',\n    'InvalidFulfillmentError': 'F04',\n    'DuplicateIdError': 'F05',\n    'AlreadyRolledBackError': 'F06',\n    'AlreadyFulfilledError': 'F07',\n    'InsufficientBalanceError': 'F08'\n};\nconst toBrowserSafeURL = (btpUrl) => {\n    if (!btpUrl.startsWith('btp+')) {\n        throw new Error('server must start with \"btp+\". server=' + btpUrl);\n    }\n    return new URL(btpUrl.substring(4));\n};\nfunction jsErrorToBtpError(e) {\n    const name = e.name || 'NotAcceptedError';\n    const code = namesToCodes[name] || 'F00';\n    return {\n        code,\n        name,\n        triggeredAt: new Date(),\n        data: JSON.stringify({ message: e.message })\n    };\n}\nconst ILP_PACKET_TYPES = {\n    12: 'ilp-prepare',\n    13: 'ilp-fulfill',\n    14: 'ilp-reject'\n};\nfunction subProtocolToString(data) {\n    let stringData;\n    switch (data.contentType) {\n        case BtpPacket.MIME_APPLICATION_OCTET_STREAM:\n            stringData = data.data.toString('base64');\n            break;\n        case BtpPacket.MIME_APPLICATION_JSON:\n        case BtpPacket.MIME_TEXT_PLAIN_UTF8:\n            stringData = data.data.toString('utf8');\n            break;\n    }\n    return `${data.protocolName}=${stringData}`;\n}\nfunction generatePacketDataTracer(packetData) {\n    return {\n        toString: () => {\n            try {\n                return packetData.protocolData.map(data => {\n                    switch (data.protocolName) {\n                        case 'ilp':\n                            return ILP_PACKET_TYPES[data.data[0]] || ('ilp-' + data.data[0]);\n                        default:\n                            return subProtocolToString(data);\n                    }\n                }).join(';');\n            }\n            catch (err) {\n                return 'serialization error. err=' + err.stack;\n            }\n        }\n    };\n}\nclass AbstractBtpPlugin extends eventemitter2_1.EventEmitter2 {\n    constructor(options, modules) {\n        super();\n        this._readyState = ReadyState.INITIAL;\n        this._wss = null;\n        this._reconnectInterval = options.reconnectInterval;\n        this._reconnectIntervals = options.reconnectIntervals;\n        this._reconnectClearTryTimeout = options.reconnectClearTryTimeout;\n        this._responseTimeout = options.responseTimeout || DEFAULT_TIMEOUT;\n        this._listener = options.listener;\n        this._server = options.server;\n        if (this._listener) {\n            this._listenerSecret = Buffer.from(this._listener.secret, 'utf8');\n            this._listener.wsOpts = this._listener.wsOpts || { port: this._listener.port };\n            if (this._listener.wsOpts.server) {\n                this._httpServer = this._listener.wsOpts.server;\n            }\n        }\n        if (this._server) {\n            const parsedBtpUri = toBrowserSafeURL(this._server);\n            const parsedAccount = parsedBtpUri.username;\n            const parsedToken = parsedBtpUri.password;\n            if ((parsedAccount || parsedToken) && (options.btpAccount || options.btpToken)) {\n                throw new Error('account/token must be passed in via constructor or uri, but not both');\n            }\n            this._btpToken = parsedToken || options.btpToken || '';\n            this._btpAccount = parsedAccount || options.btpAccount || '';\n        }\n        modules = modules || {};\n        this._log = modules.log || debug;\n        this._log.trace = this._log.trace || Debug(this._log.debug.namespace + ':trace');\n        this.WebSocket = modules.WebSocket || WebSocket;\n        this.WebSocketServer = modules.WebSocketServer || WebSocket.Server;\n    }\n    async _connect(...opts) { }\n    async _disconnect() { }\n    async connect() {\n        if (this._readyState > ReadyState.INITIAL) {\n            return;\n        }\n        this._readyState = ReadyState.CONNECTING;\n        if (this._listener) {\n            if (this._httpServer) {\n                this._httpServer.listen(this._listener.port);\n            }\n            const wss = this._wss = new (this.WebSocketServer)(Object.assign({}, this._listener.wsOpts));\n            this._incomingWs = undefined;\n            wss.on('connection', (socket) => {\n                this._log.info('got connection');\n                let authPacket;\n                socket.on('close', (code) => {\n                    this._log.info('incoming websocket closed. code=' + code);\n                    this._emitDisconnect();\n                });\n                socket.on('error', (err) => {\n                    this._log.debug('incoming websocket error. error=', err);\n                    this._emitDisconnect();\n                });\n                socket.once('message', async (binaryAuthMessage) => {\n                    try {\n                        authPacket = BtpPacket.deserialize(binaryAuthMessage);\n                        this._log.trace('got auth packet. packet=%j', authPacket);\n                        this._validateAuthPacket(authPacket);\n                        if (this._incomingWs) {\n                            this._closeIncomingSocket(this._incomingWs, authPacket);\n                        }\n                        this._incomingWs = socket;\n                        socket.send(BtpPacket.serializeResponse(authPacket.requestId, []));\n                    }\n                    catch (err) {\n                        this._incomingWs = undefined;\n                        if (authPacket) {\n                            const errorResponse = BtpPacket.serializeError({\n                                code: 'F00',\n                                name: 'NotAcceptedError',\n                                data: err.message,\n                                triggeredAt: new Date().toISOString()\n                            }, authPacket.requestId, []);\n                            socket.send(errorResponse);\n                        }\n                        socket.close();\n                        return;\n                    }\n                    this._log.trace('connection authenticated');\n                    socket.on('message', this._handleIncomingWsMessage.bind(this, socket));\n                    this._emitConnect();\n                });\n            });\n            this._log.info(`listening for BTP connections on ${this._listener.port}`);\n        }\n        if (this._server) {\n            const parsedBtpUri = toBrowserSafeURL(this._server);\n            const account = this._btpAccount || '';\n            const token = this._btpToken || '';\n            this._ws = new ws_reconnect_1.WebSocketReconnector({\n                WebSocket: this.WebSocket,\n                intervals: this._reconnectIntervals,\n                interval: this._reconnectInterval,\n                clearTryTimeout: this._reconnectClearTryTimeout\n            });\n            const protocolData = [{\n                    protocolName: 'auth',\n                    contentType: BtpPacket.MIME_APPLICATION_OCTET_STREAM,\n                    data: Buffer.from([])\n                }, {\n                    protocolName: 'auth_username',\n                    contentType: BtpPacket.MIME_TEXT_PLAIN_UTF8,\n                    data: Buffer.from(account, 'utf8')\n                }, {\n                    protocolName: 'auth_token',\n                    contentType: BtpPacket.MIME_TEXT_PLAIN_UTF8,\n                    data: Buffer.from(token, 'utf8')\n                }];\n            this._ws.on('open', async () => {\n                this._log.trace('connected to server');\n                this._call('', {\n                    type: BtpPacket.TYPE_MESSAGE,\n                    requestId: await _requestId(),\n                    data: { protocolData }\n                }).then(() => {\n                    this._emitConnect();\n                }).catch((err) => {\n                    this._log.error('error authenticating btp connection', err.message);\n                });\n            });\n            parsedBtpUri.username = '';\n            parsedBtpUri.password = '';\n            await this._ws.open(parsedBtpUri.toString());\n            this._ws.on('close', () => this._emitDisconnect());\n            this._ws.on('message', this._handleIncomingWsMessage.bind(this, this._ws));\n        }\n        await new Promise((resolve, reject) => {\n            const onDisconnect = () => {\n                if (this._ws)\n                    this._ws.close();\n                reject(new Error('connection aborted'));\n            };\n            this.once('disconnect', onDisconnect);\n            this.once('_first_time_connect', () => {\n                this.removeListener('disconnect', onDisconnect);\n                resolve();\n            });\n        });\n        await this._connect();\n        this._readyState = ReadyState.READY_TO_EMIT;\n        this._emitConnect();\n    }\n    _closeIncomingSocket(socket, authPacket) {\n        socket.removeAllListeners();\n        socket.once('message', async (data) => {\n            try {\n                socket.send(BtpPacket.serializeError({\n                    code: 'F00',\n                    name: 'NotAcceptedError',\n                    data: 'This connection has been ended because the user has opened a new connection',\n                    triggeredAt: new Date().toISOString()\n                }, authPacket.requestId, []));\n            }\n            catch (e) {\n                this._log.error('error responding on closed socket', e);\n            }\n            socket.close();\n        });\n    }\n    async disconnect() {\n        this._emitDisconnect();\n        await this._disconnect();\n        if (this._ws)\n            this._ws.close();\n        if (this._incomingWs) {\n            this._incomingWs.close();\n            this._incomingWs = undefined;\n        }\n        if (this._wss) {\n            this._wss.close();\n            if (this._httpServer) {\n                this._httpServer.close();\n            }\n            this._wss = null;\n        }\n    }\n    isConnected() {\n        return this._readyState === ReadyState.CONNECTED;\n    }\n    async _handleIncomingWsMessage(ws, binaryMessage) {\n        let btpPacket;\n        try {\n            btpPacket = BtpPacket.deserialize(binaryMessage);\n        }\n        catch (err) {\n            this._log.error('deserialization error:', err);\n            ws.close();\n            return;\n        }\n        try {\n            await this._handleIncomingBtpPacket('', btpPacket);\n        }\n        catch (err) {\n            this._log.debug(`Error processing BTP packet of type ${btpPacket.type}: `, err);\n            const error = jsErrorToBtpError(err);\n            const requestId = btpPacket.requestId;\n            const { code, name, triggeredAt, data } = error;\n            await this._handleOutgoingBtpPacket('', {\n                type: BtpPacket.TYPE_ERROR,\n                requestId,\n                data: {\n                    code,\n                    name,\n                    triggeredAt,\n                    data,\n                    protocolData: []\n                }\n            });\n        }\n    }\n    async sendData(buffer) {\n        const response = await this._call('', {\n            type: BtpPacket.TYPE_MESSAGE,\n            requestId: await _requestId(),\n            data: { protocolData: [{\n                        protocolName: 'ilp',\n                        contentType: BtpPacket.MIME_APPLICATION_OCTET_STREAM,\n                        data: buffer\n                    }] }\n        });\n        const ilpResponse = response.protocolData\n            .filter(p => p.protocolName === 'ilp')[0];\n        return ilpResponse\n            ? ilpResponse.data\n            : Buffer.alloc(0);\n    }\n    async sendMoney(amount) {\n    }\n    _safeEmit() {\n        try {\n            this.emit.apply(this, arguments);\n        }\n        catch (err) {\n            const errInfo = (typeof err === 'object' && err.stack) ? err.stack : String(err);\n            this._log.error('error in handler for event', arguments, errInfo);\n        }\n    }\n    registerDataHandler(handler) {\n        if (this._dataHandler) {\n            throw new Error('requestHandler is already registered');\n        }\n        if (typeof handler !== 'function') {\n            throw new Error('requestHandler must be a function');\n        }\n        this._log.trace('registering data handler');\n        this._dataHandler = handler;\n    }\n    deregisterDataHandler() {\n        this._dataHandler = undefined;\n    }\n    registerMoneyHandler(handler) {\n        if (this._moneyHandler) {\n            throw new Error('requestHandler is already registered');\n        }\n        if (typeof handler !== 'function') {\n            throw new Error('requestHandler must be a function');\n        }\n        this._log.trace('registering money handler');\n        this._moneyHandler = handler;\n    }\n    deregisterMoneyHandler() {\n        this._moneyHandler = undefined;\n    }\n    protocolDataToIlpAndCustom(packet) {\n        return protocol_data_converter_1.protocolDataToIlpAndCustom(packet);\n    }\n    ilpAndCustomToProtocolData(obj) {\n        return protocol_data_converter_1.ilpAndCustomToProtocolData(obj);\n    }\n    async _call(to, btpPacket) {\n        const requestId = btpPacket.requestId;\n        let callback;\n        let timer;\n        const response = new Promise((resolve, reject) => {\n            callback = (type, data) => {\n                switch (type) {\n                    case BtpPacket.TYPE_RESPONSE:\n                        resolve(data);\n                        clearTimeout(timer);\n                        break;\n                    case BtpPacket.TYPE_ERROR:\n                        reject(new Error(JSON.stringify(data)));\n                        clearTimeout(timer);\n                        break;\n                    default:\n                        throw new Error('Unknown BTP packet type: ' + type);\n                }\n            };\n            this.once('__callback_' + requestId, callback);\n        });\n        await this._handleOutgoingBtpPacket(to, btpPacket);\n        const timeout = new Promise((resolve, reject) => {\n            timer = setTimeout(() => {\n                this.removeListener('__callback_' + requestId, callback);\n                reject(new Error(requestId + ' timed out'));\n            }, this._responseTimeout);\n        });\n        return Promise.race([\n            response,\n            timeout\n        ]);\n    }\n    async _handleIncomingBtpPacket(from, btpPacket) {\n        const { type, requestId, data } = btpPacket;\n        const typeString = BtpPacket.typeToString(type);\n        this._log.trace(`received btp packet. type=${typeString} requestId=${requestId} info=${generatePacketDataTracer(data)}`);\n        let result;\n        switch (type) {\n            case BtpPacket.TYPE_RESPONSE:\n            case BtpPacket.TYPE_ERROR:\n                this.emit('__callback_' + requestId, type, data);\n                return;\n            case BtpPacket.TYPE_PREPARE:\n            case BtpPacket.TYPE_FULFILL:\n            case BtpPacket.TYPE_REJECT:\n                throw new Error('Unsupported BTP packet');\n            case BtpPacket.TYPE_TRANSFER:\n                result = await this._handleMoney(from, btpPacket);\n                break;\n            case BtpPacket.TYPE_MESSAGE:\n                result = await this._handleData(from, btpPacket);\n                break;\n            default:\n                throw new Error('Unknown BTP packet type');\n        }\n        await this._handleOutgoingBtpPacket(from, {\n            type: BtpPacket.TYPE_RESPONSE,\n            requestId,\n            data: { protocolData: result || [] }\n        });\n    }\n    async _handleData(from, btpPacket) {\n        const { data } = btpPacket;\n        const { ilp } = protocol_data_converter_1.protocolDataToIlpAndCustom(data);\n        if (!this._dataHandler) {\n            throw new Error('no request handler registered');\n        }\n        const response = await this._dataHandler(ilp);\n        return protocol_data_converter_1.ilpAndCustomToProtocolData({ ilp: response });\n    }\n    async _handleMoney(from, btpPacket) {\n        throw new Error('No sendMoney functionality is included in this module');\n    }\n    async _handleOutgoingBtpPacket(to, btpPacket) {\n        const ws = this._ws || this._incomingWs;\n        const { type, requestId, data } = btpPacket;\n        const typeString = BtpPacket.typeToString(type);\n        this._log.trace(`sending btp packet. type=${typeString} requestId=${requestId} info=${generatePacketDataTracer(data)}`);\n        try {\n            await new Promise((resolve) => ws.send(BtpPacket.serialize(btpPacket), resolve));\n        }\n        catch (e) {\n            this._log.error('unable to send btp message to client: ' + e.message, 'btp packet:', JSON.stringify(btpPacket));\n        }\n    }\n    _emitDisconnect() {\n        if (this._readyState !== ReadyState.DISCONNECTED) {\n            this._readyState = ReadyState.DISCONNECTED;\n            this.emit('disconnect');\n        }\n    }\n    _emitConnect() {\n        if (this._readyState === ReadyState.CONNECTING) {\n            this.emit('_first_time_connect');\n        }\n        else if (this._readyState === ReadyState.READY_TO_EMIT || this._readyState === ReadyState.DISCONNECTED) {\n            this._readyState = ReadyState.CONNECTED;\n            this.emit('connect');\n        }\n    }\n    _validateAuthPacket(authPacket) {\n        assert.strictEqual(authPacket.type, BtpPacket.TYPE_MESSAGE, 'First message sent over BTP connection must be auth packet');\n        assert(authPacket.data.protocolData.length >= 2, 'Auth packet must have auth and auth_token subprotocols');\n        assert.strictEqual(authPacket.data.protocolData[0].protocolName, 'auth', 'First subprotocol must be auth');\n        const tokenProto = authPacket.data.protocolData.find((subProtocol) => subProtocol.protocolName === 'auth_token');\n        assert(tokenProto, 'auth_token subprotocol is required');\n        const wantToken = this._listenerSecret;\n        const gotToken = tokenProto.data;\n        if (gotToken.length !== wantToken.length\n            || !crypto.timingSafeEqual(gotToken, wantToken)) {\n            this._log.debug('received token \"%s\", but expected \"%s\"', gotToken.toString(), this._listener.secret.toString());\n            throw new Error('invalid auth_token');\n        }\n    }\n}\nAbstractBtpPlugin.version = 2;\nexports.default = AbstractBtpPlugin;\nfunction _requestId() {\n    return new Promise((resolve, reject) => {\n        crypto.randomBytes(4, (err, buf) => {\n            if (err)\n                return reject(err);\n            resolve(buf.readUInt32BE(0));\n        });\n    });\n}\n//# sourceMappingURL=index.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"../../node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/build/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-plugin-btp/build/protocol-data-converter.js':
        /*!**********************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/build/protocol-data-converter.js ***!
  \**********************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Btp = __webpack_require__(/*! btp-packet */ \"../../node_modules/btp-packet/dist/index.js\");\nfunction protocolDataToIlpAndCustom(data) {\n    const protocolMap = {};\n    const { protocolData } = data;\n    for (const protocol of protocolData) {\n        const name = protocol.protocolName;\n        if (protocol.contentType === Btp.MIME_TEXT_PLAIN_UTF8) {\n            protocolMap[name] = protocol.data.toString('utf8');\n        }\n        else if (protocol.contentType === Btp.MIME_APPLICATION_JSON) {\n            protocolMap[name] = JSON.parse(protocol.data.toString('utf8'));\n        }\n        else {\n            protocolMap[name] = protocol.data;\n        }\n    }\n    return {\n        protocolMap,\n        ilp: protocolMap['ilp'],\n        custom: protocolMap['custom']\n    };\n}\nexports.protocolDataToIlpAndCustom = protocolDataToIlpAndCustom;\nfunction ilpAndCustomToProtocolData(data) {\n    const protocolData = [];\n    const { ilp, custom, protocolMap } = data;\n    if (ilp) {\n        protocolData.push({\n            protocolName: 'ilp',\n            contentType: Btp.MIME_APPLICATION_OCTET_STREAM,\n            data: ilp\n        });\n    }\n    if (protocolMap) {\n        const sideProtocols = Object.keys(protocolMap);\n        for (const protocol of sideProtocols) {\n            if (Buffer.isBuffer(protocolMap[protocol])) {\n                protocolData.push({\n                    protocolName: protocol,\n                    contentType: Btp.MIME_APPLICATION_OCTET_STREAM,\n                    data: protocolMap[protocol]\n                });\n            }\n            else if (typeof protocolMap[protocol] === 'string') {\n                protocolData.push({\n                    protocolName: protocol,\n                    contentType: Btp.MIME_TEXT_PLAIN_UTF8,\n                    data: Buffer.from(protocolMap[protocol])\n                });\n            }\n            else {\n                protocolData.push({\n                    protocolName: protocol,\n                    contentType: Btp.MIME_APPLICATION_JSON,\n                    data: Buffer.from(JSON.stringify(protocolMap[protocol]))\n                });\n            }\n        }\n    }\n    if (custom) {\n        protocolData.push({\n            protocolName: 'custom',\n            contentType: Btp.MIME_APPLICATION_JSON,\n            data: Buffer.from(JSON.stringify(custom))\n        });\n    }\n    return protocolData;\n}\nexports.ilpAndCustomToProtocolData = ilpAndCustomToProtocolData;\n//# sourceMappingURL=protocol-data-converter.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"../../node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/build/protocol-data-converter.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-plugin-btp/build/ws-reconnect.js':
        /*!***********************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/build/ws-reconnect.js ***!
  \***********************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst createLogger = __webpack_require__(/*! ilp-logger */ \"../../node_modules/ilp-logger/build/index.js\");\nconst eventemitter2_1 = __webpack_require__(/*! eventemitter2 */ \"../../node_modules/eventemitter2/lib/eventemitter2.js\");\nconst debug = createLogger('ilp-ws-reconnect');\nconst HEARTBEAT_INTERVAL = 20000;\nconst DEFAULT_TRY_CLEAR_TIMEOUT = 10000;\nconst DEFAULT_RECONNECT_INTERVALS = [\n    0,\n    100,\n    500,\n    1000,\n    2000,\n    5000\n];\nclass WebSocketReconnector extends eventemitter2_1.EventEmitter2 {\n    constructor(options) {\n        super();\n        this.WebSocket = options.WebSocket;\n        this._clearTryTimeout = options.clearTryTimeout ||\n            DEFAULT_TRY_CLEAR_TIMEOUT;\n        this._tries = 0;\n        this._intervals = options.intervals ||\n            (options.interval && [options.interval]) ||\n            DEFAULT_RECONNECT_INTERVALS;\n    }\n    open(url) {\n        this._url = url;\n        this._open();\n        return new Promise((resolve) => void this.once('open', resolve));\n    }\n    send(data, cb) {\n        return this._instance.send(data, cb);\n    }\n    close() {\n        if (this._heartbeatTimer) {\n            clearTimeout(this._heartbeatTimer);\n        }\n        this._instance.removeAllListeners();\n        this.emit('close');\n        this._instance.close();\n        if (this._openTimer)\n            clearTimeout(this._openTimer);\n        if (this._clearTryTimer)\n            clearTimeout(this._clearTryTimer);\n    }\n    _open() {\n        this._instance = new (this.WebSocket)(this._url);\n        this._instance.on('open', () => {\n            this.emit('open');\n            this.heartbeat();\n        });\n        this._instance.on('close', (code, reason) => this._reconnect(code));\n        this._instance.on('error', (err) => this._reconnect(err));\n        this._instance.on('message', (data) => void this.emit('message', data));\n    }\n    heartbeat() {\n        if (this._heartbeatTimer) {\n            clearTimeout(this._heartbeatTimer);\n        }\n        if (this._instance && this._instance.readyState === this._instance.OPEN) {\n            this._instance.ping();\n            this._heartbeatTimer = setTimeout(() => this.heartbeat(), HEARTBEAT_INTERVAL);\n        }\n    }\n    _reconnect(codeOrError) {\n        debug.debug(`websocket disconnected with ${codeOrError}; reconnect in ${this._intervals[this._tries]}`);\n        this._connected = false;\n        this._instance.removeAllListeners();\n        this._openTimer = setTimeout(() => {\n            this._open();\n        }, this._intervals[this._tries]);\n        this._tries = Math.min(this._tries + 1, this._intervals.length - 1);\n        if (this._clearTryTimer) {\n            clearTimeout(this._clearTryTimer);\n        }\n        this._clearTryTimer = setTimeout(() => {\n            delete this._clearTryTimer;\n            this._tries = 0;\n        }, this._clearTryTimeout);\n        if (typeof this._clearTryTimer.unref === 'function') {\n            this._clearTryTimer.unref();\n        }\n        this.emit('close');\n    }\n}\nexports.WebSocketReconnector = WebSocketReconnector;\n//# sourceMappingURL=ws-reconnect.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/build/ws-reconnect.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-plugin-btp/index.js':
        /*!**********************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/index.js ***!
  \**********************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nmodule.exports = __webpack_require__(/*! ./build */ "../../node_modules/ilp-plugin-btp/build/index.js").default\nmodule.exports.default = module.exports\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/index.js?'
          )

          /***/
        },

      /***/ '../../node_modules/ilp-plugin-btp/node_modules/debug/src/browser.js':
        /*!***********************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/node_modules/debug/src/browser.js ***!
  \***********************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(console, process) {\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  var _console;\n\n  // This hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {} // Swallow\n  // XXX (@Qix-) should we be logging these?\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"../../node_modules/ilp-plugin-btp/node_modules/debug/src/common.js\")(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../console-browserify/index.js */ \"../../node_modules/console-browserify/index.js\"), __webpack_require__(/*! ./../../../../process/browser.js */ \"../../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/node_modules/debug/src/browser.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-plugin-btp/node_modules/debug/src/common.js':
        /*!**********************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/node_modules/debug/src/common.js ***!
  \**********************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug.default = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = __webpack_require__(/*! ms */ \"../../node_modules/ms/index.js\");\n  Object.keys(env).forEach(function (key) {\n    createDebug[key] = env[key];\n  });\n  /**\n  * Active `debug` instances.\n  */\n\n  createDebug.instances = [];\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    var hash = 0;\n\n    for (var i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var self = debug; // Set `diff` timestamp\n\n      var curr = Number(new Date());\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return match;\n        }\n\n        index++;\n        var formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          var val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      var logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = createDebug.enabled(namespace);\n    debug.useColors = createDebug.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy;\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\n    // debug.rawLog = rawLog;\n    // env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    createDebug.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = createDebug.instances.indexOf(this);\n\n    if (index !== -1) {\n      createDebug.instances.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  function extend(namespace, delimiter) {\n    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.names = [];\n    createDebug.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < createDebug.instances.length; i++) {\n      var instance = createDebug.instances[i];\n      instance.enabled = createDebug.enabled(instance.namespace);\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @api public\n  */\n\n\n  function disable() {\n    createDebug.enable('');\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i;\n    var len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;\n\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-plugin-btp/node_modules/debug/src/common.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-ildcp/dist/src/index.js':
        /*!***********************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-ildcp/dist/src/index.js ***!
  \***********************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst IlpPacket = __webpack_require__(/*! ilp-packet */ \"../../node_modules/ilp-packet/dist/index.js\");\nconst oer_utils_1 = __webpack_require__(/*! oer-utils */ \"../../node_modules/oer-utils/dist/src/index.js\");\nconst debug = __webpack_require__(/*! debug */ \"../../node_modules/ilp-protocol-ildcp/node_modules/debug/src/browser.js\")('ilp-protocol-ildcp');\nconst ILDCP_DESTINATION = 'peer.config';\nconst PEER_PROTOCOL_FULFILLMENT = Buffer.alloc(32);\nconst PEER_PROTOCOL_CONDITION = Buffer.from('Zmh6rfhivXdsj8GLjp+OIAiXFIVu4jOzkCpZHQ1fKSU=', 'base64');\nconst PEER_PROTOCOL_EXPIRY_DURATION = 60000;\nconst deserializeIldcpRequest = (request) => {\n    const ilp = IlpPacket.deserializeIlpPrepare(request);\n    if (ilp.destination !== ILDCP_DESTINATION) {\n        throw new TypeError('packet is not an IL-DCP request.');\n    }\n    if (!PEER_PROTOCOL_CONDITION.equals(ilp.executionCondition)) {\n        throw new Error('packet does not contain correct condition for a peer protocol request.');\n    }\n    if (Date.now() > Number(ilp.expiresAt)) {\n        throw new Error('IL-DCP request packet is expired.');\n    }\n    return {};\n};\nexports.deserializeIldcpRequest = deserializeIldcpRequest;\nconst serializeIldcpRequest = (request) => {\n    return IlpPacket.serializeIlpPrepare({\n        amount: '0',\n        destination: ILDCP_DESTINATION,\n        executionCondition: PEER_PROTOCOL_CONDITION,\n        expiresAt: new Date(Date.now() + PEER_PROTOCOL_EXPIRY_DURATION),\n        data: Buffer.alloc(0)\n    });\n};\nexports.serializeIldcpRequest = serializeIldcpRequest;\nconst deserializeIldcpResponse = (response) => {\n    const { fulfillment, data } = IlpPacket.deserializeIlpFulfill(response);\n    if (!PEER_PROTOCOL_FULFILLMENT.equals(fulfillment)) {\n        throw new Error('IL-DCP response does not contain the expected fulfillment.');\n    }\n    const reader = oer_utils_1.Reader.from(data);\n    const clientAddress = reader.readVarOctetString().toString('ascii');\n    const assetScale = reader.readUInt8Number();\n    const assetCode = reader.readVarOctetString().toString('utf8');\n    return { clientAddress, assetScale, assetCode };\n};\nexports.deserializeIldcpResponse = deserializeIldcpResponse;\nconst writeIldcpResponse = (writer, clientAddress, assetScale, assetCode) => {\n    writer.writeVarOctetString(clientAddress);\n    writer.writeUInt8(assetScale);\n    writer.writeVarOctetString(assetCode);\n};\nconst serializeIldcpResponse = (response) => {\n    const clientAddress = Buffer.from(response.clientAddress, 'ascii');\n    const assetCode = Buffer.from(response.assetCode, 'utf8');\n    const predictor = new oer_utils_1.Predictor();\n    writeIldcpResponse(predictor, clientAddress, response.assetScale, assetCode);\n    const writer = new oer_utils_1.Writer(predictor.length);\n    writeIldcpResponse(writer, clientAddress, response.assetScale, assetCode);\n    return IlpPacket.serializeIlpFulfill({\n        fulfillment: PEER_PROTOCOL_FULFILLMENT,\n        data: writer.getBuffer()\n    });\n};\nexports.serializeIldcpResponse = serializeIldcpResponse;\nconst fetch = (sendData) => __awaiter(this, void 0, void 0, function* () {\n    const data = yield sendData(IlpPacket.serializeIlpPrepare({\n        amount: '0',\n        executionCondition: PEER_PROTOCOL_CONDITION,\n        expiresAt: new Date(Date.now() + PEER_PROTOCOL_EXPIRY_DURATION),\n        destination: 'peer.config',\n        data: Buffer.alloc(0)\n    }));\n    if (data[0] === IlpPacket.Type.TYPE_ILP_REJECT) {\n        const { triggeredBy, message } = IlpPacket.deserializeIlpReject(data);\n        debug('IL-DCP request rejected. triggeredBy=%s errorMessage=%s', triggeredBy, message);\n        throw new Error('IL-DCP failed: ' + message);\n    }\n    else if (data[0] !== IlpPacket.Type.TYPE_ILP_FULFILL) {\n        debug('invalid response type. type=%s', data[0]);\n        throw new Error('IL-DCP error, unable to retrieve client configuration.');\n    }\n    const { clientAddress, assetScale, assetCode } = deserializeIldcpResponse(data);\n    debug('received client info. clientAddress=%s assetScale=%s assetCode=%s', clientAddress, assetScale, assetCode);\n    return { clientAddress, assetScale, assetCode };\n});\nexports.fetch = fetch;\nconst serve = ({ requestPacket, handler, serverAddress }) => __awaiter(this, void 0, void 0, function* () {\n    try {\n        deserializeIldcpRequest(requestPacket);\n        const info = yield handler({});\n        return serializeIldcpResponse(info);\n    }\n    catch (err) {\n        const errInfo = (err && typeof err === 'object' && err.stack) ? err.stack : err;\n        debug('error while handling ildcp request. error=%s', errInfo);\n        return IlpPacket.serializeIlpReject({\n            code: 'F00',\n            message: (err && typeof err === 'object' && err.message) ? err.message : 'unexpected error.',\n            triggeredBy: serverAddress,\n            data: Buffer.alloc(0)\n        });\n    }\n});\nexports.serve = serve;\n//# sourceMappingURL=index.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ \"../../node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-ildcp/dist/src/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-ildcp/node_modules/debug/src/browser.js':
        /*!***************************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-ildcp/node_modules/debug/src/browser.js ***!
  \***************************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(console, process) {\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  var _console;\n\n  // This hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {} // Swallow\n  // XXX (@Qix-) should we be logging these?\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"../../node_modules/ilp-protocol-ildcp/node_modules/debug/src/common.js\")(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../console-browserify/index.js */ \"../../node_modules/console-browserify/index.js\"), __webpack_require__(/*! ./../../../../process/browser.js */ \"../../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-ildcp/node_modules/debug/src/browser.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-ildcp/node_modules/debug/src/common.js':
        /*!**************************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-ildcp/node_modules/debug/src/common.js ***!
  \**************************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug.default = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = __webpack_require__(/*! ms */ \"../../node_modules/ms/index.js\");\n  Object.keys(env).forEach(function (key) {\n    createDebug[key] = env[key];\n  });\n  /**\n  * Active `debug` instances.\n  */\n\n  createDebug.instances = [];\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    var hash = 0;\n\n    for (var i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var self = debug; // Set `diff` timestamp\n\n      var curr = Number(new Date());\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return match;\n        }\n\n        index++;\n        var formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          var val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      var logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = createDebug.enabled(namespace);\n    debug.useColors = createDebug.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy;\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\n    // debug.rawLog = rawLog;\n    // env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    createDebug.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = createDebug.instances.indexOf(this);\n\n    if (index !== -1) {\n      createDebug.instances.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  function extend(namespace, delimiter) {\n    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.names = [];\n    createDebug.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < createDebug.instances.length; i++) {\n      var instance = createDebug.instances[i];\n      instance.enabled = createDebug.enabled(instance.namespace);\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @api public\n  */\n\n\n  function disable() {\n    createDebug.enable('');\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i;\n    var len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;\n\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-ildcp/node_modules/debug/src/common.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-stream/dist/src/connection.js':
        /*!*****************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/connection.js ***!
  \*****************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(setImmediate, process) {\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = __webpack_require__(/*! events */ \"../../node_modules/events/events.js\");\nconst ilp_logger_1 = __webpack_require__(/*! ilp-logger */ \"../../node_modules/ilp-logger/build/index.js\");\nconst stream_1 = __webpack_require__(/*! ./stream */ \"../../node_modules/ilp-protocol-stream/dist/src/stream.js\");\nconst IlpPacket = __webpack_require__(/*! ilp-packet */ \"../../node_modules/ilp-packet/dist/index.js\");\nconst cryptoHelper = __webpack_require__(/*! ./crypto */ \"../../node_modules/ilp-protocol-stream/dist/src/crypto.js\");\nconst packet_1 = __webpack_require__(/*! ./packet */ \"../../node_modules/ilp-protocol-stream/dist/src/packet.js\");\nconst oer_utils_1 = __webpack_require__(/*! oer-utils */ \"../../node_modules/oer-utils/dist/src/index.js\");\nconst congestion_1 = __webpack_require__(/*! ./util/congestion */ \"../../node_modules/ilp-protocol-stream/dist/src/util/congestion.js\");\nconst long_1 = __webpack_require__(/*! ./util/long */ \"../../node_modules/ilp-protocol-stream/dist/src/util/long.js\");\nconst Long = __webpack_require__(/*! long */ \"../../node_modules/long/src/long.js\");\nconst rational_1 = __webpack_require__(/*! ./util/rational */ \"../../node_modules/ilp-protocol-stream/dist/src/util/rational.js\");\nconst RETRY_DELAY_START = 100;\nconst RETRY_DELAY_MAX = 43200000;\nconst RETRY_DELAY_INCREASE_FACTOR = 1.5;\nconst DEFAULT_PACKET_TIMEOUT = 30000;\nconst DEFAULT_IDLE_TIMEOUT = 60000;\nconst MAX_DATA_SIZE = 32767;\nconst DEFAULT_MAX_REMOTE_STREAMS = 10;\nconst DEFAULT_MINIMUM_EXCHANGE_RATE_PRECISION = 3;\nconst TEST_PACKET_MAX_ATTEMPTS = 20;\nclass ConnectionError extends Error {\n    constructor(message, streamErrorCode) {\n        super(message);\n        this.streamErrorCode = streamErrorCode || packet_1.ErrorCode.InternalError;\n    }\n}\nexports.ConnectionError = ConnectionError;\nvar RemoteState;\n(function (RemoteState) {\n    RemoteState[RemoteState[\"Init\"] = 0] = \"Init\";\n    RemoteState[RemoteState[\"Connected\"] = 1] = \"Connected\";\n    RemoteState[RemoteState[\"Closed\"] = 2] = \"Closed\";\n})(RemoteState || (RemoteState = {}));\nclass Connection extends events_1.EventEmitter {\n    constructor(opts) {\n        super();\n        this.remoteState = RemoteState.Init;\n        this.plugin = opts.plugin;\n        this._sourceAccount = opts.sourceAccount;\n        this._sourceAssetCode = opts.assetCode;\n        this._sourceAssetScale = opts.assetScale;\n        this._destinationAccount = opts.destinationAccount;\n        this.sharedSecret = opts.sharedSecret;\n        this.isServer = opts.isServer;\n        this._pskKey = opts.pskKey;\n        this._fulfillmentKey = opts.fulfillmentKey;\n        this.slippage = rational_1.default.fromNumber(opts.slippage === undefined ? 0.01 : opts.slippage, true);\n        if (this.slippage.greaterThanOne()) {\n            throw new Error('slippage must be less than one');\n        }\n        this.allowableReceiveExtra = rational_1.default.fromNumber(1.01, true);\n        this.enablePadding = !!opts.enablePadding;\n        this.connectionTag = opts.connectionTag;\n        this.maxStreamId = 2 * (opts.maxRemoteStreams || DEFAULT_MAX_REMOTE_STREAMS);\n        this.maxBufferedData = opts.connectionBufferSize || MAX_DATA_SIZE * 2;\n        this.minExchangeRatePrecision = opts.minExchangeRatePrecision || DEFAULT_MINIMUM_EXCHANGE_RATE_PRECISION;\n        this.exchangeRate = opts.exchangeRate === undefined\n            ? undefined\n            : rational_1.default.fromNumber(opts.exchangeRate, true);\n        this.idleTimeout = opts.idleTimeout || DEFAULT_IDLE_TIMEOUT;\n        this.lastActive = new Date();\n        this.nextPacketSequence = 1;\n        this.streams = new Map();\n        this.closedStreams = new Set();\n        this.nextStreamId = (this.isServer ? 2 : 1);\n        this.log = ilp_logger_1.default(`ilp-protocol-stream:${this.isServer ? 'Server' : 'Client'}:Connection`);\n        this.sending = false;\n        this.connected = false;\n        this.closed = true;\n        this.queuedFrames = [];\n        this.congestion = new congestion_1.CongestionController({\n            maximumPacketAmount: opts.maximumPacketAmount === undefined\n                ? undefined\n                : Long.fromString(opts.maximumPacketAmount, true)\n        });\n        this.retryDelay = RETRY_DELAY_START;\n        this.remoteKnowsOurAccount = this.isServer;\n        this.remoteMaxStreamId = DEFAULT_MAX_REMOTE_STREAMS * 2;\n        this.remoteMaxOffset = this.maxBufferedData;\n        this._totalReceived = Long.UZERO;\n        this._totalSent = Long.UZERO;\n        this._totalDelivered = Long.UZERO;\n        this._lastPacketExchangeRate = rational_1.default.UZERO;\n    }\n    static build(opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pskKey = yield cryptoHelper.generatePskEncryptionKey(opts.sharedSecret);\n            const fulfillmentKey = yield cryptoHelper.generateFulfillmentKey(opts.sharedSecret);\n            return new Connection(Object.assign({ pskKey, fulfillmentKey }, opts));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.closed) {\n                return Promise.resolve();\n            }\n            this.startSendLoop();\n            yield new Promise((resolve, reject) => {\n                const connectHandler = () => {\n                    cleanup();\n                    resolve();\n                };\n                const closeHandler = () => {\n                    cleanup();\n                    reject(new Error('Connection was closed before it was connected'));\n                };\n                const errorHandler = (error) => {\n                    cleanup();\n                    reject(new Error(`Error connecting${error ? ': ' + error.message : ''}`));\n                };\n                this.once('connect', connectHandler);\n                this.once('error', errorHandler);\n                this.once('close', closeHandler);\n                this.once('end', closeHandler);\n                const self = this;\n                function cleanup() {\n                    clearTimeout(self.idleTimer);\n                    self.removeListener('connect', connectHandler);\n                    self.removeListener('error', errorHandler);\n                    self.removeListener('close', closeHandler);\n                    self.removeListener('end', closeHandler);\n                }\n            });\n            this.closed = false;\n            this.startIdleTimer();\n        });\n    }\n    end() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.log.info('closing connection');\n            let streamEndPromises = [];\n            for (let [_, stream] of this.streams) {\n                if (stream.isOpen()) {\n                    streamEndPromises.push(new Promise((resolve, reject) => {\n                        stream.on('end', resolve);\n                    }));\n                    stream.end();\n                }\n            }\n            yield new Promise((resolve, reject) => {\n                this.once('_send_loop_finished', resolve);\n                this.once('error', reject);\n                this.startSendLoop();\n            });\n            yield Promise.all(streamEndPromises);\n            this.closed = true;\n            yield this.sendConnectionClose();\n            this.safeEmit('end');\n            this.safeEmit('close');\n            clearTimeout(this.idleTimer);\n        });\n    }\n    destroy(err) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.log.error('destroying connection with error:', err);\n            if (err) {\n                this.safeEmit('error', err);\n            }\n            let streamClosePromises = [];\n            for (let [_, stream] of this.streams) {\n                streamClosePromises.push(new Promise((resolve, reject) => {\n                    stream.on('close', resolve);\n                }));\n                stream.destroy();\n            }\n            yield this.sendConnectionClose(err || new ConnectionError('Connection destroyed', packet_1.ErrorCode.ApplicationError));\n            yield Promise.all(streamClosePromises);\n            this.safeEmit('close');\n            clearTimeout(this.idleTimer);\n        });\n    }\n    createStream() {\n        if (this.remoteMaxStreamId < this.nextStreamId) {\n            this.log.debug('cannot create another stream. nextStreamId: %d, remote maxStreamId: %d', this.nextStreamId, this.remoteMaxStreamId);\n            this.queuedFrames.push(new packet_1.ConnectionStreamIdBlockedFrame(this.nextStreamId));\n            throw new Error(`Creating another stream would exceed the remote connection's maximum number of open streams`);\n        }\n        const stream = new stream_1.DataAndMoneyStream({\n            id: this.nextStreamId,\n            isServer: this.isServer\n        });\n        this.streams.set(this.nextStreamId, stream);\n        this.log.debug('created stream: %d', this.nextStreamId);\n        this.nextStreamId += 2;\n        stream.on('_maybe_start_send_loop', this.startSendLoop.bind(this));\n        stream.once('close', () => this.removeStreamRecord(stream));\n        return stream;\n    }\n    get destinationAccount() {\n        return this._destinationAccount;\n    }\n    get destinationAssetScale() {\n        return this._destinationAssetScale;\n    }\n    get destinationAssetCode() {\n        return this._destinationAssetCode;\n    }\n    get sourceAccount() {\n        return this._sourceAccount;\n    }\n    get sourceAssetScale() {\n        return this._sourceAssetScale;\n    }\n    get sourceAssetCode() {\n        return this._sourceAssetCode;\n    }\n    get minimumAcceptableExchangeRate() {\n        if (this.exchangeRate) {\n            const minimumExchangeWithSlippage = this.exchangeRate\n                .multiplyByRational(this.slippage.complement());\n            return minimumExchangeWithSlippage.toString();\n        }\n        return '0';\n    }\n    get lastPacketExchangeRate() {\n        return this._lastPacketExchangeRate.toString();\n    }\n    get totalDelivered() {\n        return this._totalDelivered.toString();\n    }\n    get totalSent() {\n        return this._totalSent.toString();\n    }\n    get totalReceived() {\n        return this._totalReceived.toString();\n    }\n    handlePrepare(prepare) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let requestPacket;\n            try {\n                requestPacket = yield packet_1.Packet.decryptAndDeserialize(this._pskKey, prepare.data);\n            }\n            catch (err) {\n                this.log.error('error parsing frames:', err);\n                throw new IlpPacket.Errors.UnexpectedPaymentError('');\n            }\n            this.log.trace('handling packet:', JSON.stringify(requestPacket));\n            if (requestPacket.ilpPacketType.valueOf() !== IlpPacket.Type.TYPE_ILP_PREPARE) {\n                this.log.error('prepare packet contains a frame that says it should be something other than a prepare: %d', requestPacket.ilpPacketType);\n                throw new IlpPacket.Errors.UnexpectedPaymentError('');\n            }\n            this.bumpIdle();\n            let responseFrames = [];\n            responseFrames.push(new packet_1.ConnectionMaxDataFrame(this.getIncomingOffsets().maxAcceptable));\n            const throwFinalApplicationError = () => __awaiter(this, void 0, void 0, function* () {\n                responseFrames = responseFrames.concat(this.queuedFrames);\n                this.queuedFrames = [];\n                const responsePacket = new packet_1.Packet(requestPacket.sequence, packet_1.IlpPacketType.Reject, prepare.amount, responseFrames);\n                this.log.trace('rejecting packet %s: %j', requestPacket.sequence, responsePacket);\n                throw new IlpPacket.Errors.FinalApplicationError('', yield responsePacket.serializeAndEncrypt(this._pskKey, (this.enablePadding ? MAX_DATA_SIZE : undefined)));\n            });\n            for (let frame of requestPacket.frames) {\n                if (frame.type === packet_1.FrameType.StreamMoney\n                    || frame.type === packet_1.FrameType.StreamData\n                    || frame.type === packet_1.FrameType.StreamMaxMoney\n                    || frame.type === packet_1.FrameType.StreamMaxData) {\n                    const streamId = frame.streamId.toNumber();\n                    if (this.closedStreams.has(streamId)) {\n                        this.log.trace('got packet with frame for stream %d, which was already closed', streamId);\n                        if (frame.type !== packet_1.FrameType.StreamMoney && frame.type !== packet_1.FrameType.StreamData) {\n                            continue;\n                        }\n                        const testStreamClose = (frame) => {\n                            return frame.type === packet_1.FrameType.StreamClose\n                                && frame.streamId.equals(streamId);\n                        };\n                        const includesStreamClose = responseFrames.find(testStreamClose)\n                            || this.queuedFrames.find(testStreamClose);\n                        if (!includesStreamClose) {\n                            responseFrames.push(new packet_1.StreamCloseFrame(streamId, packet_1.ErrorCode.StreamStateError, 'Stream is already closed'));\n                        }\n                        yield throwFinalApplicationError();\n                    }\n                    try {\n                        this.handleNewStream(frame.streamId.toNumber());\n                    }\n                    catch (err) {\n                        this.log.debug('error handling new stream %s: %s', frame.streamId, err && err.message);\n                        yield throwFinalApplicationError();\n                    }\n                }\n            }\n            try {\n                this.handleControlFrames(requestPacket.frames);\n            }\n            catch (err) {\n                this.log.debug('error handling frames:', err && err.message);\n                yield throwFinalApplicationError();\n            }\n            const incomingOffsets = this.getIncomingOffsets();\n            if (incomingOffsets.max > incomingOffsets.maxAcceptable) {\n                this.destroy(new ConnectionError(`Exceeded flow control limits. Max connection byte offset: ${incomingOffsets.maxAcceptable}, received: ${incomingOffsets.max}`, packet_1.ErrorCode.FlowControlError));\n                yield throwFinalApplicationError();\n            }\n            const incomingAmount = Long.fromString(prepare.amount, true);\n            if (requestPacket.prepareAmount.greaterThan(incomingAmount)) {\n                this.log.debug('received less than minimum destination amount. actual: %s, expected: %s', prepare.amount, requestPacket.prepareAmount);\n                yield throwFinalApplicationError();\n            }\n            const fulfillment = yield cryptoHelper.generateFulfillment(this._fulfillmentKey, prepare.data);\n            const generatedCondition = yield cryptoHelper.hash(fulfillment);\n            if (!generatedCondition.equals(prepare.executionCondition)) {\n                this.log.debug('got unfulfillable prepare for amount: %s. generated condition: %h, prepare condition: %h', prepare.amount, generatedCondition, prepare.executionCondition);\n                yield throwFinalApplicationError();\n            }\n            const amountsToReceive = [];\n            const totalMoneyShares = requestPacket.frames.reduce((sum, frame) => {\n                if (frame instanceof packet_1.StreamMoneyFrame) {\n                    const result = long_1.checkedAdd(sum, frame.shares);\n                    if (result.overflow)\n                        throw new Error('Total shares exceeded MaxUint64');\n                    return result.sum;\n                }\n                return sum;\n            }, Long.UZERO);\n            for (let frame of requestPacket.frames) {\n                if (!(frame instanceof packet_1.StreamMoneyFrame)) {\n                    continue;\n                }\n                const streamId = frame.streamId.toNumber();\n                const streamAmount = long_1.multiplyDivideFloor(incomingAmount, frame.shares, totalMoneyShares);\n                const stream = this.streams.get(streamId);\n                amountsToReceive.push({\n                    stream,\n                    amount: streamAmount\n                });\n                const maxStreamCanReceive = this.allowableReceiveExtra\n                    .multiplyByLongCeil(stream._getAmountStreamCanReceive());\n                if (maxStreamCanReceive.lessThan(streamAmount)) {\n                    this.log.debug('peer sent too much for stream: %d. got: %s, max receivable: %s', streamId, streamAmount, maxStreamCanReceive);\n                    responseFrames.push(new packet_1.StreamMaxMoneyFrame(streamId, stream.receiveMax, stream.totalReceived));\n                    yield throwFinalApplicationError();\n                }\n                if (!stream.isOpen()) {\n                    this.log.debug('peer sent money for stream that was already closed: %d', streamId);\n                    responseFrames.push(new packet_1.StreamCloseFrame(streamId, packet_1.ErrorCode.StreamStateError, 'Stream is already closed'));\n                    yield throwFinalApplicationError();\n                }\n            }\n            for (let { stream, amount } of amountsToReceive) {\n                stream._addToIncoming(amount);\n            }\n            if (!this.closed && this.remoteState !== RemoteState.Closed) {\n                for (let [_, stream] of this.streams) {\n                    if (!stream.isOpen() && !stream._remoteClosed) {\n                        this.log.trace('telling other side that stream %d is closed', stream.id);\n                        if (stream._errorMessage) {\n                            responseFrames.push(new packet_1.StreamCloseFrame(stream.id, packet_1.ErrorCode.ApplicationError, stream._errorMessage));\n                        }\n                        else {\n                            responseFrames.push(new packet_1.StreamCloseFrame(stream.id, packet_1.ErrorCode.NoError, ''));\n                        }\n                        stream._remoteClosed = true;\n                    }\n                    else {\n                        this.log.trace('telling other side that stream %d can receive %s', stream.id, stream.receiveMax);\n                        responseFrames.push(new packet_1.StreamMaxMoneyFrame(stream.id, stream.receiveMax, stream.totalReceived));\n                        responseFrames.push(new packet_1.StreamMaxDataFrame(stream.id, stream._getIncomingOffsets().maxAcceptable));\n                    }\n                }\n            }\n            responseFrames = responseFrames.concat(this.queuedFrames);\n            this.queuedFrames = [];\n            const responsePacket = new packet_1.Packet(requestPacket.sequence, packet_1.IlpPacketType.Fulfill, incomingAmount, responseFrames);\n            this.addTotalReceived(incomingAmount);\n            this.log.trace('fulfilling prepare with fulfillment: %h and response packet: %j', fulfillment, responsePacket);\n            return {\n                fulfillment,\n                data: yield responsePacket.serializeAndEncrypt(this._pskKey, (this.enablePadding ? MAX_DATA_SIZE : undefined))\n            };\n        });\n    }\n    handleControlFrames(frames) {\n        for (let frame of frames) {\n            let stream;\n            switch (frame.type) {\n                case packet_1.FrameType.ConnectionNewAddress:\n                    this.log.trace('peer notified us of their account: %s', frame.sourceAccount);\n                    const firstConnection = this._destinationAccount === undefined;\n                    this._destinationAccount = frame.sourceAccount;\n                    if (firstConnection) {\n                        this.handleConnect();\n                    }\n                    break;\n                case packet_1.FrameType.ConnectionAssetDetails:\n                    this.log.trace('peer notified us of their asset details: code=%s, scale=%d', frame.sourceAssetCode, frame.sourceAssetScale);\n                    this._destinationAssetCode = frame.sourceAssetCode;\n                    this._destinationAssetScale = frame.sourceAssetScale;\n                    break;\n                case packet_1.FrameType.ConnectionClose:\n                    this.sending = false;\n                    this.closed = true;\n                    this.remoteState = RemoteState.Closed;\n                    if (frame.errorCode === packet_1.ErrorCode.NoError) {\n                        this.log.info('remote closed connection');\n                        this.end();\n                    }\n                    else {\n                        this.log.error('remote connection error. code: %s, message: %s', packet_1.ErrorCode[frame.errorCode], frame.errorMessage);\n                        this.destroy(new Error(`Remote connection error. Code: ${packet_1.ErrorCode[frame.errorCode]}, message: ${frame.errorMessage}`));\n                    }\n                    break;\n                case packet_1.FrameType.ConnectionMaxData:\n                    const outgoingOffsets = this.getOutgoingOffsets();\n                    this.log.trace('remote connection max byte offset is: %s, we\\'ve sent: %d, we want to send up to: %d', frame.maxOffset, outgoingOffsets.currentOffset, outgoingOffsets.maxOffset);\n                    if (frame.maxOffset.notEquals(this.maxBufferedData)) {\n                        this.remoteMaxOffset = Math.max(frame.maxOffset.toNumber(), this.remoteMaxOffset);\n                    }\n                    else {\n                        this.remoteMaxOffset = frame.maxOffset.toNumber();\n                    }\n                    break;\n                case packet_1.FrameType.ConnectionDataBlocked:\n                    this.log.trace('remote wants to send more data but we are blocking them. current max incoming offset: %d, remote max offset: %s', this.getIncomingOffsets(), frame.maxOffset);\n                    break;\n                case packet_1.FrameType.ConnectionMaxStreamId:\n                    this.log.trace('remote set max stream id to %s', frame.maxStreamId);\n                    this.remoteMaxStreamId = frame.maxStreamId.toNumber();\n                    break;\n                case packet_1.FrameType.ConnectionStreamIdBlocked:\n                    this.log.trace('remote wants to open more streams but we are blocking them');\n                    break;\n                case packet_1.FrameType.StreamClose:\n                    this.handleStreamClose(frame);\n                    break;\n                case packet_1.FrameType.StreamMaxMoney:\n                    this.log.trace('peer told us that stream %s can receive up to: %s and has received: %s so far', frame.streamId, frame.receiveMax, frame.totalReceived);\n                    stream = this.streams.get(frame.streamId.toNumber());\n                    if (!stream) {\n                        break;\n                    }\n                    stream._remoteReceived = long_1.maxLong(stream._remoteReceived, frame.totalReceived);\n                    if (stream._remoteReceiveMax.notEquals(Long.MAX_UNSIGNED_VALUE)) {\n                        stream._remoteReceiveMax = long_1.maxLong(stream._remoteReceiveMax, frame.receiveMax);\n                    }\n                    else {\n                        stream._remoteReceiveMax = frame.receiveMax;\n                    }\n                    if (stream._remoteReceiveMax.greaterThan(stream._remoteReceived)\n                        && stream._getAmountAvailableToSend().greaterThan(0)) {\n                        this.startSendLoop();\n                    }\n                    break;\n                case packet_1.FrameType.StreamMoneyBlocked:\n                    this.log.debug('peer told us that they want to send more money on stream %s but we are blocking them. they have sent: %s so far and want to send: %s', frame.streamId, frame.totalSent, frame.sendMax);\n                    break;\n                case packet_1.FrameType.StreamData:\n                    this.log.trace('got data for stream %s', frame.streamId);\n                    stream = this.streams.get(frame.streamId.toNumber());\n                    if (!stream) {\n                        break;\n                    }\n                    stream._pushIncomingData(frame.data, frame.offset.toNumber());\n                    const incomingOffsets = stream._getIncomingOffsets();\n                    if (incomingOffsets.max > incomingOffsets.maxAcceptable) {\n                        this.destroy(new ConnectionError(`Exceeded flow control limits. Stream ${stream.id} can accept up to offset: ${incomingOffsets.maxAcceptable} but got bytes up to offset: ${incomingOffsets.max}`, packet_1.ErrorCode.FlowControlError));\n                    }\n                    break;\n                case packet_1.FrameType.StreamMaxData:\n                    stream = this.streams.get(frame.streamId.toNumber());\n                    if (!stream) {\n                        break;\n                    }\n                    const oldOffset = stream._remoteMaxOffset;\n                    const newOffset = frame.maxOffset.toNumber();\n                    if (newOffset > oldOffset) {\n                        this.log.trace('peer told us that stream %s can receive up to byte offset: %s (we\\'ve sent up to offset: %d)', frame.streamId, frame.maxOffset, stream._getOutgoingOffsets().current);\n                        stream._remoteMaxOffset = newOffset;\n                        this.startSendLoop();\n                    }\n                    else {\n                        this.log.trace('peer told us that stream %s can receive up to byte offset: %d; ignoring new offset: %d', frame.streamId, oldOffset, newOffset);\n                    }\n                    break;\n                case packet_1.FrameType.StreamDataBlocked:\n                    stream = this.streams.get(frame.streamId.toNumber());\n                    if (!stream) {\n                        break;\n                    }\n                    this.log.debug('peer told us that stream %s is blocked. they want to send up to offset: %s, but we are only allowing up to: %d', frame.streamId, frame.maxOffset, stream._getIncomingOffsets().maxAcceptable);\n                    break;\n                default:\n                    continue;\n            }\n        }\n    }\n    handleConnect() {\n        this.closed = false;\n        this.log.info('connected');\n        this.safeEmit('connect');\n        this.queuedFrames.push(new packet_1.ConnectionMaxStreamIdFrame(this.maxStreamId), new packet_1.ConnectionAssetDetailsFrame(this.sourceAssetCode, this.sourceAssetScale));\n    }\n    handleNewStream(streamId) {\n        if (this.streams.has(streamId) || this.closedStreams.has(streamId)) {\n            return;\n        }\n        if (this.isServer && streamId % 2 === 0) {\n            this.log.error('got invalid stream ID %d from peer (should be odd)', streamId);\n            this.queuedFrames.push(new packet_1.ConnectionCloseFrame(packet_1.ErrorCode.ProtocolViolation, `Invalid Stream ID: ${streamId}. Client-initiated streams must have odd-numbered IDs`));\n            const err = new Error(`Invalid Stream ID: ${streamId}. Client-initiated streams must have odd-numbered IDs`);\n            this.safeEmit('error', err);\n            throw err;\n        }\n        else if (!this.isServer && streamId % 2 === 1) {\n            this.log.error('got invalid stream ID %d from peer (should be even)', streamId);\n            this.queuedFrames.push(new packet_1.ConnectionCloseFrame(packet_1.ErrorCode.ProtocolViolation, `Invalid Stream ID: ${streamId}. Server-initiated streams must have even-numbered IDs`));\n            const err = new Error(`Invalid Stream ID: ${streamId}. Server-initiated streams must have even-numbered IDs`);\n            this.safeEmit('error', err);\n            throw err;\n        }\n        if (streamId > this.maxStreamId) {\n            this.log.debug('peer opened too many streams. got stream: %d, but max stream id is: %d. closing connection', streamId, this.maxStreamId);\n            this.queuedFrames.push(new packet_1.ConnectionCloseFrame(packet_1.ErrorCode.StreamIdError, `Maximum number of open streams exceeded. Got stream: ${streamId}, current max stream ID: ${this.maxStreamId}`));\n            const err = new Error(`Maximum number of open streams exceeded. Got stream: ${streamId}, current max stream ID: ${this.maxStreamId}`);\n            this.safeEmit('error', err);\n            throw err;\n        }\n        if (this.maxStreamId * .75 < streamId) {\n            this.log.trace('informing peer that our max stream id is: %d', this.maxStreamId);\n            this.queuedFrames.push(new packet_1.ConnectionMaxStreamIdFrame(this.maxStreamId));\n        }\n        this.log.info('got new stream: %d', streamId);\n        const stream = new stream_1.DataAndMoneyStream({\n            id: streamId,\n            isServer: this.isServer\n        });\n        this.streams.set(streamId, stream);\n        stream.on('_maybe_start_send_loop', () => this.startSendLoop());\n        stream.once('close', () => this.removeStreamRecord(stream));\n        this.safeEmit('stream', stream);\n    }\n    handleStreamClose(frame) {\n        const streamId = frame.streamId.toNumber();\n        const stream = this.streams.get(streamId);\n        if (!stream) {\n            this.log.error('remote error on stream %d, but we don\\'t have a record of that stream', streamId);\n            return;\n        }\n        if (!stream.isOpen() || stream._remoteSentEnd) {\n            return;\n        }\n        this.log.error('peer closed stream %d with error code: %s and message: %s', stream.id, packet_1.ErrorCode[frame.errorCode], frame.errorMessage);\n        stream._sentEnd = true;\n        let err;\n        if (frame.errorMessage) {\n            err = new Error(frame.errorMessage);\n            err.name = packet_1.ErrorCode[frame.errorCode];\n        }\n        stream._remoteEnded(err);\n        this.maxStreamId += 2;\n        this.log.trace('raising maxStreamId to %d', this.maxStreamId);\n        this.queuedFrames.push(new packet_1.ConnectionMaxStreamIdFrame(this.maxStreamId));\n        this.startSendLoop();\n    }\n    startSendLoop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.sending) {\n                return;\n            }\n            if (this.remoteState === RemoteState.Closed) {\n                this.log.debug('remote connection is already closed, not starting another loop');\n                this.safeEmit('_send_loop_finished');\n                return;\n            }\n            if (!this._destinationAccount) {\n                this.log.debug('not sending because we do not know the client\\'s address');\n                return;\n            }\n            this.sending = true;\n            this.log.debug('starting send loop');\n            try {\n                while (this.sending) {\n                    if (!this.connected) {\n                        yield this.setupExchangeRate();\n                        this.connected = true;\n                    }\n                    else {\n                        yield this.loadAndSendPacket();\n                    }\n                }\n            }\n            catch (err) {\n                return this.destroy(err);\n            }\n            this.log.debug('finished sending');\n            this.safeEmit('_send_loop_finished');\n            for (let [_, stream] of this.streams) {\n                stream.emit('_send_loop_finished');\n            }\n        });\n    }\n    loadAndSendPacket() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield new Promise((resolve, reject) => setImmediate(resolve));\n            this.log.trace('loadAndSendPacket');\n            let amountToSend = Long.UZERO;\n            const requestPacket = new packet_1.Packet(this.getNextPacketSequence(), packet_1.IlpPacketType.Prepare, undefined, this.queuedFrames);\n            this.queuedFrames = [];\n            this.maybePushAccountFrames(requestPacket);\n            for (let [_, stream] of this.streams) {\n                if (stream.isOpen()) {\n                    requestPacket.frames.push(new packet_1.StreamMaxMoneyFrame(stream.id, stream.receiveMax, stream.totalReceived));\n                    requestPacket.frames.push(new packet_1.StreamMaxDataFrame(stream.id, stream._getIncomingOffsets().maxAcceptable));\n                }\n            }\n            if (this.closed && this.remoteState === RemoteState.Connected) {\n                this.log.trace('sending connection close frame');\n                requestPacket.frames.push(new packet_1.ConnectionCloseFrame(packet_1.ErrorCode.NoError, ''));\n                this.remoteState = RemoteState.Closed;\n            }\n            let maxAmountFromNextStream = this.congestion.testMaximumPacketAmount;\n            if (this.exchangeRate.greaterThanOne()) {\n                maxAmountFromNextStream = long_1.minLong(maxAmountFromNextStream, this.exchangeRate.reciprocal()\n                    .multiplyByLong(Long.MAX_UNSIGNED_VALUE));\n            }\n            const streamsSentFrom = [];\n            for (let [_, stream] of this.streams) {\n                if (stream._sentEnd) {\n                    continue;\n                }\n                let amountToSendFromStream = long_1.minLong(stream._getAmountAvailableToSend(), maxAmountFromNextStream);\n                const maxDestinationAmount = long_1.checkedSubtract(stream._remoteReceiveMax, stream._remoteReceived).difference;\n                const maxSourceAmount = this.exchangeRate.reciprocal()\n                    .multiplyByLongCeil(maxDestinationAmount);\n                if (maxSourceAmount.lessThan(amountToSendFromStream)) {\n                    this.log.trace('stream %d could send %s but that would be more than the receiver says they can receive, so we\\'ll send %s instead', stream.id, amountToSendFromStream, maxSourceAmount);\n                    amountToSendFromStream = maxSourceAmount;\n                }\n                this.log.trace('amount to send from stream %d: %s, exchange rate: %s, remote total received: %s, remote receive max: %s', stream.id, amountToSendFromStream, this.exchangeRate, stream._remoteReceived, stream._remoteReceiveMax);\n                if (amountToSendFromStream.greaterThan(0)) {\n                    stream._holdOutgoing(requestPacket.sequence.toString(), amountToSendFromStream);\n                    requestPacket.frames.push(new packet_1.StreamMoneyFrame(stream.id, amountToSendFromStream));\n                    amountToSend = amountToSend.add(amountToSendFromStream);\n                    maxAmountFromNextStream = maxAmountFromNextStream.subtract(amountToSendFromStream);\n                    streamsSentFrom.push(stream);\n                }\n                const amountLeftStreamWantsToSend = Long.fromString(stream.sendMax, true)\n                    .subtract(stream.totalSent)\n                    .subtract(amountToSendFromStream);\n                if (this.exchangeRate\n                    .multiplyByLong(amountLeftStreamWantsToSend)\n                    .greaterThan(long_1.checkedSubtract(stream._remoteReceiveMax, stream._remoteReceived).difference)) {\n                    requestPacket.frames.push(new packet_1.StreamMoneyBlockedFrame(stream.id, stream.sendMax, stream.totalSent));\n                }\n                if (maxAmountFromNextStream.equals(0)) {\n                    break;\n                }\n            }\n            let bytesLeftInPacket = MAX_DATA_SIZE - requestPacket.byteLength();\n            const maxBytesRemoteConnectionCanReceive = this.remoteMaxOffset - this.getOutgoingOffsets().currentOffset;\n            if (bytesLeftInPacket > maxBytesRemoteConnectionCanReceive) {\n                const outgoingMaxOffset = this.getOutgoingOffsets().maxOffset;\n                this.log.debug('peer is blocking us from sending more data. they will only accept up to offset: %d, but we want to send up to: %d', this.remoteMaxOffset, outgoingMaxOffset);\n                requestPacket.frames.push(new packet_1.ConnectionDataBlockedFrame(outgoingMaxOffset));\n                bytesLeftInPacket = maxBytesRemoteConnectionCanReceive;\n            }\n            for (let [_, stream] of this.streams) {\n                if (bytesLeftInPacket - 20 <= 0) {\n                    break;\n                }\n                const { data, offset } = stream._getAvailableDataToSend(bytesLeftInPacket - 20);\n                if (data && data.length > 0) {\n                    const streamDataFrame = new packet_1.StreamDataFrame(stream.id, offset, data);\n                    this.log.trace('sending %d bytes from stream %d', data.length, stream.id);\n                    bytesLeftInPacket -= streamDataFrame.byteLength();\n                    requestPacket.frames.push(streamDataFrame);\n                }\n                const maxOutgoingOffset = stream._isDataBlocked();\n                if (maxOutgoingOffset) {\n                    this.log.trace('telling remote that stream %d is blocked and has more data to send', stream.id);\n                    requestPacket.frames.push(new packet_1.StreamDataBlockedFrame(stream.id, maxOutgoingOffset));\n                }\n            }\n            if (amountToSend.equals(0)) {\n                if (requestPacket.frames.length === 0) {\n                    this.sending = false;\n                    return;\n                }\n                else {\n                    if (!requestPacket.frames.find(frame => ((frame.type === packet_1.FrameType.StreamClose)\n                        || (frame.type === packet_1.FrameType.StreamData)\n                        || (frame.type === packet_1.FrameType.StreamMoney)))) {\n                        this.sending = false;\n                    }\n                }\n            }\n            const minimumDestinationAmount = this.slippage.complement().multiplyByLong(this.exchangeRate.multiplyByLong(amountToSend));\n            if (minimumDestinationAmount.greaterThan(0)) {\n                requestPacket.prepareAmount = minimumDestinationAmount;\n            }\n            const responsePacket = yield this.sendPacket(requestPacket, amountToSend, false);\n            if (responsePacket) {\n                if (this.remoteState === RemoteState.Init) {\n                    this.remoteState = RemoteState.Connected;\n                }\n                this.remoteKnowsOurAccount = true;\n                this.handleControlFrames(responsePacket.frames);\n                if (amountToSend.greaterThan(0)) {\n                    this._lastPacketExchangeRate = new rational_1.default(responsePacket.prepareAmount, amountToSend, true);\n                }\n                if (responsePacket.ilpPacketType === packet_1.IlpPacketType.Fulfill) {\n                    for (let stream of streamsSentFrom) {\n                        stream._executeHold(requestPacket.sequence.toString());\n                    }\n                    this.addTotalDelivered(responsePacket.prepareAmount);\n                    this.addTotalSent(amountToSend);\n                    this.congestion.onFulfill(amountToSend);\n                    this.retryDelay = RETRY_DELAY_START;\n                }\n            }\n        });\n    }\n    sendTestPacketVolley(testPacketAmounts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const results = yield Promise.all(testPacketAmounts.map((amount) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    return this.sendTestPacket(Long.fromNumber(amount, true));\n                }\n                catch (err) {\n                    this.log.error('Error sending test packet for amount %d: %s', amount, err);\n                    return null;\n                }\n            })));\n            const maxPacketAmounts = testPacketAmounts.map((sourceAmount, index) => {\n                if (results[index] && results[index].code === 'F08') {\n                    try {\n                        const reader = oer_utils_1.Reader.from(results[index].data);\n                        const receivedAmount = reader.readUInt64Long();\n                        const maximumAmount = reader.readUInt64Long();\n                        const maximumPacketAmount = long_1.multiplyDivideFloor(Long.fromNumber(sourceAmount, true), maximumAmount, receivedAmount);\n                        this.log.debug('sending test packet of %d resulted in F08 error that told us maximum packet amount is %s', testPacketAmounts[index], maximumPacketAmount);\n                        return maximumPacketAmount;\n                    }\n                    catch (err) {\n                        return Long.MAX_UNSIGNED_VALUE;\n                    }\n                }\n                return Long.MAX_UNSIGNED_VALUE;\n            });\n            const { maxDigits, exchangeRate, packetErrors } = results.reduce(({ maxDigits, exchangeRate, packetErrors }, result, index) => {\n                const sourceAmount = testPacketAmounts[index];\n                if (result && result.code) {\n                    packetErrors.push({\n                        sourceAmount: sourceAmount,\n                        code: result.code\n                    });\n                }\n                if (result && result.prepareAmount) {\n                    const prepareAmount = result.prepareAmount;\n                    const exchangeRate = new rational_1.default(prepareAmount, Long.fromNumber(sourceAmount, true), true);\n                    this.log.debug('sending test packet of %d delivered %s (exchange rate: %s)', sourceAmount, prepareAmount, exchangeRate);\n                    if (long_1.countDigits(prepareAmount) >= maxDigits) {\n                        return {\n                            maxDigits: long_1.countDigits(prepareAmount),\n                            exchangeRate,\n                            packetErrors\n                        };\n                    }\n                }\n                return { maxDigits, exchangeRate, packetErrors };\n            }, { maxDigits: 0, exchangeRate: rational_1.default.UZERO, packetErrors: [] });\n            return { maxDigits, exchangeRate, maxPacketAmounts, packetErrors };\n        });\n    }\n    setupExchangeRate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.exchangeRate) {\n                this.log.trace('determining exchange rate');\n                yield this.determineExchangeRate();\n            }\n            process.nextTick(() => {\n                this.safeEmit('connect');\n                this.log.trace('connected');\n            });\n        });\n    }\n    determineExchangeRate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.log.trace('determineExchangeRate');\n            if (!this._destinationAccount) {\n                throw new Error('Cannot determine exchange rate. Destination account is unknown');\n            }\n            let retryDelay = RETRY_DELAY_START;\n            let testPacketAmounts = [1, 1e3, 1e6, 1e9, 1e12];\n            let attempts = 0;\n            while (!this.exchangeRate && testPacketAmounts.length > 0 && attempts < TEST_PACKET_MAX_ATTEMPTS) {\n                attempts++;\n                const { maxDigits, exchangeRate, maxPacketAmounts, packetErrors } = yield this.sendTestPacketVolley(testPacketAmounts);\n                this.congestion.setMaximumAmounts(long_1.minLongs(maxPacketAmounts.concat(this.congestion.maximumPacketAmount)));\n                if (this.congestion.maximumPacketAmount.equals(0)) {\n                    this.log.error('cannot send anything through this path. the maximum packet amount is 0');\n                    throw new Error('Cannot send. Path has a Maximum Packet Amount of 0');\n                }\n                if (maxDigits >= this.minExchangeRatePrecision) {\n                    this.log.debug('determined exchange rate to be %s with %d digits precision', exchangeRate, maxDigits);\n                    this.exchangeRate = exchangeRate;\n                    return;\n                }\n                testPacketAmounts = maxPacketAmounts\n                    .filter((amount) => !amount.equals(Long.MAX_UNSIGNED_VALUE))\n                    .reduce((acc, curr) => [...new Set([...acc, curr.toString()])], []);\n                if (packetErrors.some((error) => error.code[0] === 'T')) {\n                    const smallestPacketAmount = packetErrors.reduce((min, error) => {\n                        return long_1.minLong(min, Long.fromNumber(error.sourceAmount, true));\n                    }, Long.MAX_UNSIGNED_VALUE);\n                    const reducedPacketAmount = smallestPacketAmount.subtract(smallestPacketAmount.divide(3));\n                    this.log.debug('got Txx error(s), waiting %dms and reducing packet amount to %s before sending another test packet', retryDelay, reducedPacketAmount);\n                    testPacketAmounts = [...testPacketAmounts, reducedPacketAmount];\n                    yield new Promise((resolve, reject) => setTimeout(resolve, retryDelay));\n                    retryDelay *= RETRY_DELAY_INCREASE_FACTOR;\n                }\n                this.log.debug('retry with packet amounts %j', testPacketAmounts);\n            }\n            throw new Error(`Unable to establish connection, no packets meeting the minimum exchange precision of ${this.minExchangeRatePrecision} digits made it through the path.`);\n        });\n    }\n    sendTestPacket(amount, timeout = DEFAULT_PACKET_TIMEOUT) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const requestPacket = new packet_1.Packet(this.getNextPacketSequence(), packet_1.IlpPacketType.Prepare);\n            this.log.trace('sending test packet %s for amount: %s. timeout: %d', requestPacket.sequence, amount, timeout);\n            this.maybePushAccountFrames(requestPacket);\n            const prepare = {\n                destination: this._destinationAccount,\n                amount: amount.toString(),\n                data: yield requestPacket.serializeAndEncrypt(this._pskKey),\n                executionCondition: cryptoHelper.generateRandomCondition(),\n                expiresAt: new Date(Date.now() + timeout)\n            };\n            const responseData = yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const timer = setTimeout(() => {\n                    this.log.error('test packet %s timed out before we got a response', requestPacket.sequence);\n                    resolve(null);\n                }, timeout);\n                const result = yield this.plugin.sendData(IlpPacket.serializeIlpPrepare(prepare));\n                clearTimeout(timer);\n                resolve(result);\n            }));\n            if (!responseData) {\n                return null;\n            }\n            this.bumpIdle();\n            const ilpReject = IlpPacket.deserializeIlpReject(responseData);\n            let responsePacket;\n            if (ilpReject.code === 'F99' && ilpReject.data.length > 0) {\n                responsePacket = yield packet_1.Packet.decryptAndDeserialize(this._pskKey, ilpReject.data);\n                if (!responsePacket.sequence.equals(requestPacket.sequence)) {\n                    this.log.error('response packet sequence does not match the request packet. expected sequence: %s, got response packet: %j', requestPacket.sequence, responsePacket);\n                    throw new Error(`Response packet sequence does not correspond to the request. Actual: ${responsePacket.sequence}, expected: ${requestPacket.sequence}`);\n                }\n                if (responsePacket.ilpPacketType !== responseData[0]) {\n                    this.log.error('response packet was on wrong ILP packet type. expected ILP packet type: %d, got: %j', responseData[0], responsePacket);\n                    throw new Error(`Response says it should be on an ILP packet of type: ${responsePacket.ilpPacketType} but it was carried on an ILP packet of type: ${responseData[0]}`);\n                }\n            }\n            else {\n                this.log.debug('test packet %s was rejected with a %s triggered by %s error%s', requestPacket.sequence, ilpReject.code, ilpReject.triggeredBy, ilpReject.message ? ' with the message: \"' + ilpReject.message + '\"' : '');\n            }\n            if (responsePacket) {\n                this.remoteKnowsOurAccount = true;\n                this.handleControlFrames(responsePacket.frames);\n                return responsePacket;\n            }\n            else {\n                return ilpReject;\n            }\n        });\n    }\n    sendConnectionClose(err) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.remoteState === RemoteState.Closed) {\n                this.log.debug('not sending connection error because remote is already closed');\n                return;\n            }\n            let errorCode;\n            let errorMessage;\n            if (err && err instanceof ConnectionError) {\n                errorCode = err.streamErrorCode;\n                errorMessage = err.message;\n            }\n            else if (err) {\n                errorCode = packet_1.ErrorCode.InternalError;\n                errorMessage = err.message;\n            }\n            else {\n                errorCode = packet_1.ErrorCode.NoError;\n                errorMessage = '';\n            }\n            const packet = new packet_1.Packet(this.nextPacketSequence++, packet_1.IlpPacketType.Prepare, 0, [\n                new packet_1.ConnectionCloseFrame(errorCode, errorMessage)\n            ]);\n            try {\n                const prepare = {\n                    destination: this._destinationAccount,\n                    amount: '0',\n                    data: yield packet.serializeAndEncrypt(this._pskKey),\n                    executionCondition: cryptoHelper.generateRandomCondition(),\n                    expiresAt: new Date(Date.now() + DEFAULT_PACKET_TIMEOUT)\n                };\n                yield this.plugin.sendData(IlpPacket.serializeIlpPrepare(prepare));\n            }\n            catch (err) {\n                this.log.error('error while trying to inform peer that connection is closing, but closing anyway', err);\n            }\n            this.remoteState = RemoteState.Closed;\n        });\n    }\n    sendPacket(packet, sourceAmount, unfulfillable = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.log.trace('sending packet %s with source amount: %s: %j', packet.sequence, sourceAmount, packet);\n            const data = yield packet.serializeAndEncrypt(this._pskKey, (this.enablePadding ? MAX_DATA_SIZE : undefined));\n            let fulfillment;\n            let executionCondition;\n            if (unfulfillable) {\n                fulfillment = undefined;\n                executionCondition = cryptoHelper.generateRandomCondition();\n            }\n            else {\n                fulfillment = yield cryptoHelper.generateFulfillment(this._fulfillmentKey, data);\n                executionCondition = yield cryptoHelper.hash(fulfillment);\n            }\n            const prepare = {\n                destination: this._destinationAccount,\n                amount: sourceAmount.toString(),\n                data,\n                executionCondition,\n                expiresAt: new Date(Date.now() + DEFAULT_PACKET_TIMEOUT)\n            };\n            const responseData = yield this.plugin.sendData(IlpPacket.serializeIlpPrepare(prepare));\n            this.bumpIdle();\n            let response;\n            try {\n                if (responseData[0] === IlpPacket.Type.TYPE_ILP_FULFILL) {\n                    response = IlpPacket.deserializeIlpFulfill(responseData);\n                }\n                else if (responseData[0] === IlpPacket.Type.TYPE_ILP_REJECT) {\n                    response = IlpPacket.deserializeIlpReject(responseData);\n                }\n                else {\n                    throw new Error(`Invalid response packet type: ${responseData[0]}`);\n                }\n            }\n            catch (err) {\n                this.log.error('got invalid response from sending packet %s: %s %h', packet.sequence, err, responseData);\n                throw new Error(`Invalid response when sending packet ${packet.sequence}: ${err.message}`);\n            }\n            if (fulfillment && isFulfill(response)) {\n                if (!(yield cryptoHelper.hash(response.fulfillment)).equals(executionCondition)) {\n                    this.log.error('got invalid fulfillment for packet %s: %h. expected: %h for condition: %h', packet.sequence, response.fulfillment, fulfillment, executionCondition);\n                    throw new Error(`Got invalid fulfillment for packet ${packet.sequence}. Actual: ${response.fulfillment.toString('hex')}, expected: ${fulfillment.toString('hex')}`);\n                }\n            }\n            else {\n                response = response;\n                this.undoRejectedPacket(packet);\n                if (response.code !== 'F99') {\n                    return this.handleConnectorError(response, sourceAmount);\n                }\n            }\n            if (response.data.length === 0) {\n                return undefined;\n            }\n            let responsePacket;\n            try {\n                responsePacket = yield packet_1.Packet.decryptAndDeserialize(this._pskKey, response.data);\n            }\n            catch (err) {\n                this.log.error('unable to decrypt and parse response data: %s %h', err);\n                throw new Error('Unable to decrypt and parse response data: ' + err.message);\n            }\n            if (!responsePacket.sequence.equals(packet.sequence)) {\n                this.log.error('response packet sequence does not match the request packet. expected sequence: %s, got response packet: %j', packet.sequence, responsePacket);\n                throw new Error(`Response packet sequence does not correspond to the request. Actual: ${responsePacket.sequence}, expected: ${packet.sequence}`);\n            }\n            if (responsePacket.ilpPacketType !== responseData[0]) {\n                this.log.error('response packet was on wrong ILP packet type. expected ILP packet type: %d, got: %j', responseData[0], responsePacket);\n                throw new Error(`Response says it should be on an ILP packet of type: ${responsePacket.ilpPacketType} but it was carried on an ILP packet of type: ${responseData[0]}`);\n            }\n            this.log.debug('got response to packet: %s: %j', packet.sequence, responsePacket);\n            return responsePacket;\n        });\n    }\n    undoRejectedPacket(requestPacket) {\n        this.log.debug('packet %s was rejected', requestPacket.sequence);\n        for (let frame of requestPacket.frames) {\n            switch (frame.type) {\n                case packet_1.FrameType.StreamMoney:\n                    const stream1 = this.streams.get(frame.streamId.toNumber());\n                    if (stream1)\n                        stream1._cancelHold(requestPacket.sequence.toString());\n                    break;\n                case packet_1.FrameType.StreamData:\n                    const stream2 = this.streams.get(frame.streamId.toNumber());\n                    if (stream2)\n                        stream2._resendOutgoingData(frame.data, frame.offset.toNumber());\n                    break;\n                case packet_1.FrameType.StreamClose:\n                    this.queuedFrames.push(frame);\n                    break;\n                default:\n                    continue;\n            }\n        }\n    }\n    handleConnectorError(reject, amountSent) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.log.debug('handling reject triggered by: %s error: %s message: %s data: %h', reject.triggeredBy, reject.code, reject.message, reject.data);\n            if (reject.code === 'F08') {\n                const maximumPacketAmount = this.congestion.onAmountTooLargeError(reject, amountSent);\n                if (maximumPacketAmount.equals(0)) {\n                    this.log.error('cannot send anything through this path. the maximum packet amount is 0');\n                    throw new Error('Cannot send. Path has a Maximum Packet Amount of 0');\n                }\n            }\n            else if (reject.code[0] === 'T') {\n                if (reject.code === 'T04') {\n                    this.congestion.onInsufficientLiquidityError(reject, amountSent);\n                }\n                this.log.warn('got %s temporary error triggered by: %s. waiting %dms before trying again', reject.code, reject.triggeredBy, this.retryDelay);\n                const delay = this.retryDelay;\n                this.retryDelay = Math.min(this.retryDelay * 2, RETRY_DELAY_MAX);\n                yield new Promise((resolve, reject) => setTimeout(resolve, delay));\n            }\n            else {\n                this.log.error('unexpected error. code: %s, triggered by: %s, message: %s, data: %h', reject.code, reject.triggeredBy, reject.message, reject.data);\n                throw new Error(`Unexpected error while sending packet. Code: ${reject.code}, triggered by: ${reject.triggeredBy}, message: ${reject.message}`);\n            }\n        });\n    }\n    safeEmit(event, ...args) {\n        try {\n            args.unshift(event);\n            this.emit.apply(this, args);\n        }\n        catch (err) {\n            this.log.debug('error in %s handler: %s', event, err);\n        }\n    }\n    getOutgoingOffsets() {\n        let currentOffset = 0;\n        let maxOffset = 0;\n        for (let [_, stream] of this.streams) {\n            const streamOffsets = stream._getOutgoingOffsets();\n            currentOffset += streamOffsets.current;\n            maxOffset += streamOffsets.max;\n        }\n        return {\n            currentOffset,\n            maxOffset\n        };\n    }\n    getIncomingOffsets() {\n        let totalMaxOffset = 0;\n        let totalReadOffset = 0;\n        let totalBufferedData = 0;\n        for (let [_, stream] of this.streams) {\n            const { max, current } = stream._getIncomingOffsets();\n            totalMaxOffset += max;\n            totalReadOffset += current;\n            totalBufferedData += stream.readableLength;\n        }\n        return {\n            current: totalReadOffset,\n            max: totalMaxOffset,\n            maxAcceptable: totalReadOffset - totalBufferedData + this.maxBufferedData\n        };\n    }\n    removeStreamRecord(stream) {\n        this.log.debug('removing record of stream %d', stream.id);\n        this.streams.delete(stream.id);\n        this.closedStreams.add(stream.id);\n        if (!stream._sentEnd) {\n            stream._sentEnd = true;\n            const streamEndFrame = (stream._errorMessage\n                ? new packet_1.StreamCloseFrame(stream.id, packet_1.ErrorCode.ApplicationError, stream._errorMessage)\n                : new packet_1.StreamCloseFrame(stream.id, packet_1.ErrorCode.NoError, ''));\n            this.queuedFrames.push(streamEndFrame);\n            setImmediate(() => this.startSendLoop());\n        }\n    }\n    startIdleTimer() {\n        if (this.idleTimeout === 0)\n            return;\n        const idle = Date.now() - this.lastActive.getTime();\n        this.idleTimer = setTimeout(() => this.testIdle(), this.idleTimeout - idle);\n        if (typeof this.idleTimer.unref === 'function') {\n            this.idleTimer.unref();\n        }\n        this.log.trace('(re)starting idle timeout for %dms from now', this.idleTimeout);\n    }\n    testIdle() {\n        const idle = Date.now() - this.lastActive.getTime();\n        if (idle >= this.idleTimeout) {\n            this.log.error('Connection timed out due to inactivity, destroying connection');\n            this.destroy(new Error('Connection timed out due to inactivity'));\n        }\n        else {\n            this.startIdleTimer();\n        }\n    }\n    bumpIdle() { this.lastActive = new Date(); }\n    addTotalReceived(value) {\n        const result = long_1.checkedAdd(this._totalReceived, value);\n        if (result.overflow) {\n            const err = new IlpPacket.Errors.BadRequestError('Total received exceeded MaxUint64');\n            err['ilpErrorMessage'] = err.message;\n            this.destroy(err);\n            throw err;\n        }\n        else {\n            this._totalReceived = result.sum;\n        }\n    }\n    addTotalSent(value) {\n        const result = long_1.checkedAdd(this._totalSent, value);\n        if (result.overflow) {\n            const err = new IlpPacket.Errors.BadRequestError('Total sent exceeded MaxUint64');\n            err['ilpErrorMessage'] = err.message;\n            this.destroy(err);\n            throw err;\n        }\n        else {\n            this._totalSent = result.sum;\n        }\n    }\n    addTotalDelivered(value) {\n        const result = long_1.checkedAdd(this._totalDelivered, value);\n        if (result.overflow) {\n            const err = new IlpPacket.Errors.BadRequestError('Total delivered exceeded MaxUint64');\n            err['ilpErrorMessage'] = err.message;\n            this.destroy(err);\n            throw err;\n        }\n        else {\n            this._totalDelivered = result.sum;\n        }\n    }\n    getNextPacketSequence() {\n        const sequence = this.nextPacketSequence++;\n        if (sequence >= Math.pow(2, 31)) {\n            throw new ConnectionError('Connection exceeded maximum number of packets', packet_1.ErrorCode.InternalError);\n        }\n        return sequence;\n    }\n    maybePushAccountFrames(requestPacket) {\n        if (!this.remoteKnowsOurAccount) {\n            requestPacket.frames.push(new packet_1.ConnectionNewAddressFrame(this._sourceAccount));\n            requestPacket.frames.push(new packet_1.ConnectionAssetDetailsFrame(this._sourceAssetCode, this._sourceAssetScale));\n        }\n    }\n}\nexports.Connection = Connection;\nfunction isFulfill(packet) {\n    return packet.hasOwnProperty('fulfillment');\n}\n//# sourceMappingURL=connection.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../timers-browserify/main.js */ \"../../node_modules/timers-browserify/main.js\").setImmediate, __webpack_require__(/*! ./../../../process/browser.js */ \"../../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/connection.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-stream/dist/src/crypto.js':
        /*!*************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/crypto.js ***!
  \*************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, "__esModule", { value: true });\nconst crypto_node_1 = __webpack_require__(/*! ./util/crypto-node */ "../../node_modules/ilp-protocol-stream/dist/src/util/crypto-browser.js");\nvar crypto_node_2 = __webpack_require__(/*! ./util/crypto-node */ "../../node_modules/ilp-protocol-stream/dist/src/util/crypto-browser.js");\nexports.decrypt = crypto_node_2.decrypt;\nexports.encrypt = crypto_node_2.encrypt;\nexports.generateSharedSecretFromToken = crypto_node_2.generateSharedSecretFromToken;\nexports.hash = crypto_node_2.hash;\nexports.randomBytes = crypto_node_2.randomBytes;\nconst TOKEN_LENGTH = 18;\nconst ENCRYPTION_KEY_STRING = Buffer.from(\'ilp_stream_encryption\', \'utf8\');\nconst FULFILLMENT_GENERATION_STRING = Buffer.from(\'ilp_stream_fulfillment\', \'utf8\');\nexports.ENCRYPTION_OVERHEAD = 28;\nfunction generateToken() {\n    return crypto_node_1.randomBytes(TOKEN_LENGTH);\n}\nexports.generateToken = generateToken;\nfunction generateRandomCondition() {\n    return crypto_node_1.randomBytes(32);\n}\nexports.generateRandomCondition = generateRandomCondition;\nfunction generatePskEncryptionKey(sharedSecret) {\n    return crypto_node_1.hmac(sharedSecret, ENCRYPTION_KEY_STRING);\n}\nexports.generatePskEncryptionKey = generatePskEncryptionKey;\nfunction generateFulfillmentKey(sharedSecret) {\n    return crypto_node_1.hmac(sharedSecret, FULFILLMENT_GENERATION_STRING);\n}\nexports.generateFulfillmentKey = generateFulfillmentKey;\nfunction generateFulfillment(fulfillmentKey, data) {\n    return crypto_node_1.hmac(fulfillmentKey, data);\n}\nexports.generateFulfillment = generateFulfillment;\n//# sourceMappingURL=crypto.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "../../node_modules/buffer/index.js").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/crypto.js?'
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-stream/dist/src/index.js':
        /*!************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/index.js ***!
  \************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nconst ILDCP = __webpack_require__(/*! ilp-protocol-ildcp */ "../../node_modules/ilp-protocol-ildcp/dist/src/index.js");\nconst IlpPacket = __webpack_require__(/*! ilp-packet */ "../../node_modules/ilp-packet/dist/index.js");\nconst ilp_logger_1 = __webpack_require__(/*! ilp-logger */ "../../node_modules/ilp-logger/build/index.js");\n__webpack_require__(/*! ./util/formatters */ "../../node_modules/ilp-protocol-stream/dist/src/util/formatters.js");\nconst connection_1 = __webpack_require__(/*! ./connection */ "../../node_modules/ilp-protocol-stream/dist/src/connection.js");\nconst CONNECTION_ID_REGEX = /^[a-zA-Z0-9~_-]+$/;\nvar connection_2 = __webpack_require__(/*! ./connection */ "../../node_modules/ilp-protocol-stream/dist/src/connection.js");\nexports.Connection = connection_2.Connection;\nvar stream_1 = __webpack_require__(/*! ./stream */ "../../node_modules/ilp-protocol-stream/dist/src/stream.js");\nexports.DataAndMoneyStream = stream_1.DataAndMoneyStream;\nvar server_1 = __webpack_require__(/*! ./server */ 3);\nexports.Server = server_1.Server;\nexports.createServer = server_1.createServer;\nfunction createConnection(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const plugin = opts.plugin;\n        yield plugin.connect();\n        const log = ilp_logger_1.default(\'ilp-protocol-stream:Client\');\n        const { clientAddress, assetCode, assetScale } = yield ILDCP.fetch(plugin.sendData.bind(plugin));\n        const connection = yield connection_1.Connection.build(Object.assign(Object.assign({}, opts), { sourceAccount: clientAddress, assetCode,\n            assetScale, isServer: false, plugin }));\n        plugin.registerDataHandler((data) => __awaiter(this, void 0, void 0, function* () {\n            let prepare;\n            try {\n                prepare = IlpPacket.deserializeIlpPrepare(data);\n            }\n            catch (err) {\n                log.error(\'got data that is not an ILP Prepare packet: %h\', data);\n                return IlpPacket.serializeIlpReject({\n                    code: \'F00\',\n                    message: `Expected an ILP Prepare packet (type 12), but got packet with type: ${data[0]}`,\n                    data: Buffer.alloc(0),\n                    triggeredBy: clientAddress\n                });\n            }\n            try {\n                const fulfill = yield connection.handlePrepare(prepare);\n                return IlpPacket.serializeIlpFulfill(fulfill);\n            }\n            catch (err) {\n                if (!err.ilpErrorCode) {\n                    log.error(\'error handling prepare:\', err);\n                }\n                return IlpPacket.serializeIlpReject({\n                    code: err.ilpErrorCode || \'F00\',\n                    message: err.ilpErrorMessage || \'\',\n                    data: err.ilpErrorData || Buffer.alloc(0),\n                    triggeredBy: clientAddress\n                });\n            }\n        }));\n        connection.once(\'close\', () => {\n            plugin.deregisterDataHandler();\n            plugin.disconnect()\n                .then(() => log.info(\'plugin disconnected\'))\n                .catch((err) => log.error(\'error disconnecting plugin:\', err));\n        });\n        yield connection.connect();\n        return connection;\n    });\n}\nexports.createConnection = createConnection;\n//# sourceMappingURL=index.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "../../node_modules/buffer/index.js").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/index.js?'
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-stream/dist/src/packet.js':
        /*!*************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/packet.js ***!
  \*************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nconst oer_utils_1 = __webpack_require__(/*! oer-utils */ "../../node_modules/oer-utils/dist/src/index.js");\nconst IlpPacket = __webpack_require__(/*! ilp-packet */ "../../node_modules/ilp-packet/dist/index.js");\nconst Long = __webpack_require__(/*! long */ "../../node_modules/long/src/long.js");\nconst crypto_1 = __webpack_require__(/*! ./crypto */ "../../node_modules/ilp-protocol-stream/dist/src/crypto.js");\nconst long_1 = __webpack_require__(/*! ./util/long */ "../../node_modules/ilp-protocol-stream/dist/src/util/long.js");\nconst VERSION = Long.fromNumber(1, true);\nconst ZERO_BYTES = Buffer.alloc(32);\nexports.IlpPacketType = {\n    Prepare: IlpPacket.Type.TYPE_ILP_PREPARE,\n    Fulfill: IlpPacket.Type.TYPE_ILP_FULFILL,\n    Reject: IlpPacket.Type.TYPE_ILP_REJECT\n};\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode["NoError"] = 1] = "NoError";\n    ErrorCode[ErrorCode["InternalError"] = 2] = "InternalError";\n    ErrorCode[ErrorCode["EndpointBusy"] = 3] = "EndpointBusy";\n    ErrorCode[ErrorCode["FlowControlError"] = 4] = "FlowControlError";\n    ErrorCode[ErrorCode["StreamIdError"] = 5] = "StreamIdError";\n    ErrorCode[ErrorCode["StreamStateError"] = 6] = "StreamStateError";\n    ErrorCode[ErrorCode["FrameFormatError"] = 7] = "FrameFormatError";\n    ErrorCode[ErrorCode["ProtocolViolation"] = 8] = "ProtocolViolation";\n    ErrorCode[ErrorCode["ApplicationError"] = 9] = "ApplicationError";\n})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));\nvar FrameType;\n(function (FrameType) {\n    FrameType[FrameType["ConnectionClose"] = 1] = "ConnectionClose";\n    FrameType[FrameType["ConnectionNewAddress"] = 2] = "ConnectionNewAddress";\n    FrameType[FrameType["ConnectionMaxData"] = 3] = "ConnectionMaxData";\n    FrameType[FrameType["ConnectionDataBlocked"] = 4] = "ConnectionDataBlocked";\n    FrameType[FrameType["ConnectionMaxStreamId"] = 5] = "ConnectionMaxStreamId";\n    FrameType[FrameType["ConnectionStreamIdBlocked"] = 6] = "ConnectionStreamIdBlocked";\n    FrameType[FrameType["ConnectionAssetDetails"] = 7] = "ConnectionAssetDetails";\n    FrameType[FrameType["StreamClose"] = 16] = "StreamClose";\n    FrameType[FrameType["StreamMoney"] = 17] = "StreamMoney";\n    FrameType[FrameType["StreamMaxMoney"] = 18] = "StreamMaxMoney";\n    FrameType[FrameType["StreamMoneyBlocked"] = 19] = "StreamMoneyBlocked";\n    FrameType[FrameType["StreamData"] = 20] = "StreamData";\n    FrameType[FrameType["StreamMaxData"] = 21] = "StreamMaxData";\n    FrameType[FrameType["StreamDataBlocked"] = 22] = "StreamDataBlocked";\n})(FrameType = exports.FrameType || (exports.FrameType = {}));\nclass Packet {\n    constructor(sequence, ilpPacketType, packetAmount = Long.UZERO, frames = []) {\n        this.sequence = long_1.longFromValue(sequence, true);\n        this.ilpPacketType = ilpPacketType;\n        this.prepareAmount = long_1.longFromValue(packetAmount, true);\n        this.frames = frames;\n    }\n    static decryptAndDeserialize(pskEncryptionKey, buffer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let decrypted;\n            try {\n                decrypted = yield crypto_1.decrypt(pskEncryptionKey, buffer);\n            }\n            catch (err) {\n                throw new Error(`Unable to decrypt packet. Data was corrupted or packet was encrypted with the wrong key`);\n            }\n            return Packet._deserializeUnencrypted(decrypted);\n        });\n    }\n    static _deserializeUnencrypted(buffer) {\n        const reader = oer_utils_1.Reader.from(buffer);\n        const version = reader.readUInt8Long();\n        if (!version.equals(VERSION)) {\n            throw new Error(`Unsupported protocol version: ${version}`);\n        }\n        const ilpPacketType = reader.readUInt8Number();\n        const sequence = reader.readVarUIntLong();\n        const packetAmount = reader.readVarUIntLong();\n        const numFrames = reader.readVarUIntNumber();\n        const frames = [];\n        for (let i = 0; i < numFrames; i++) {\n            const frame = parseFrame(reader);\n            if (frame) {\n                frames.push(frame);\n            }\n        }\n        return new Packet(sequence, ilpPacketType, packetAmount, frames);\n    }\n    serializeAndEncrypt(pskEncryptionKey, padPacketToSize) {\n        const serialized = this._serialize();\n        if (padPacketToSize !== undefined) {\n            const paddingSize = padPacketToSize - crypto_1.ENCRYPTION_OVERHEAD - serialized.length;\n            const args = [pskEncryptionKey, serialized];\n            for (let i = 0; i < Math.floor(paddingSize / 32); i++) {\n                args.push(ZERO_BYTES);\n            }\n            args.push(ZERO_BYTES.slice(0, paddingSize % 32));\n            return crypto_1.encrypt.apply(null, args);\n        }\n        return crypto_1.encrypt(pskEncryptionKey, serialized);\n    }\n    _serialize() {\n        const predictor = new oer_utils_1.Predictor();\n        this.writeTo(predictor);\n        const writer = new oer_utils_1.Writer(predictor.length);\n        this.writeTo(writer);\n        return writer.getBuffer();\n    }\n    writeTo(writer) {\n        writer.writeUInt8(VERSION);\n        writer.writeUInt8(this.ilpPacketType);\n        writer.writeVarUInt(this.sequence);\n        writer.writeVarUInt(this.prepareAmount);\n        writer.writeVarUInt(this.frames.length);\n        for (let frame of this.frames) {\n            frame.writeTo(writer);\n        }\n    }\n    byteLength() {\n        const predictor = new oer_utils_1.Predictor();\n        this.writeTo(predictor);\n        return predictor.getSize() + crypto_1.ENCRYPTION_OVERHEAD;\n    }\n}\nexports.Packet = Packet;\nclass BaseFrame {\n    constructor(name) {\n        this.type = FrameType[name];\n        this.name = name;\n    }\n    static fromContents(reader) {\n        throw new Error(`class method "fromContents" is not implemented`);\n    }\n    writeTo(writer) {\n        const predictor = new oer_utils_1.Predictor();\n        this.writeContentsTo(predictor);\n        writer.writeUInt8(this.type);\n        this.writeContentsTo(writer.createVarOctetString(predictor.length));\n        return writer;\n    }\n    writeContentsTo(contents) {\n        const properties = Object.getOwnPropertyNames(this).filter((propName) => propName !== \'type\' && propName !== \'name\');\n        for (let prop of properties) {\n            const value = this[prop];\n            if (typeof value === \'number\') {\n                contents.writeUInt8(value);\n            }\n            else if (typeof value === \'string\') {\n                contents.writeVarOctetString(Buffer.from(value, \'utf8\'));\n            }\n            else if (Buffer.isBuffer(value)) {\n                contents.writeVarOctetString(value);\n            }\n            else if (Long.isLong(value)) {\n                contents.writeVarUInt(value);\n            }\n            else {\n                throw new Error(`Unexpected property type for property "${prop}": ${typeof value}`);\n            }\n        }\n    }\n    byteLength() {\n        const predictor = new oer_utils_1.Predictor();\n        this.writeTo(predictor);\n        return predictor.getSize();\n    }\n}\nexports.BaseFrame = BaseFrame;\nclass ConnectionCloseFrame extends BaseFrame {\n    constructor(errorCode, errorMessage) {\n        super(\'ConnectionClose\');\n        this.errorCode = errorCode;\n        this.errorMessage = errorMessage;\n    }\n    static fromContents(reader) {\n        const errorCode = reader.readUInt8Number();\n        const errorMessage = reader.readVarOctetString().toString();\n        return new ConnectionCloseFrame(errorCode, errorMessage);\n    }\n}\nexports.ConnectionCloseFrame = ConnectionCloseFrame;\nclass ConnectionNewAddressFrame extends BaseFrame {\n    constructor(sourceAccount) {\n        super(\'ConnectionNewAddress\');\n        this.sourceAccount = sourceAccount;\n    }\n    static fromContents(reader) {\n        const sourceAccount = reader.readVarOctetString().toString(\'utf8\');\n        return new ConnectionNewAddressFrame(sourceAccount);\n    }\n}\nexports.ConnectionNewAddressFrame = ConnectionNewAddressFrame;\nclass ConnectionAssetDetailsFrame extends BaseFrame {\n    constructor(sourceAssetCode, sourceAssetScale) {\n        super(\'ConnectionAssetDetails\');\n        this.sourceAssetCode = sourceAssetCode;\n        this.sourceAssetScale = sourceAssetScale;\n    }\n    static fromContents(reader) {\n        const sourceAssetCode = reader.readVarOctetString().toString(\'utf8\');\n        const sourceAssetScale = reader.readUInt8Number();\n        return new ConnectionAssetDetailsFrame(sourceAssetCode, sourceAssetScale);\n    }\n}\nexports.ConnectionAssetDetailsFrame = ConnectionAssetDetailsFrame;\nclass ConnectionMaxDataFrame extends BaseFrame {\n    constructor(maxOffset) {\n        super(\'ConnectionMaxData\');\n        this.maxOffset = long_1.longFromValue(maxOffset, true);\n    }\n    static fromContents(reader) {\n        const maxOffset = reader.readVarUIntLong();\n        return new ConnectionMaxDataFrame(maxOffset);\n    }\n}\nexports.ConnectionMaxDataFrame = ConnectionMaxDataFrame;\nclass ConnectionDataBlockedFrame extends BaseFrame {\n    constructor(maxOffset) {\n        super(\'ConnectionDataBlocked\');\n        this.maxOffset = long_1.longFromValue(maxOffset, true);\n    }\n    static fromContents(reader) {\n        const maxOffset = reader.readVarUIntLong();\n        return new ConnectionDataBlockedFrame(maxOffset);\n    }\n}\nexports.ConnectionDataBlockedFrame = ConnectionDataBlockedFrame;\nclass ConnectionMaxStreamIdFrame extends BaseFrame {\n    constructor(maxStreamId) {\n        super(\'ConnectionMaxStreamId\');\n        this.maxStreamId = long_1.longFromValue(maxStreamId, true);\n    }\n    static fromContents(reader) {\n        const maxStreamId = reader.readVarUIntLong();\n        return new ConnectionMaxStreamIdFrame(maxStreamId);\n    }\n}\nexports.ConnectionMaxStreamIdFrame = ConnectionMaxStreamIdFrame;\nclass ConnectionStreamIdBlockedFrame extends BaseFrame {\n    constructor(maxStreamId) {\n        super(\'ConnectionStreamIdBlocked\');\n        this.maxStreamId = long_1.longFromValue(maxStreamId, true);\n    }\n    static fromContents(reader) {\n        const maxStreamId = reader.readVarUIntLong();\n        return new ConnectionStreamIdBlockedFrame(maxStreamId);\n    }\n}\nexports.ConnectionStreamIdBlockedFrame = ConnectionStreamIdBlockedFrame;\nclass StreamCloseFrame extends BaseFrame {\n    constructor(streamId, errorCode, errorMessage) {\n        super(\'StreamClose\');\n        this.streamId = long_1.longFromValue(streamId, true);\n        this.errorCode = errorCode;\n        this.errorMessage = errorMessage;\n    }\n    static fromContents(reader) {\n        const streamId = reader.readVarUIntLong();\n        const errorCode = reader.readUInt8Number();\n        const errorMessage = reader.readVarOctetString().toString(\'utf8\');\n        return new StreamCloseFrame(streamId, errorCode, errorMessage);\n    }\n}\nexports.StreamCloseFrame = StreamCloseFrame;\nclass StreamMoneyFrame extends BaseFrame {\n    constructor(streamId, shares) {\n        super(\'StreamMoney\');\n        this.streamId = long_1.longFromValue(streamId, true);\n        this.shares = long_1.longFromValue(shares, true);\n    }\n    static fromContents(reader) {\n        const streamId = reader.readVarUIntLong();\n        const amount = reader.readVarUIntLong();\n        return new StreamMoneyFrame(streamId, amount);\n    }\n}\nexports.StreamMoneyFrame = StreamMoneyFrame;\nclass StreamMaxMoneyFrame extends BaseFrame {\n    constructor(streamId, receiveMax, totalReceived) {\n        super(\'StreamMaxMoney\');\n        if (typeof receiveMax === \'number\' && !isFinite(receiveMax)) {\n            receiveMax = Long.MAX_UNSIGNED_VALUE;\n        }\n        this.streamId = long_1.longFromValue(streamId, true);\n        this.receiveMax = long_1.longFromValue(receiveMax, true);\n        this.totalReceived = long_1.longFromValue(totalReceived, true);\n    }\n    static fromContents(reader) {\n        const streamId = reader.readVarUIntLong();\n        const receiveMax = saturatingReadVarUInt(reader);\n        const totalReceived = reader.readVarUIntLong();\n        return new StreamMaxMoneyFrame(streamId, receiveMax, totalReceived);\n    }\n}\nexports.StreamMaxMoneyFrame = StreamMaxMoneyFrame;\nclass StreamMoneyBlockedFrame extends BaseFrame {\n    constructor(streamId, sendMax, totalSent) {\n        super(\'StreamMoneyBlocked\');\n        this.streamId = long_1.longFromValue(streamId, true);\n        this.sendMax = long_1.longFromValue(sendMax, true);\n        this.totalSent = long_1.longFromValue(totalSent, true);\n    }\n    static fromContents(reader) {\n        const streamId = reader.readVarUIntLong();\n        const sendMax = saturatingReadVarUInt(reader);\n        const totalSent = reader.readVarUIntLong();\n        return new StreamMoneyBlockedFrame(streamId, sendMax, totalSent);\n    }\n}\nexports.StreamMoneyBlockedFrame = StreamMoneyBlockedFrame;\nclass StreamDataFrame extends BaseFrame {\n    constructor(streamId, offset, data) {\n        super(\'StreamData\');\n        this.streamId = long_1.longFromValue(streamId, true);\n        this.offset = long_1.longFromValue(offset, true);\n        this.data = data;\n    }\n    static fromContents(reader) {\n        const streamId = reader.readVarUIntLong();\n        const offset = reader.readVarUIntLong();\n        const data = reader.readVarOctetString();\n        return new StreamDataFrame(streamId, offset, data);\n    }\n    toJSON() {\n        return {\n            type: this.type,\n            name: this.name,\n            streamId: this.streamId,\n            offset: this.offset,\n            dataLength: this.data.length\n        };\n    }\n}\nexports.StreamDataFrame = StreamDataFrame;\nclass StreamMaxDataFrame extends BaseFrame {\n    constructor(streamId, maxOffset) {\n        super(\'StreamMaxData\');\n        this.streamId = long_1.longFromValue(streamId, true);\n        this.maxOffset = long_1.longFromValue(maxOffset, true);\n    }\n    static fromContents(reader) {\n        const streamId = reader.readVarUIntLong();\n        const maxOffset = reader.readVarUIntLong();\n        return new StreamMaxDataFrame(streamId, maxOffset);\n    }\n}\nexports.StreamMaxDataFrame = StreamMaxDataFrame;\nclass StreamDataBlockedFrame extends BaseFrame {\n    constructor(streamId, maxOffset) {\n        super(\'StreamDataBlocked\');\n        this.streamId = long_1.longFromValue(streamId, true);\n        this.maxOffset = long_1.longFromValue(maxOffset, true);\n    }\n    static fromContents(reader) {\n        const streamId = reader.readVarUIntLong();\n        const maxOffset = reader.readVarUIntLong();\n        return new StreamDataBlockedFrame(streamId, maxOffset);\n    }\n}\nexports.StreamDataBlockedFrame = StreamDataBlockedFrame;\nfunction parseFrame(reader) {\n    const type = reader.readUInt8Number();\n    const contents = oer_utils_1.Reader.from(reader.readVarOctetString());\n    switch (type) {\n        case FrameType.ConnectionClose:\n            return ConnectionCloseFrame.fromContents(contents);\n        case FrameType.ConnectionNewAddress:\n            return ConnectionNewAddressFrame.fromContents(contents);\n        case FrameType.ConnectionAssetDetails:\n            return ConnectionAssetDetailsFrame.fromContents(contents);\n        case FrameType.ConnectionMaxData:\n            return ConnectionMaxDataFrame.fromContents(contents);\n        case FrameType.ConnectionDataBlocked:\n            return ConnectionDataBlockedFrame.fromContents(contents);\n        case FrameType.ConnectionMaxStreamId:\n            return ConnectionMaxStreamIdFrame.fromContents(contents);\n        case FrameType.ConnectionStreamIdBlocked:\n            return ConnectionStreamIdBlockedFrame.fromContents(contents);\n        case FrameType.StreamClose:\n            return StreamCloseFrame.fromContents(contents);\n        case FrameType.StreamMoney:\n            return StreamMoneyFrame.fromContents(contents);\n        case FrameType.StreamMaxMoney:\n            return StreamMaxMoneyFrame.fromContents(contents);\n        case FrameType.StreamMoneyBlocked:\n            return StreamMoneyBlockedFrame.fromContents(contents);\n        case FrameType.StreamData:\n            return StreamDataFrame.fromContents(contents);\n        case FrameType.StreamMaxData:\n            return StreamMaxDataFrame.fromContents(contents);\n        case FrameType.StreamDataBlocked:\n            return StreamDataBlockedFrame.fromContents(contents);\n        default:\n            return undefined;\n    }\n}\nfunction saturatingReadVarUInt(reader) {\n    if (reader.peekVarOctetString().length > 8) {\n        reader.skipVarOctetString();\n        return Long.MAX_UNSIGNED_VALUE;\n    }\n    else {\n        return reader.readVarUIntLong();\n    }\n}\n//# sourceMappingURL=packet.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "../../node_modules/buffer/index.js").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/packet.js?'
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-stream/dist/src/stream.js':
        /*!*************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/stream.js ***!
  \*************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(setImmediate, process) {\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ilp_logger_1 = __webpack_require__(/*! ilp-logger */ \"../../node_modules/ilp-logger/build/index.js\");\nconst Long = __webpack_require__(/*! long */ \"../../node_modules/long/src/long.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"../../node_modules/stream-browserify/index.js\");\nconst data_queue_1 = __webpack_require__(/*! ./util/data-queue */ \"../../node_modules/ilp-protocol-stream/dist/src/util/data-queue.js\");\nconst data_offset_sorter_1 = __webpack_require__(/*! ./util/data-offset-sorter */ \"../../node_modules/ilp-protocol-stream/dist/src/util/data-offset-sorter.js\");\nconst long_1 = __webpack_require__(/*! ./util/long */ \"../../node_modules/ilp-protocol-stream/dist/src/util/long.js\");\nconst DEFAULT_TIMEOUT = 60000;\nconst MAX_REMOTE_RECEIVE = Long.MAX_UNSIGNED_VALUE;\nclass DataAndMoneyStream extends stream_1.Duplex {\n    constructor(opts) {\n        super({ allowHalfOpen: false });\n        this.id = opts.id;\n        this.isServer = opts.isServer;\n        this.log = ilp_logger_1.default(`ilp-protocol-stream:${this.isServer ? 'Server' : 'Client'}:Stream:${this.id}`);\n        this.log.info('new stream created');\n        this._totalSent = Long.UZERO;\n        this._totalReceived = Long.UZERO;\n        this._sendMax = Long.UZERO;\n        this._receiveMax = Long.UZERO;\n        this._outgoingHeldAmount = Long.UZERO;\n        this._sentEnd = false;\n        this._remoteSentEnd = false;\n        this.closed = false;\n        this.holds = {};\n        this._incomingData = new data_offset_sorter_1.OffsetSorter();\n        this._outgoingData = new data_queue_1.DataQueue();\n        this._outgoingDataToRetry = [];\n        this.outgoingOffset = 0;\n        this._remoteClosed = false;\n        this._remoteReceived = Long.UZERO;\n        this._remoteReceiveMax = MAX_REMOTE_RECEIVE;\n        this._remoteMaxOffset = 16384;\n        this.emittedEnd = false;\n        this.emittedClose = false;\n        this.once('end', () => {\n            this.emittedEnd = true;\n        });\n        this.once('close', () => {\n            this.emittedClose = true;\n        });\n    }\n    get totalSent() {\n        return this._totalSent.toString();\n    }\n    get totalReceived() {\n        return this._totalReceived.toString();\n    }\n    get sendMax() {\n        return this._sendMax.toString();\n    }\n    get receiveMax() {\n        return this._receiveMax.toString();\n    }\n    get readableLength() {\n        const readableLength = super.readableLength || (this['_readableState'] && this['_readableState'].length) || 0;\n        return readableLength + this._incomingData.byteLength();\n    }\n    get writableLength() {\n        const writableLength = super.writableLength || (this['_writableState'] && this['_writableState'].length) || 0;\n        return writableLength;\n    }\n    get readableHighWaterMark() {\n        if (typeof super.readableHighWaterMark === 'number') {\n            return super.readableHighWaterMark;\n        }\n        else {\n            return this['_readableState'].highWaterMark;\n        }\n    }\n    get writableHighWaterMark() {\n        if (typeof super.writableHighWaterMark === 'number') {\n            return super.writableHighWaterMark;\n        }\n        else {\n            return this['_writableState'].highWaterMark;\n        }\n    }\n    isOpen() {\n        return !this.closed;\n    }\n    setSendMax(limit) {\n        if (this.closed) {\n            throw new Error('Stream already closed');\n        }\n        else if (typeof limit === 'number' && !isFinite(limit)) {\n            throw new Error('sendMax must be finite');\n        }\n        const sendMax = long_1.longFromValue(limit, true);\n        if (this._totalSent.greaterThan(sendMax)) {\n            this.log.debug('cannot set sendMax to %s because we have already sent: %s', sendMax, this._totalSent);\n            throw new Error(`Cannot set sendMax lower than the totalSent`);\n        }\n        this.log.debug('setting sendMax to %s', sendMax);\n        this._sendMax = sendMax;\n        this.emit('_maybe_start_send_loop');\n    }\n    setReceiveMax(limit) {\n        if (this.closed) {\n            throw new Error('Stream already closed');\n        }\n        const receiveMax = long_1.longFromValue(limit, true);\n        if (this._totalReceived.greaterThan(receiveMax)) {\n            this.log.debug('cannot set receiveMax to %s because we have already received: %s', receiveMax, this._totalReceived);\n            throw new Error('Cannot set receiveMax lower than the totalReceived');\n        }\n        if (this._receiveMax.greaterThan(receiveMax)) {\n            this.log.debug('cannot set receiveMax to %s because the current limit is: %s', receiveMax, this._receiveMax);\n            throw new Error('Cannot decrease the receiveMax');\n        }\n        this.log.debug('setting receiveMax to %s', receiveMax);\n        this._receiveMax = receiveMax;\n        this.emit('_maybe_start_send_loop');\n    }\n    sendTotal(_limit, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const limit = long_1.longFromValue(_limit, true);\n            const timeout = (opts && opts.timeout) || DEFAULT_TIMEOUT;\n            if (this._totalSent.greaterThanOrEqual(limit)) {\n                this.log.debug('already sent %s, not sending any more', this._totalSent);\n                return Promise.resolve();\n            }\n            this.setSendMax(limit);\n            yield new Promise((resolve, reject) => {\n                const self = this;\n                function outgoingHandler() {\n                    if (self._totalSent.greaterThanOrEqual(limit)) {\n                        cleanup();\n                        resolve();\n                    }\n                }\n                function endHandler() {\n                    setImmediate(cleanup);\n                    if ((self._totalSent.greaterThanOrEqual(limit))) {\n                        resolve();\n                    }\n                    else {\n                        self.log.debug('Stream was closed before the desired amount was sent (target: %s, totalSent: %s)', limit, self._totalSent);\n                        reject(new Error(`Stream was closed before the desired amount was sent (target: ${limit}, totalSent: ${self._totalSent})`));\n                    }\n                }\n                function errorHandler(err) {\n                    self.log.debug('error waiting for stream to stabilize:', err);\n                    cleanup();\n                    reject(new Error(`Stream encountered an error before the desired amount was sent (target: ${limit}, totalSent: ${self._totalSent}): ${err}`));\n                }\n                const timer = setTimeout(() => {\n                    cleanup();\n                    reject(new Error(`Timed out before the desired amount was sent (target: ${limit}, totalSent: ${self._totalSent})`));\n                }, timeout);\n                function cleanup() {\n                    clearTimeout(timer);\n                    self.removeListener('outgoing_money', outgoingHandler);\n                    self.removeListener('error', errorHandler);\n                    self.removeListener('end', endHandler);\n                }\n                this.on('outgoing_money', outgoingHandler);\n                this.on('error', errorHandler);\n                this.on('end', endHandler);\n            });\n        });\n    }\n    receiveTotal(_limit, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const limit = long_1.longFromValue(_limit, true);\n            const timeout = (opts && opts.timeout) || DEFAULT_TIMEOUT;\n            if (this._totalReceived.greaterThanOrEqual(limit)) {\n                this.log.debug('already received %s, not waiting for more', this._totalReceived);\n                return Promise.resolve();\n            }\n            this.setReceiveMax(limit);\n            yield new Promise((resolve, reject) => {\n                const self = this;\n                function moneyHandler() {\n                    if (self._totalReceived.greaterThanOrEqual(limit)) {\n                        cleanup();\n                        resolve();\n                    }\n                }\n                function endHandler() {\n                    setImmediate(cleanup);\n                    if (self._totalReceived.greaterThanOrEqual(limit)) {\n                        resolve();\n                    }\n                    else {\n                        self.log.debug('Stream was closed before the desired amount was received (target: %s, totalReceived: %s)', limit, self._totalReceived);\n                        reject(new Error(`Stream was closed before the desired amount was received (target: ${limit}, totalReceived: ${self._totalReceived})`));\n                    }\n                }\n                function errorHandler(err) {\n                    self.log.debug('error waiting for stream to stabilize:', err);\n                    cleanup();\n                    reject(new Error(`Stream encountered an error before the desired amount was received (target: ${limit}, totalReceived: ${self._totalReceived}): ${err}`));\n                }\n                const timer = setTimeout(() => {\n                    cleanup();\n                    reject(new Error(`Timed out before the desired amount was received (target: ${limit}, totalReceived: ${self._totalReceived})`));\n                }, timeout);\n                function cleanup() {\n                    clearTimeout(timer);\n                    self.removeListener('money', moneyHandler);\n                    self.removeListener('error', errorHandler);\n                    self.removeListener('end', endHandler);\n                }\n                this.on('money', moneyHandler);\n                this.on('error', errorHandler);\n                this.on('end', endHandler);\n            });\n        });\n    }\n    _getAmountStreamCanReceive() {\n        if (this._receiveMax.lessThan(this._totalReceived)) {\n            return Long.UZERO;\n        }\n        return long_1.checkedSubtract(this._receiveMax, this._totalReceived).difference;\n    }\n    _addToIncoming(amount) {\n        this._totalReceived = long_1.checkedAdd(this._totalReceived, amount).sum;\n        this.log.trace('received %s (totalReceived: %s)', amount, this._totalReceived);\n        this.emit('money', amount.toString());\n    }\n    _getAmountAvailableToSend() {\n        if (this.closed) {\n            return Long.UZERO;\n        }\n        const amountAvailable = long_1.checkedSubtract(long_1.checkedSubtract(this._sendMax, this._totalSent).difference, this._outgoingHeldAmount).difference;\n        return amountAvailable;\n    }\n    _holdOutgoing(holdId, maxAmount) {\n        const amountAvailable = this._getAmountAvailableToSend();\n        const amountToHold = (maxAmount ? long_1.minLong(amountAvailable, maxAmount) : amountAvailable);\n        if (amountToHold.greaterThan(0)) {\n            this._outgoingHeldAmount = this._outgoingHeldAmount.add(amountToHold);\n            this.holds[holdId] = amountToHold;\n            this.log.trace('holding outgoing balance. holdId: %s, amount: %s', holdId, amountToHold);\n        }\n        return amountToHold;\n    }\n    _executeHold(holdId) {\n        if (!this.holds[holdId]) {\n            return;\n        }\n        const amount = this.holds[holdId];\n        this._outgoingHeldAmount = this._outgoingHeldAmount.subtract(amount);\n        this._totalSent = this._totalSent.add(amount);\n        delete this.holds[holdId];\n        this.log.trace('executed holdId: %s for: %s', holdId, amount);\n        this.emit('outgoing_money', amount.toString());\n        if (this._totalSent.greaterThanOrEqual(this._sendMax)) {\n            this.log.debug('outgoing total sent');\n            this.emit('outgoing_total_sent');\n        }\n    }\n    _cancelHold(holdId) {\n        if (!this.holds[holdId]) {\n            return;\n        }\n        const amount = this.holds[holdId];\n        this.log.trace('cancelled holdId: %s for: %s', holdId, amount);\n        this._outgoingHeldAmount = this._outgoingHeldAmount.subtract(amount);\n        delete this.holds[holdId];\n    }\n    _final(callback) {\n        this.log.info('stream is closing');\n        const finish = (err) => {\n            if (err) {\n                this.log.debug('error waiting for money to be sent:', err);\n            }\n            this.log.info('stream ended');\n            this.closed = true;\n            setImmediate(() => {\n                if (!this.emittedEnd) {\n                    this.emittedEnd = true;\n                    this.safeEmit('end');\n                }\n                if (!this.emittedClose) {\n                    this.emittedClose = true;\n                    this.safeEmit('close');\n                }\n            });\n            callback(err);\n        };\n        if (this._remoteSentEnd || this._sendMax.lessThanOrEqual(this._totalSent)) {\n            finish();\n        }\n        else {\n            this.log.info('waiting to finish sending money before ending stream');\n            new Promise((resolve, reject) => {\n                this.once('outgoing_total_sent', resolve);\n                this.once('_send_loop_finished', resolve);\n                this.once('error', (error) => reject(error));\n            })\n                .then(() => finish())\n                .catch(finish);\n        }\n    }\n    _destroy(error, callback) {\n        this.log.error('destroying stream because of error:', error);\n        this.closed = true;\n        if (error) {\n            this._errorMessage = error.message;\n        }\n        setImmediate(() => {\n            if (!this.emittedEnd) {\n                this.emittedEnd = true;\n                this.safeEmit('end');\n            }\n            if (!this.emittedClose) {\n                this.emittedClose = true;\n                this.safeEmit('close');\n            }\n        });\n        callback(error);\n    }\n    _write(chunk, encoding, callback) {\n        this.log.trace('%d bytes written to the outgoing data queue', chunk.length);\n        this._outgoingData.push(chunk, callback);\n        this.emit('_maybe_start_send_loop');\n    }\n    _writev(chunks, callback) {\n        for (let i = 0; i < chunks.length; i++) {\n            const chunk = chunks[i];\n            this.log.trace('%d bytes written to the outgoing data queue', chunk.chunk.length);\n            if (i === chunks.length - 1) {\n                this._outgoingData.push(chunk.chunk, callback);\n            }\n            else {\n                this._outgoingData.push(chunk.chunk);\n            }\n        }\n        this.emit('_maybe_start_send_loop');\n    }\n    _read(size) {\n        const data = this._incomingData.read();\n        if (!data) {\n            if (this['readableFlowing'] !== true) {\n                process.nextTick(() => this.emit('_maybe_start_send_loop'));\n            }\n            return;\n        }\n        this.push(data);\n        if (data.length < size) {\n            this._read(size - data.length);\n        }\n    }\n    _hasDataToSend() {\n        return !this._outgoingData.isEmpty() || this._outgoingDataToRetry.length > 0;\n    }\n    _getAvailableDataToSend(size) {\n        if (this._outgoingDataToRetry.length > 0) {\n            const toSend = this._outgoingDataToRetry[0];\n            if (toSend.data.length > size) {\n                const data = toSend.data.slice(0, size);\n                const offset = toSend.offset;\n                toSend.data = toSend.data.slice(size);\n                toSend.offset = toSend.offset + size;\n                return { data, offset };\n            }\n            else {\n                return this._outgoingDataToRetry.shift();\n            }\n        }\n        const maxBytes = Math.min(size, this._remoteMaxOffset - this.outgoingOffset);\n        const offset = this.outgoingOffset;\n        const data = this._outgoingData.read(maxBytes);\n        if (data && data.length > 0) {\n            this.outgoingOffset += data.length;\n            this.log.trace('%d bytes taken from the outgoing data queue', data.length);\n        }\n        return { data, offset };\n    }\n    _resendOutgoingData(data, offset) {\n        this.log.trace('re-queuing %d bytes of data starting at offset %d', data.length, offset);\n        this._outgoingDataToRetry.push({ data, offset });\n    }\n    _isDataBlocked() {\n        if (this._remoteMaxOffset < this.outgoingOffset + this._outgoingData.byteLength()) {\n            return this.outgoingOffset + this._outgoingData.byteLength();\n        }\n    }\n    _getOutgoingOffsets() {\n        return {\n            current: this.outgoingOffset,\n            max: this.outgoingOffset + this._outgoingData.byteLength()\n        };\n    }\n    _getIncomingOffsets() {\n        return {\n            max: this._incomingData.maxOffset,\n            current: this._incomingData.readOffset,\n            maxAcceptable: this._incomingData.readOffset + this.readableHighWaterMark - this.readableLength\n        };\n    }\n    _pushIncomingData(data, offset) {\n        this._incomingData.push(data, offset);\n        this._read(this.readableHighWaterMark - this.readableLength);\n    }\n    _remoteEnded(err) {\n        this.log.info('remote closed stream');\n        this._remoteSentEnd = true;\n        this._remoteClosed = true;\n        if (err) {\n            this.destroy(err);\n        }\n        else {\n            this.push(null);\n            this.end();\n        }\n    }\n    safeEmit(event, ...args) {\n        try {\n            args.unshift(event);\n            this.emit.apply(this, args);\n        }\n        catch (err) {\n            this.log.debug('error in %s handler: %s', event, err);\n        }\n    }\n}\nexports.DataAndMoneyStream = DataAndMoneyStream;\n//# sourceMappingURL=stream.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../timers-browserify/main.js */ \"../../node_modules/timers-browserify/main.js\").setImmediate, __webpack_require__(/*! ./../../../process/browser.js */ \"../../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/stream.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-stream/dist/src/util/congestion.js':
        /*!**********************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/util/congestion.js ***!
  \**********************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nObject.defineProperty(exports, "__esModule", { value: true });\nconst Long = __webpack_require__(/*! long */ "../../node_modules/long/src/long.js");\nconst ilp_logger_1 = __webpack_require__(/*! ilp-logger */ "../../node_modules/ilp-logger/build/index.js");\nconst oer_utils_1 = __webpack_require__(/*! oer-utils */ "../../node_modules/oer-utils/dist/src/index.js");\nconst long_1 = __webpack_require__(/*! ./long */ "../../node_modules/ilp-protocol-stream/dist/src/util/long.js");\nconst log = ilp_logger_1.default(\'ilp-protocol-stream:Congestion\');\nclass CongestionController {\n    constructor(opts) {\n        this._testMaximumPacketAmount = Long.MAX_UNSIGNED_VALUE;\n        this._maximumPacketAmount = Long.MAX_UNSIGNED_VALUE;\n        this._fixedPacketAmount = opts.maximumPacketAmount || Long.MAX_UNSIGNED_VALUE;\n    }\n    get testMaximumPacketAmount() {\n        return this._testMaximumPacketAmount;\n    }\n    get maximumPacketAmount() {\n        return long_1.minLong(this._maximumPacketAmount, this._fixedPacketAmount);\n    }\n    setMaximumAmounts(amount) {\n        this._testMaximumPacketAmount = amount;\n        this._maximumPacketAmount = amount;\n    }\n    onFulfill(amountSent) {\n        const maximumPacketAmount = this.maximumPacketAmount;\n        const shouldRaiseLimit = amountSent.equals(this._testMaximumPacketAmount)\n            && this._testMaximumPacketAmount.lessThan(maximumPacketAmount);\n        if (!shouldRaiseLimit)\n            return;\n        let newTestMax;\n        const isMaxPacketAmountKnown = maximumPacketAmount.notEquals(Long.MAX_UNSIGNED_VALUE);\n        if (isMaxPacketAmountKnown) {\n            const additiveIncrease = maximumPacketAmount.divide(10);\n            newTestMax = long_1.minLong(long_1.checkedAdd(this._testMaximumPacketAmount, additiveIncrease).sum, maximumPacketAmount);\n            log.trace(\'last packet amount was successful (max packet amount: %s), raising packet amount from %s to: %s\', maximumPacketAmount, this._testMaximumPacketAmount, newTestMax);\n        }\n        else {\n            newTestMax = long_1.checkedMultiply(this._testMaximumPacketAmount, Long.fromNumber(2, true)).product;\n            log.trace(\'last packet amount was successful, unknown max packet amount, raising packet amount from: %s to: %s\', this._testMaximumPacketAmount, newTestMax);\n        }\n        this._testMaximumPacketAmount = newTestMax;\n    }\n    onAmountTooLargeError(reject, amountSent) {\n        let receivedAmount;\n        let maximumAmount;\n        try {\n            const reader = oer_utils_1.Reader.from(reject.data);\n            receivedAmount = reader.readUInt64Long();\n            maximumAmount = reader.readUInt64Long();\n        }\n        catch (err) {\n            receivedAmount = undefined;\n            maximumAmount = undefined;\n        }\n        if (receivedAmount && maximumAmount && receivedAmount.greaterThan(maximumAmount)) {\n            const newMaximum = long_1.multiplyDivideFloor(amountSent, maximumAmount, receivedAmount);\n            log.trace(\'reducing maximum packet amount from %s to %s\', this._maximumPacketAmount, newMaximum);\n            this._maximumPacketAmount = newMaximum;\n            this._testMaximumPacketAmount = newMaximum;\n        }\n        else {\n            this._maximumPacketAmount = amountSent.subtract(1);\n            this._testMaximumPacketAmount = this.maximumPacketAmount.divide(2);\n        }\n        return this.maximumPacketAmount;\n    }\n    onInsufficientLiquidityError(reject, amountSent) {\n        const minPacketAmount = long_1.minLong(amountSent, this._testMaximumPacketAmount);\n        const newTestAmount = minPacketAmount.subtract(minPacketAmount.divide(3));\n        this._testMaximumPacketAmount = long_1.maxLong(Long.fromNumber(2, true), newTestAmount);\n        log.warn(\'got T04: Insufficient Liquidity error triggered by: %s reducing the packet amount to %s\', reject.triggeredBy, this._testMaximumPacketAmount);\n    }\n}\nexports.CongestionController = CongestionController;\n//# sourceMappingURL=congestion.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/util/congestion.js?'
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-stream/dist/src/util/crypto-browser.js':
        /*!**************************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/util/crypto-browser.js ***!
  \**************************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst { crypto } = window;\nconst HASH_ALGORITHM = 'SHA-256';\nconst ENCRYPTION_ALGORITHM = 'AES-GCM';\nconst IV_LENGTH = 12;\nconst AUTH_TAG_BYTES = 16;\nconst AUTH_TAG_BITS = 8 * AUTH_TAG_BYTES;\nconst CACHE_EXPIRY = 30000;\nclass KeyCache {\n    constructor() {\n        this.cache = new Map();\n    }\n    cleanup() {\n        const now = Date.now();\n        for (const [cacheData, cacheEntry] of this.cache) {\n            if (now - cacheEntry.accessTime > CACHE_EXPIRY) {\n                this.cache.delete(cacheData);\n            }\n        }\n    }\n    importKey(keyData, algorithm, keyUsages) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const oldEntry = this.cache.get(keyData);\n            if (oldEntry) {\n                oldEntry.accessTime = Date.now();\n                return oldEntry.keyObject;\n            }\n            const keyObject = yield crypto.subtle.importKey('raw', keyData, algorithm, false, keyUsages);\n            this.cache.set(keyData, {\n                keyObject,\n                accessTime: Date.now()\n            });\n            return keyObject;\n        });\n    }\n}\nconst hmacKeyCache = new KeyCache();\nconst aesKeyCache = new KeyCache();\nsetInterval(() => {\n    hmacKeyCache.cleanup();\n    aesKeyCache.cleanup();\n}, 30000);\nfunction hash(preimage) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const digest = yield crypto.subtle.digest({ name: HASH_ALGORITHM }, preimage);\n        return Buffer.from(digest);\n    });\n}\nexports.hash = hash;\nfunction encrypt(pskEncryptionKey, ...buffers) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const iv = randomBytes(IV_LENGTH);\n        const key = yield aesKeyCache.importKey(pskEncryptionKey, ENCRYPTION_ALGORITHM, ['encrypt', 'decrypt']);\n        const ciphertext = yield crypto.subtle.encrypt({\n            name: ENCRYPTION_ALGORITHM,\n            iv,\n            tagLength: AUTH_TAG_BITS\n        }, key, Buffer.concat(buffers));\n        const tagStart = ciphertext.byteLength - AUTH_TAG_BYTES;\n        const tag = ciphertext.slice(tagStart);\n        const data = ciphertext.slice(0, tagStart);\n        return Buffer.concat([\n            Buffer.from(iv),\n            Buffer.from(tag),\n            Buffer.from(data)\n        ]);\n    });\n}\nexports.encrypt = encrypt;\nfunction decrypt(pskEncryptionKey, data) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const nonce = data.slice(0, IV_LENGTH);\n        const tag = data.slice(IV_LENGTH, IV_LENGTH + AUTH_TAG_BYTES);\n        const cipherdata = data.slice(IV_LENGTH + AUTH_TAG_BYTES);\n        const key = yield aesKeyCache.importKey(pskEncryptionKey, ENCRYPTION_ALGORITHM, ['encrypt', 'decrypt']);\n        const decryptedData = yield crypto.subtle.decrypt({\n            name: ENCRYPTION_ALGORITHM,\n            iv: nonce\n        }, key, Buffer.concat([cipherdata, tag]));\n        return Buffer.from(decryptedData);\n    });\n}\nexports.decrypt = decrypt;\nconst HMAC_ALGORITHM = {\n    name: 'HMAC',\n    hash: { name: HASH_ALGORITHM }\n};\nfunction hmac(key, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const hmacKey = yield hmacKeyCache.importKey(key, HMAC_ALGORITHM, ['sign', 'verify']);\n        const signature = yield crypto.subtle.sign('HMAC', hmacKey, message);\n        return Buffer.from(signature);\n    });\n}\nexports.hmac = hmac;\nfunction randomBytes(size) {\n    const randArray = new Uint8Array(size);\n    const randValues = crypto.getRandomValues(randArray);\n    return Buffer.from(randValues);\n}\nexports.randomBytes = randomBytes;\nfunction generateSharedSecretFromToken(seed, token) {\n    throw new Error('unreachable in browser');\n}\nexports.generateSharedSecretFromToken = generateSharedSecretFromToken;\n//# sourceMappingURL=crypto-browser.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../buffer/index.js */ \"../../node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/util/crypto-browser.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-stream/dist/src/util/data-offset-sorter.js':
        /*!******************************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/util/data-offset-sorter.js ***!
  \******************************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nObject.defineProperty(exports, "__esModule", { value: true });\nclass OffsetDataEntry {\n    constructor(data, offset, next) {\n        this.data = data;\n        this.offset = offset;\n        this.next = next;\n    }\n}\nclass OffsetSorter {\n    constructor() {\n        this.readOffset = 0;\n        this.maxOffset = 0;\n    }\n    push(data, offset) {\n        const entry = new OffsetDataEntry(data, offset);\n        this.maxOffset = Math.max(offset + data.length, this.maxOffset);\n        if (!this.head) {\n            this.head = entry;\n        }\n        else if (this.head.offset > offset) {\n            entry.next = this.head;\n            this.head = entry;\n        }\n        else {\n            let prev = this.head;\n            while (true) {\n                if (!prev.next) {\n                    prev.next = entry;\n                    break;\n                }\n                if (prev.next.offset > offset) {\n                    entry.next = prev.next;\n                    prev.next = entry;\n                    break;\n                }\n                prev = prev.next;\n            }\n        }\n    }\n    read() {\n        let data;\n        if (this.head && this.readOffset === this.head.offset) {\n            data = this.head.data;\n            this.readOffset = this.head.offset + (data ? data.length : 0);\n            this.head = this.head.next;\n        }\n        return data;\n    }\n    byteLength() {\n        let length = 0;\n        let entry = this.head;\n        let offset = this.readOffset;\n        while (entry && entry.offset === offset) {\n            length += entry.data.length;\n            offset += entry.data.length;\n            entry = entry.next;\n        }\n        return length;\n    }\n}\nexports.OffsetSorter = OffsetSorter;\n//# sourceMappingURL=data-offset-sorter.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/util/data-offset-sorter.js?'
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-stream/dist/src/util/data-queue.js':
        /*!**********************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/util/data-queue.js ***!
  \**********************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, "__esModule", { value: true });\nclass DataQueueEntry {\n    constructor(buf, callback, entry) {\n        this.data = buf;\n        this.callback = callback;\n        this.next = entry;\n    }\n}\nclass DataQueue {\n    constructor() {\n        this.length = 0;\n    }\n    push(buf, callback) {\n        const entry = new DataQueueEntry(buf, callback);\n        if (this.tail) {\n            this.tail.next = entry;\n        }\n        else {\n            this.head = entry;\n        }\n        this.tail = entry;\n        this.length += 1;\n    }\n    shift() {\n        if (!this.head) {\n            return null;\n        }\n        const ret = this.head.data;\n        if (this.length === 1) {\n            this.head = this.tail = undefined;\n        }\n        else {\n            this.head = this.head.next;\n        }\n        this.length -= 1;\n        return ret;\n    }\n    read(n) {\n        if (!this.head) {\n            return undefined;\n        }\n        let bytesLeft = n;\n        const chunks = [];\n        while (bytesLeft > 0 && this.length > 0) {\n            let chunk = this.head.data;\n            if (chunk.length > bytesLeft) {\n                this.head.data = chunk.slice(bytesLeft);\n                chunk = chunk.slice(0, bytesLeft);\n                chunks.push(chunk);\n                bytesLeft -= chunk.length;\n            }\n            else {\n                chunks.push(chunk);\n                bytesLeft -= chunk.length;\n                if (this.head && this.head.callback) {\n                    this.head.callback();\n                }\n                this.shift();\n            }\n        }\n        return Buffer.concat(chunks);\n    }\n    isEmpty() {\n        return this.length === 0;\n    }\n    byteLength() {\n        let length = 0;\n        let entry = this.head;\n        while (entry) {\n            length += entry.data.length;\n            entry = entry.next;\n        }\n        return length;\n    }\n}\nexports.DataQueue = DataQueue;\n//# sourceMappingURL=data-queue.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../buffer/index.js */ "../../node_modules/buffer/index.js").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/util/data-queue.js?'
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-stream/dist/src/util/formatters.js':
        /*!**********************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/util/formatters.js ***!
  \**********************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nObject.defineProperty(exports, "__esModule", { value: true });\nconst ilp_logger_1 = __webpack_require__(/*! ilp-logger */ "../../node_modules/ilp-logger/build/index.js");\nilp_logger_1.formatters.h = (v) => v.toString(\'hex\');\n//# sourceMappingURL=formatters.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/util/formatters.js?'
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-stream/dist/src/util/long.js':
        /*!****************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/util/long.js ***!
  \****************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Long = __webpack_require__(/*! long */ \"../../node_modules/long/src/long.js\");\nfunction longFromValue(value, unsigned) {\n    if (typeof value === 'number') {\n        if (unsigned && value < 0) {\n            throw new Error('Expected positive number');\n        }\n        return Long.fromNumber(value, unsigned);\n    }\n    if (typeof value === 'string') {\n        if (unsigned && value[0] === '-') {\n            throw new Error('Expected positive number');\n        }\n        const longValue = Long.fromString(value, unsigned);\n        if (longValue.toString() !== value) {\n            throw new Error('Value ' + value + ' does not fit in a Long.');\n        }\n        return longValue;\n    }\n    if (value.unsigned !== unsigned) {\n        throw new Error('Expected ' + (unsigned ? 'unsigned' : 'signed') + ' Long');\n    }\n    return value;\n}\nexports.longFromValue = longFromValue;\nfunction maxLong(a, b) {\n    return a.greaterThan(b) ? a : b;\n}\nexports.maxLong = maxLong;\nfunction minLong(a, b) {\n    return a.lessThan(b) ? a : b;\n}\nexports.minLong = minLong;\nfunction minLongs(values) {\n    let min = values[0];\n    for (let i = 1; i < values.length; i++) {\n        min = minLong(min, values[i]);\n    }\n    return min;\n}\nexports.minLongs = minLongs;\nfunction countDigits(value) {\n    let digits = 0;\n    while (!value.isZero()) {\n        digits++;\n        value = value.divide(10);\n    }\n    return digits;\n}\nexports.countDigits = countDigits;\nfunction checkedAdd(a, b) {\n    const sum = a.add(b);\n    const overflow = sum.lessThan(a) || sum.lessThan(b);\n    return {\n        sum: overflow ? Long.MAX_UNSIGNED_VALUE : sum,\n        overflow\n    };\n}\nexports.checkedAdd = checkedAdd;\nfunction checkedSubtract(a, b) {\n    const difference = a.subtract(b);\n    const underflow = difference.greaterThan(a) && difference.greaterThan(b);\n    return {\n        difference: underflow ? Long.UZERO : difference,\n        underflow\n    };\n}\nexports.checkedSubtract = checkedSubtract;\nfunction checkedMultiply(a, b) {\n    const product = a.multiply(b);\n    const overflow = product.lessThan(a) || product.lessThan(b);\n    return {\n        product: overflow ? Long.MAX_UNSIGNED_VALUE : product,\n        overflow\n    };\n}\nexports.checkedMultiply = checkedMultiply;\nfunction multiplyDivideFloor(a, b, c) {\n    return multiplyDivide(a, b, c).quo;\n}\nexports.multiplyDivideFloor = multiplyDivideFloor;\nfunction multiplyDivideCeil(a, b, c) {\n    const { quo, rem } = multiplyDivide(a, b, c);\n    if (quo.equals(Long.MAX_UNSIGNED_VALUE))\n        return quo;\n    return quo.add(rem.isZero() ? 0 : 1);\n}\nexports.multiplyDivideCeil = multiplyDivideCeil;\nfunction multiplyDivideRound(a, b, c) {\n    const { quo, rem } = multiplyDivide(a, b, c);\n    if (quo.equals(Long.MAX_UNSIGNED_VALUE))\n        return quo;\n    const roundUp = !rem.isZero() && (c.isOdd()\n        ? rem.greaterThan(c.divide(2))\n        : rem.greaterThanOrEqual(c.divide(2)));\n    return roundUp ? quo.add(Long.UONE) : quo;\n}\nexports.multiplyDivideRound = multiplyDivideRound;\nfunction multiplyDivide(a, b, c) {\n    let quo = Long.UZERO;\n    let rem = Long.UZERO;\n    let qn = b.divide(c);\n    let rn = b.modulo(c);\n    while (!a.isZero()) {\n        let oldQuo = quo;\n        if (!a.and(Long.UONE).isZero()) {\n            quo = quo.add(qn);\n            rem = rem.add(rn);\n            if (rem.greaterThanOrEqual(c)) {\n                quo = quo.add(Long.UONE);\n                rem = rem.subtract(c);\n            }\n        }\n        if (quo.lessThan(oldQuo)) {\n            return { quo: Long.MAX_UNSIGNED_VALUE, rem: Long.UZERO };\n        }\n        a = a.shiftRightUnsigned(1);\n        qn = qn.shiftLeft(1);\n        rn = rn.shiftLeft(1);\n        if (rn.greaterThanOrEqual(c)) {\n            qn = qn.add(Long.UONE);\n            rn = rn.subtract(c);\n        }\n    }\n    return { quo, rem };\n}\nexports.multiplyDivide = multiplyDivide;\nLong.prototype['toJSON'] = function () {\n    return this.toString();\n};\n//# sourceMappingURL=long.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/util/long.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ilp-protocol-stream/dist/src/util/rational.js':
        /*!********************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/util/rational.js ***!
  \********************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = __webpack_require__(/*! assert */ \"../../node_modules/assert/assert.js\");\nconst Long = __webpack_require__(/*! long */ \"../../node_modules/long/src/long.js\");\nconst long_1 = __webpack_require__(/*! ./long */ \"../../node_modules/ilp-protocol-stream/dist/src/util/long.js\");\nclass Rational {\n    constructor(numer, denom, unsigned) {\n        if (!unsigned) {\n            throw new Error('signed rationals are not implemented');\n        }\n        assert.strictEqual(numer.unsigned, unsigned, 'numerator is incorrectly signed');\n        assert.strictEqual(denom.unsigned, unsigned, 'denominator is incorrectly signed');\n        assert(!denom.isZero(), 'denominator must be non-zero');\n        this.a = numer;\n        this.b = denom;\n        this.unsigned = unsigned;\n    }\n    static isRational(value) {\n        return value instanceof Rational;\n    }\n    static fromNumbers(numer, denom, unsigned) {\n        return new Rational(Long.fromNumber(numer, unsigned), Long.fromNumber(denom, unsigned), unsigned);\n    }\n    static fromNumber(value, unsigned) {\n        if (!isFinite(value)) {\n            throw new Error('value must be finite');\n        }\n        else if (unsigned && value < 0) {\n            throw new Error('unsigned value must be positive');\n        }\n        if (value % 1 === 0) {\n            return Rational.fromNumbers(value, 1, unsigned);\n        }\n        const mag = Math.floor(Math.log(value) / Math.LN10);\n        let shift = mag < 0 ? 18 : (18 - mag);\n        let den = 1;\n        while (Math.floor(value * den) !== value * den &&\n            shift > 0) {\n            den *= 10;\n            shift--;\n        }\n        return Rational.fromNumbers(value * den, den, unsigned);\n    }\n    multiplyByLong(value) {\n        return long_1.multiplyDivideFloor(value, this.a, this.b);\n    }\n    multiplyByLongCeil(value) {\n        return long_1.multiplyDivideCeil(value, this.a, this.b);\n    }\n    multiplyByRational(other) {\n        return new Rational(this.a.multiply(other.a), this.b.multiply(other.b), this.unsigned);\n    }\n    greaterThanOne() {\n        return this.a.greaterThan(this.b);\n    }\n    complement() {\n        if (this.a.greaterThan(this.b)) {\n            throw new Error('cannot take complement of rational >1');\n        }\n        return new Rational(this.b.subtract(this.a), this.b, this.unsigned);\n    }\n    reciprocal() {\n        return new Rational(this.b, this.a, this.unsigned);\n    }\n    toNumber() {\n        return this.a.toNumber() / this.b.toNumber();\n    }\n    toString() {\n        const str = trimRight(this.toFixed(19), '0');\n        return str[str.length - 1] === '.'\n            ? str.slice(0, -1)\n            : str;\n    }\n    toFixed(digits) {\n        digits = digits || 0;\n        const quotient = this.a.divide(this.b);\n        if (digits === 0) {\n            return quotient.toString();\n        }\n        const remainder = this.a.modulo(this.b);\n        const remainderString = long_1.multiplyDivideRound(remainder, power10(digits), this.b).toString();\n        return quotient.toString() +\n            '.' +\n            '0'.repeat(digits - remainderString.length) +\n            remainderString;\n    }\n}\nexports.default = Rational;\nRational.UZERO = new Rational(Long.UZERO, Long.UONE, true);\nfunction trimRight(str, ch) {\n    for (let i = str.length - 1; i >= 0; i--) {\n        if (str[i] !== ch) {\n            return str.slice(0, i + 1);\n        }\n    }\n    return '';\n}\nfunction power10(n) {\n    const ten = Long.fromNumber(10, true);\n    let value = Long.UONE;\n    while (n--)\n        value = value.multiply(ten);\n    return value;\n}\n//# sourceMappingURL=rational.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ilp-protocol-stream/dist/src/util/rational.js?"
          )

          /***/
        },

      /***/ '../../node_modules/inherits/inherits_browser.js':
        /*!***************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/inherits/inherits_browser.js ***!
  \***************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            "if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/inherits/inherits_browser.js?"
          )

          /***/
        },

      /***/ '../../node_modules/isarray/index.js':
        /*!***************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/isarray/index.js ***!
  \***************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            "var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/isarray/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/long/src/long.js':
        /*!***************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/long/src/long.js ***!
  \***************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            "module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/long/src/long.js?"
          )

          /***/
        },

      /***/ '../../node_modules/ms/index.js':
        /*!**********************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/ms/index.js ***!
  \**********************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            "/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/ms/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/node-fetch/browser.js':
        /*!********************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/node-fetch/browser.js ***!
  \********************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar global = getGlobal();\n\nmodule.exports = exports = global.fetch;\n\n// Needed for TypeScript and Webpack.\nexports.default = global.fetch.bind(global);\n\nexports.Headers = global.Headers;\nexports.Request = global.Request;\nexports.Response = global.Response;\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/node-fetch/browser.js?"
          )

          /***/
        },

      /***/ '../../node_modules/object-assign/index.js':
        /*!*********************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/object-assign/index.js ***!
  \*********************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/object-assign/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/oer-utils/dist/src/errors/base-error.js':
        /*!**************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/errors/base-error.js ***!
  \**************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BaseError = (function (_super) {\n    __extends(BaseError, _super);\n    function BaseError(message) {\n        if (message === void 0) { message = ''; }\n        var _this = _super.call(this) || this;\n        Object.defineProperty(_this, 'message', {\n            configurable: true,\n            enumerable: false,\n            value: message\n        });\n        Object.defineProperty(_this, 'name', {\n            configurable: true,\n            enumerable: false,\n            value: _this.constructor.name\n        });\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, _this.constructor);\n        }\n        return _this;\n    }\n    return BaseError;\n}(Error));\nexports.default = BaseError;\n//# sourceMappingURL=base-error.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/errors/base-error.js?"
          )

          /***/
        },

      /***/ '../../node_modules/oer-utils/dist/src/errors/parse-error.js':
        /*!***************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/errors/parse-error.js ***!
  \***************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, "__esModule", { value: true });\nvar base_error_1 = __webpack_require__(/*! ./base-error */ "../../node_modules/oer-utils/dist/src/errors/base-error.js");\nvar ParseError = (function (_super) {\n    __extends(ParseError, _super);\n    function ParseError() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ParseError;\n}(base_error_1.default));\nexports.default = ParseError;\n//# sourceMappingURL=parse-error.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/errors/parse-error.js?'
          )

          /***/
        },

      /***/ '../../node_modules/oer-utils/dist/src/errors/underflow-error.js':
        /*!*******************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/errors/underflow-error.js ***!
  \*******************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, "__esModule", { value: true });\nvar base_error_1 = __webpack_require__(/*! ./base-error */ "../../node_modules/oer-utils/dist/src/errors/base-error.js");\nvar UnderflowError = (function (_super) {\n    __extends(UnderflowError, _super);\n    function UnderflowError() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return UnderflowError;\n}(base_error_1.default));\nexports.default = UnderflowError;\n//# sourceMappingURL=underflow-error.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/errors/underflow-error.js?'
          )

          /***/
        },

      /***/ '../../node_modules/oer-utils/dist/src/index.js':
        /*!**************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/index.js ***!
  \**************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nObject.defineProperty(exports, "__esModule", { value: true });\nvar reader_1 = __webpack_require__(/*! ./lib/reader */ "../../node_modules/oer-utils/dist/src/lib/reader.js");\nexports.Reader = reader_1.default;\nvar writer_1 = __webpack_require__(/*! ./lib/writer */ "../../node_modules/oer-utils/dist/src/lib/writer.js");\nexports.Writer = writer_1.default;\nvar predictor_1 = __webpack_require__(/*! ./lib/predictor */ "../../node_modules/oer-utils/dist/src/lib/predictor.js");\nexports.Predictor = predictor_1.default;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/index.js?'
          )

          /***/
        },

      /***/ '../../node_modules/oer-utils/dist/src/lib/predictor.js':
        /*!**********************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/lib/predictor.js ***!
  \**********************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/oer-utils/dist/src/lib/util.js\");\nvar Predictor = (function () {\n    function Predictor() {\n        this.size = 0;\n    }\n    Object.defineProperty(Predictor.prototype, \"length\", {\n        get: function () {\n            return this.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Predictor.prototype.writeUInt = function (value, length) {\n        this.size += length;\n    };\n    Predictor.prototype.writeInt = function (value, length) {\n        this.size += length;\n    };\n    Predictor.prototype.writeVarUInt = function (_value) {\n        if (!util_1.isInteger(_value)) {\n            throw new Error('UInt must be an integer');\n        }\n        var lengthOfValue;\n        if (typeof _value === 'number') {\n            if (_value < 0) {\n                throw new Error('UInt must be positive');\n            }\n            lengthOfValue = util_1.getUIntBufferSize(_value);\n        }\n        else {\n            var value = util_1.longFromValue(_value, true);\n            lengthOfValue = util_1.getLongUIntBufferSize(value);\n        }\n        this.skipVarOctetString(lengthOfValue);\n    };\n    Predictor.prototype.writeVarInt = function (_value) {\n        if (!util_1.isInteger(_value)) {\n            throw new Error('UInt must be an integer');\n        }\n        var lengthOfValue;\n        if (typeof _value === 'number') {\n            lengthOfValue = util_1.getIntBufferSize(_value);\n        }\n        else {\n            var value = util_1.longFromValue(_value, false);\n            lengthOfValue = util_1.getLongIntBufferSize(value);\n        }\n        this.skipVarOctetString(lengthOfValue);\n    };\n    Predictor.prototype.writeOctetString = function (buffer, length) {\n        if (buffer.length !== length) {\n            throw new Error('Incorrect length for octet string (actual: ' +\n                buffer.length + ', expected: ' + length + ')');\n        }\n        this.skip(length);\n    };\n    Predictor.prototype.writeVarOctetString = function (buffer) {\n        this.skipVarOctetString(buffer.length);\n    };\n    Predictor.prototype.createVarOctetString = function (length) {\n        this.skipVarOctetString(length);\n        return new Predictor();\n    };\n    Predictor.prototype.write = function (bytes) {\n        this.size += bytes.length;\n    };\n    Predictor.prototype.skip = function (bytes) {\n        this.size += bytes;\n    };\n    Predictor.prototype.getSize = function () {\n        return this.size;\n    };\n    Predictor.measureVarOctetString = function (length) {\n        var total = 1;\n        if (length > 127) {\n            var lengthOfLength = util_1.getUIntBufferSize(length);\n            total += lengthOfLength;\n        }\n        total += length;\n        return total;\n    };\n    Predictor.prototype.skipVarOctetString = function (length) {\n        this.skip(Predictor.measureVarOctetString(length));\n    };\n    return Predictor;\n}());\n[1, 2, 4, 8].forEach(function (bytes) {\n    Predictor.prototype['writeUInt' + bytes * 8] = function (value) {\n        return this.writeUInt(value, bytes);\n    };\n    Predictor.prototype['writeInt' + bytes * 8] = function (value) {\n        return this.writeUInt(value, bytes);\n    };\n});\nexports.default = Predictor;\n//# sourceMappingURL=predictor.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/lib/predictor.js?"
          )

          /***/
        },

      /***/ '../../node_modules/oer-utils/dist/src/lib/reader.js':
        /*!*******************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/lib/reader.js ***!
  \*******************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar underflow_error_1 = __webpack_require__(/*! ../errors/underflow-error */ \"../../node_modules/oer-utils/dist/src/errors/underflow-error.js\");\nvar parse_error_1 = __webpack_require__(/*! ../errors/parse-error */ \"../../node_modules/oer-utils/dist/src/errors/parse-error.js\");\nvar Long = __webpack_require__(/*! long */ \"../../node_modules/long/src/long.js\");\nvar util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/oer-utils/dist/src/lib/util.js\");\nvar Reader = (function () {\n    function Reader(buffer) {\n        this.buffer = buffer;\n        this.cursor = 0;\n        this.bookmarks = [];\n    }\n    Reader.from = function (source) {\n        if (Buffer.isBuffer(source)) {\n            return new Reader(source);\n        }\n        else if (source instanceof Reader) {\n            return new Reader(source.buffer.slice(source.cursor));\n        }\n        else {\n            throw new Error('Reader must be given a Buffer');\n        }\n    };\n    Reader.prototype.bookmark = function () {\n        this.bookmarks.push(this.cursor);\n    };\n    Reader.prototype.restore = function () {\n        if (!this.bookmarks.length) {\n            throw new Error('Cannot restore bookmark when no bookmark set');\n        }\n        this.cursor = this.bookmarks.pop();\n    };\n    Reader.prototype.ensureAvailable = function (bytes) {\n        if (this.buffer.length < (this.cursor + bytes)) {\n            throw new underflow_error_1.default('Tried to read ' + bytes + ' bytes, but only ' +\n                (this.buffer.length - this.cursor) + ' bytes available');\n        }\n    };\n    Reader.prototype.readUIntNumber = function (length) {\n        if (length < 1) {\n            throw new Error('UInt length must be greater than zero');\n        }\n        else if (util_1.MAX_SAFE_BYTES < length) {\n            throw new Error('Value does not fit a JS number without sacrificing precision');\n        }\n        else {\n            var value = this.buffer.readUIntBE(this.cursor, length);\n            this.cursor += length;\n            return value;\n        }\n    };\n    Reader.prototype.readUIntLong = function (length) {\n        var value = this.peekUIntLong(length);\n        this.cursor += length;\n        return value;\n    };\n    Reader.prototype.readUInt = function (length) {\n        if (length >= 1 && length <= util_1.MAX_SAFE_BYTES) {\n            return String(this.readUIntNumber(length));\n        }\n        else {\n            return this.readUIntLong(length).toString();\n        }\n    };\n    Reader.prototype.peekUIntNumber = function (length) {\n        if (length >= 1 && length <= util_1.MAX_SAFE_BYTES) {\n            return this.buffer.readUIntBE(this.cursor, length);\n        }\n        else {\n            throw new Error('Value does not fit a JS number without sacrificing precision');\n        }\n    };\n    Reader.prototype.peekUIntLong = function (length) {\n        if (length === 0) {\n            return Long.UZERO;\n        }\n        else if (length < 0) {\n            throw new Error('Tried to read integer with negative length (provided: ' +\n                length + ')');\n        }\n        else if (length > 8) {\n            throw new Error('UInts longer than 8 bytes must be encoded as VarUInts');\n        }\n        return util_1.bufferToLong(this.peek(length), true);\n    };\n    Reader.prototype.peekUInt = function (length) {\n        if (length >= 1 && length <= util_1.MAX_SAFE_BYTES) {\n            return String(this.peekUIntNumber(length));\n        }\n        else {\n            return this.peekUIntLong(length).toString();\n        }\n    };\n    Reader.prototype.skipUInt = function (length) {\n        this.skip(length);\n    };\n    Reader.prototype.readIntNumber = function (length) {\n        if (length < 1) {\n            throw new Error('Int length must be greater than zero');\n        }\n        else if (util_1.MAX_SAFE_BYTES < length) {\n            throw new Error('Value does not fit a JS number without sacrificing precision');\n        }\n        else {\n            var value = this.buffer.readIntBE(this.cursor, length);\n            this.cursor += length;\n            return value;\n        }\n    };\n    Reader.prototype.readIntLong = function (length) {\n        var value = this.peekIntLong(length);\n        this.cursor += length;\n        return value;\n    };\n    Reader.prototype.readInt = function (length) {\n        if (length >= 1 && length <= util_1.MAX_SAFE_BYTES) {\n            return String(this.readIntNumber(length));\n        }\n        else {\n            return this.readIntLong(length).toString();\n        }\n    };\n    Reader.prototype.peekIntNumber = function (length) {\n        if (length >= 1 && length <= util_1.MAX_SAFE_BYTES) {\n            return this.buffer.readIntBE(this.cursor, length);\n        }\n        else {\n            throw new Error('Value does not fit a JS number without sacrificing precision');\n        }\n    };\n    Reader.prototype.peekIntLong = function (length) {\n        if (length === 0) {\n            return Long.ZERO;\n        }\n        else if (length < 0) {\n            throw new Error('Tried to read integer with negative length (provided: ' +\n                length + ')');\n        }\n        else if (length > 8) {\n            throw new Error('Ints longer than 8 bytes must be encoded as VarInts');\n        }\n        return util_1.bufferToLong(this.peek(length), false);\n    };\n    Reader.prototype.peekInt = function (length) {\n        if (length >= 1 && length <= util_1.MAX_SAFE_BYTES) {\n            return String(this.peekIntNumber(length));\n        }\n        else {\n            return this.peekIntLong(length).toString();\n        }\n    };\n    Reader.prototype.skipInt = function (length) {\n        this.skip(length);\n    };\n    Reader.prototype.readVarUIntNumber = function () {\n        if (this.buffer[this.cursor] === 0) {\n            throw new parse_error_1.default('UInt of length 0 is invalid');\n        }\n        if (this.buffer[this.cursor] <= util_1.MAX_SAFE_BYTES) {\n            return this.readUIntNumber(this.buffer[this.cursor++]);\n        }\n        else {\n            throw new Error('Value does not fit a JS number without sacrificing precision');\n        }\n    };\n    Reader.prototype.readVarUIntLong = function () {\n        var buffer = this.readVarOctetString();\n        if (buffer.length === 0) {\n            throw new parse_error_1.default('UInt of length 0 is invalid');\n        }\n        return util_1.bufferToLong(buffer, true);\n    };\n    Reader.prototype.readVarUInt = function () {\n        return this.readVarUIntLong().toString();\n    };\n    Reader.prototype.peekVarUIntNumber = function () {\n        this.bookmark();\n        var value = this.readVarUIntNumber();\n        this.restore();\n        return value;\n    };\n    Reader.prototype.peekVarUIntLong = function () {\n        this.bookmark();\n        var value = this.readVarUIntLong();\n        this.restore();\n        return value;\n    };\n    Reader.prototype.peekVarUInt = function () {\n        return this.peekVarUIntLong().toString();\n    };\n    Reader.prototype.skipVarUInt = function () {\n        this.skipVarOctetString();\n    };\n    Reader.prototype.readVarIntNumber = function () {\n        if (this.buffer[this.cursor] === 0) {\n            throw new parse_error_1.default('Int of length 0 is invalid');\n        }\n        if (this.buffer[this.cursor] <= util_1.MAX_SAFE_BYTES) {\n            return this.readIntNumber(this.buffer[this.cursor++]);\n        }\n        else {\n            throw new Error('Value does not fit a JS number without sacrificing precision');\n        }\n    };\n    Reader.prototype.readVarIntLong = function () {\n        var buffer = this.readVarOctetString();\n        if (buffer.length === 0) {\n            throw new parse_error_1.default('Int of length 0 is invalid');\n        }\n        return util_1.bufferToLong(buffer, false);\n    };\n    Reader.prototype.readVarInt = function () {\n        return this.readVarIntLong().toString();\n    };\n    Reader.prototype.peekVarIntNumber = function () {\n        this.bookmark();\n        var value = this.readVarIntNumber();\n        this.restore();\n        return value;\n    };\n    Reader.prototype.peekVarIntLong = function () {\n        this.bookmark();\n        var value = this.readVarIntLong();\n        this.restore();\n        return value;\n    };\n    Reader.prototype.peekVarInt = function () {\n        return this.peekVarIntLong().toString();\n    };\n    Reader.prototype.skipVarInt = function () {\n        this.skipVarOctetString();\n    };\n    Reader.prototype.readOctetString = function (length) {\n        return this.read(length);\n    };\n    Reader.prototype.peekOctetString = function (length) {\n        return this.peek(length);\n    };\n    Reader.prototype.skipOctetString = function (length) {\n        return this.skip(length);\n    };\n    Reader.prototype.readLengthPrefix = function () {\n        var length = this.readUInt8Number();\n        if (length & Reader.HIGH_BIT) {\n            var lengthPrefixLength = length & Reader.LOWER_SEVEN_BITS;\n            var actualLength = lengthPrefixLength && this.readUIntNumber(lengthPrefixLength);\n            var minLength = Math.max(128, 1 << ((lengthPrefixLength - 1) * 8));\n            if (lengthPrefixLength === 0 || actualLength < minLength) {\n                throw new parse_error_1.default('Length prefix encoding is not canonical: ' +\n                    actualLength + ' encoded in ' + lengthPrefixLength + ' bytes');\n            }\n            return actualLength;\n        }\n        return length;\n    };\n    Reader.prototype.readVarOctetString = function () {\n        var length = this.readLengthPrefix();\n        return this.read(length);\n    };\n    Reader.prototype.peekVarOctetString = function () {\n        this.bookmark();\n        var value = this.readVarOctetString();\n        this.restore();\n        return value;\n    };\n    Reader.prototype.skipVarOctetString = function () {\n        var length = this.readLengthPrefix();\n        this.skip(length);\n    };\n    Reader.prototype.read = function (bytes) {\n        this.ensureAvailable(bytes);\n        var value = this.buffer.slice(this.cursor, this.cursor + bytes);\n        this.cursor += bytes;\n        return value;\n    };\n    Reader.prototype.peek = function (bytes) {\n        this.ensureAvailable(bytes);\n        return this.buffer.slice(this.cursor, this.cursor + bytes);\n    };\n    Reader.prototype.skip = function (bytes) {\n        this.ensureAvailable(bytes);\n        this.cursor += bytes;\n    };\n    Reader.HIGH_BIT = 0x80;\n    Reader.LOWER_SEVEN_BITS = 0x7F;\n    return Reader;\n}());\n['read', 'peek', 'skip'].forEach(function (verb) {\n    [1, 2, 4, 8].forEach(function (bytes) {\n        Reader.prototype[verb + 'UInt' + bytes * 8] = function () {\n            return this[verb + 'UInt'](bytes);\n        };\n        Reader.prototype[verb + 'Int' + bytes * 8] = function () {\n            return this[verb + 'Int'](bytes);\n        };\n        if (verb !== 'skip') {\n            Reader.prototype[verb + 'UInt' + bytes * 8 + 'Number'] = function () {\n                return this[verb + 'UIntNumber'](bytes);\n            };\n            Reader.prototype[verb + 'Int' + bytes * 8 + 'Number'] = function () {\n                return this[verb + 'IntNumber'](bytes);\n            };\n            Reader.prototype[verb + 'UInt' + bytes * 8 + 'Long'] = function () {\n                return this[verb + 'UIntLong'](bytes);\n            };\n            Reader.prototype[verb + 'Int' + bytes * 8 + 'Long'] = function () {\n                return this[verb + 'IntLong'](bytes);\n            };\n        }\n    });\n});\nexports.default = Reader;\n//# sourceMappingURL=reader.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../buffer/index.js */ \"../../node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/lib/reader.js?"
          )

          /***/
        },

      /***/ '../../node_modules/oer-utils/dist/src/lib/util.js':
        /*!*****************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/lib/util.js ***!
  \*****************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Long = __webpack_require__(/*! long */ \"../../node_modules/long/src/long.js\");\nexports.MAX_SAFE_BYTES = 6;\nvar INTEGER_REGEX = /^-?[0-9]+$/;\nfunction isInteger(value) {\n    if (typeof value === 'number') {\n        return isFinite(value) && Math.floor(value) === value;\n    }\n    else if (typeof value === 'string') {\n        return !!INTEGER_REGEX.exec(value);\n    }\n    else {\n        return Long.isLong(value);\n    }\n}\nexports.isInteger = isInteger;\nfunction isLong(obj) { return Long.isLong(obj); }\nexports.isLong = isLong;\nfunction longFromValue(value, unsigned) {\n    if (typeof value === 'number') {\n        if (unsigned && value < 0) {\n            throw new Error('UInt must be positive');\n        }\n        return Long.fromNumber(value, unsigned);\n    }\n    if (isLong(value)) {\n        if (value.unsigned !== unsigned) {\n            if (unsigned)\n                throw new Error('Expected unsigned Long');\n            else\n                throw new Error('Expected signed Long');\n        }\n        return value;\n    }\n    if (unsigned && value[0] === '-') {\n        throw new Error('UInt must be positive');\n    }\n    return Long.fromString(value, unsigned);\n}\nexports.longFromValue = longFromValue;\nfunction bufferToLong(buffer, unsigned) {\n    if (buffer.length > 8) {\n        throw new Error((unsigned ? 'UInt' : 'Int') +\n            ' of length ' + buffer.length + ' is too large');\n    }\n    if (unsigned) {\n        return buffer.reduce(function (sum, value) { return sum.shiftLeft(8).add(value); }, Long.UZERO);\n    }\n    else {\n        return buffer.reduce(function (sum, value, i) {\n            return sum.multiply(256).add((i === 0 && 0x80 <= value) ? value - 0x100 : value);\n        }, Long.ZERO);\n    }\n}\nexports.bufferToLong = bufferToLong;\nfunction longToBuffer(value, length) {\n    return Buffer.from(value.toBytesBE().slice(8 - length));\n}\nexports.longToBuffer = longToBuffer;\nvar LONG_VAR_UINT_SIZES = new Array(8);\nvar LONG_VAR_INT_SIZES = new Array(8);\nfor (var i = 0; i < 8; i++) {\n    LONG_VAR_UINT_SIZES[i] = {\n        max: Long.MAX_UNSIGNED_VALUE.shiftRightUnsigned(64 - 8 * (i + 1)),\n        bytes: i + 1\n    };\n    LONG_VAR_INT_SIZES[i] = {\n        min: Long.MIN_VALUE.shiftRight(64 - 8 * (i + 1)),\n        max: Long.MAX_VALUE.shiftRight(64 - 8 * (i + 1)),\n        bytes: i + 1\n    };\n}\nvar VAR_UINT_SIZES = makeNumberRanges(LONG_VAR_UINT_SIZES);\nvar VAR_INT_SIZES = makeNumberRanges(LONG_VAR_INT_SIZES);\nfunction getLongUIntBufferSize(value) {\n    for (var i = 0; i < LONG_VAR_UINT_SIZES.length; i++) {\n        var item = LONG_VAR_UINT_SIZES[i];\n        if (value.lessThanOrEqual(item.max)) {\n            return item.bytes;\n        }\n    }\n    throw new Error('unreachable');\n}\nexports.getLongUIntBufferSize = getLongUIntBufferSize;\nfunction getUIntBufferSize(value) {\n    for (var i = 0; i < VAR_UINT_SIZES.length; i++) {\n        var item = VAR_UINT_SIZES[i];\n        if (value <= item.max)\n            return item.bytes;\n    }\n    return computeLongBufferSize(Long.fromNumber(value, true));\n}\nexports.getUIntBufferSize = getUIntBufferSize;\nfunction getLongIntBufferSize(value) {\n    for (var i = 0; i < LONG_VAR_INT_SIZES.length; i++) {\n        var item = LONG_VAR_INT_SIZES[i];\n        if (value.greaterThanOrEqual(item.min) &&\n            value.lessThanOrEqual(item.max)) {\n            return item.bytes;\n        }\n    }\n    throw new Error('unreachable');\n}\nexports.getLongIntBufferSize = getLongIntBufferSize;\nfunction getIntBufferSize(value) {\n    for (var i = 0; i < VAR_INT_SIZES.length; i++) {\n        var item = VAR_INT_SIZES[i];\n        if (value >= item.min && value <= item.max)\n            return item.bytes;\n    }\n    return computeLongBufferSize(Long.fromNumber(value, false));\n}\nexports.getIntBufferSize = getIntBufferSize;\nfunction computeLongBufferSize(value) {\n    return Math.ceil(value.toString(16).length / 2);\n}\nfunction makeNumberRanges(ranges) {\n    return ranges\n        .filter(function (range) { return range.bytes <= exports.MAX_SAFE_BYTES; })\n        .map(function (range) { return ({\n        min: range.min && range.min.toNumber(),\n        max: range.max.toNumber(),\n        bytes: range.bytes\n    }); });\n}\n//# sourceMappingURL=util.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../buffer/index.js */ \"../../node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/lib/util.js?"
          )

          /***/
        },

      /***/ '../../node_modules/oer-utils/dist/src/lib/writer.js':
        /*!*******************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/lib/writer.js ***!
  \*******************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/oer-utils/dist/src/lib/util.js\");\nvar Writer = (function () {\n    function Writer(value) {\n        if (Buffer.isBuffer(value)) {\n            this.buffer = value;\n            this.strict = true;\n        }\n        else {\n            this.buffer = Buffer.alloc(value || 0);\n            this.strict = typeof value === 'number';\n        }\n        this._offset = 0;\n    }\n    Object.defineProperty(Writer.prototype, \"length\", {\n        get: function () {\n            return this._offset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Writer.prototype.writeUInt = function (_value, length) {\n        if (!util_1.isInteger(_value)) {\n            throw new Error('UInt must be an integer');\n        }\n        else if (typeof _value === 'number' && _value > Writer.MAX_SAFE_INTEGER) {\n            throw new Error('UInt is larger than safe JavaScript range (try using Longs instead)');\n        }\n        else if (length <= 0) {\n            throw new Error('UInt length must be greater than zero');\n        }\n        else if (util_1.isLong(_value) && !_value.unsigned) {\n            throw new Error('Expected unsigned Long');\n        }\n        if (length <= util_1.MAX_SAFE_BYTES) {\n            var value = Number(_value);\n            if (value < 0) {\n                throw new Error('UInt must be positive');\n            }\n            else if (value > Writer.UINT_RANGES[length]) {\n                throw new Error(\"UInt \" + _value + \" does not fit in \" + length + \" bytes\");\n            }\n            var offset = this.advance(length);\n            this.buffer.writeUIntBE(value, offset, length);\n        }\n        else {\n            var value = util_1.longFromValue(_value, true);\n            if (length < util_1.getLongUIntBufferSize(value)) {\n                throw new Error(\"UInt \" + value + \" does not fit in \" + length + \" bytes\");\n            }\n            this.write(util_1.longToBuffer(value, length));\n        }\n    };\n    Writer.prototype.writeInt = function (_value, length) {\n        if (!util_1.isInteger(_value)) {\n            throw new Error('Int must be an integer');\n        }\n        else if (length <= 0) {\n            throw new Error('Int length must be greater than zero');\n        }\n        else if (typeof _value === 'number' && _value > Writer.MAX_SAFE_INTEGER) {\n            throw new Error('Int is larger than safe JavaScript range (try using Longs instead)');\n        }\n        else if (typeof _value === 'number' && _value < Writer.MIN_SAFE_INTEGER) {\n            throw new Error('Int is smaller than safe JavaScript range (try using Longs instead)');\n        }\n        else if (util_1.isLong(_value) && _value.unsigned) {\n            throw new Error('Expected signed Long');\n        }\n        if (length <= util_1.MAX_SAFE_BYTES) {\n            var value = Number(_value);\n            if (value < Writer.INT_RANGES[length][0] || value > Writer.INT_RANGES[length][1]) {\n                throw new Error('Int ' + _value + ' does not fit in ' + length + ' bytes');\n            }\n            var offset = this.advance(length);\n            this.buffer.writeIntBE(value, offset, length);\n        }\n        else {\n            var value = util_1.longFromValue(_value, false);\n            if (length < util_1.getLongIntBufferSize(value)) {\n                throw new Error('Int ' + value + ' does not fit in ' + length + ' bytes');\n            }\n            this.write(util_1.longToBuffer(value, length));\n        }\n    };\n    Writer.prototype.writeVarUInt = function (_value) {\n        if (Buffer.isBuffer(_value)) {\n            this.writeVarOctetString(_value);\n            return;\n        }\n        else if (!util_1.isInteger(_value)) {\n            throw new Error('UInt must be an integer');\n        }\n        var value;\n        var lengthOfValue;\n        if (typeof _value === 'number') {\n            value = _value;\n            lengthOfValue = util_1.getUIntBufferSize(value);\n        }\n        else {\n            value = util_1.longFromValue(_value, true);\n            lengthOfValue = util_1.getLongUIntBufferSize(value);\n        }\n        this.createVarOctetString(lengthOfValue).writeUInt(value, lengthOfValue);\n    };\n    Writer.prototype.writeVarInt = function (_value) {\n        if (Buffer.isBuffer(_value)) {\n            this.writeVarOctetString(_value);\n            return;\n        }\n        else if (!util_1.isInteger(_value)) {\n            throw new Error('Int must be an integer');\n        }\n        else if (typeof _value === 'number' && _value > Writer.MAX_SAFE_INTEGER) {\n            throw new Error('Int is larger than safe JavaScript range');\n        }\n        else if (typeof _value === 'number' && _value < Writer.MIN_SAFE_INTEGER) {\n            throw new Error('Int is smaller than safe JavaScript range');\n        }\n        var value;\n        var lengthOfValue;\n        if (typeof _value === 'number') {\n            value = _value;\n            lengthOfValue = util_1.getIntBufferSize(value);\n        }\n        else {\n            value = util_1.longFromValue(_value, false);\n            lengthOfValue = util_1.getLongIntBufferSize(value);\n        }\n        this.createVarOctetString(lengthOfValue).writeInt(value, lengthOfValue);\n    };\n    Writer.prototype.writeOctetString = function (buffer, length) {\n        if (buffer.length !== length) {\n            throw new Error('Incorrect length for octet string (actual: ' +\n                buffer.length + ', expected: ' + length + ')');\n        }\n        this.write(buffer);\n    };\n    Writer.prototype.writeVarOctetString = function (buffer) {\n        if (Buffer.isBuffer(buffer)) {\n            this._writeLengthPrefix(buffer.length);\n            this.write(buffer);\n        }\n        else {\n            throw new TypeError('Expects a buffer');\n        }\n    };\n    Writer.prototype.createVarOctetString = function (length) {\n        if (length < 0) {\n            throw new Error('length must be non-negative');\n        }\n        this._writeLengthPrefix(length);\n        var offset = this.advance(length);\n        var slice = this.buffer.slice(offset, offset + length);\n        return new Writer(slice);\n    };\n    Writer.prototype._writeLengthPrefix = function (length) {\n        var MSB = 0x80;\n        if (length <= 127) {\n            this.writeUInt8(length);\n        }\n        else {\n            var lengthOfLength = util_1.getUIntBufferSize(length);\n            this.writeUInt8(MSB | lengthOfLength);\n            this.writeUInt(length, lengthOfLength);\n        }\n    };\n    Writer.prototype.write = function (buffer) {\n        var offset = this.advance(buffer.length);\n        buffer.copy(this.buffer, offset);\n    };\n    Writer.prototype.getBuffer = function () {\n        return this.buffer.slice(0, this._offset);\n    };\n    Writer.prototype.advance = function (advanceBy) {\n        var srcOffset = this._offset;\n        var minCapacity = srcOffset + advanceBy;\n        if (minCapacity <= this.buffer.length) {\n            this._offset += advanceBy;\n            return srcOffset;\n        }\n        if (this.strict) {\n            throw new Error('writer cannot exceed capacity');\n        }\n        var capacity = this.buffer.length || Writer.MIN_BUFFER_SIZE;\n        while (capacity < minCapacity)\n            capacity *= 2;\n        var newBuffer = Buffer.alloc(capacity);\n        if (this.buffer.length) {\n            this.buffer.copy(newBuffer);\n        }\n        this.buffer = newBuffer;\n        this._offset += advanceBy;\n        return srcOffset;\n    };\n    Writer.MAX_SAFE_INTEGER = 0x1fffffffffffff;\n    Writer.MIN_SAFE_INTEGER = -0x1fffffffffffff;\n    Writer.MIN_BUFFER_SIZE = 32;\n    Writer.UINT_RANGES = {\n        1: 0xff,\n        2: 0xffff,\n        3: 0xffffff,\n        4: 0xffffffff,\n        5: 0xffffffffff,\n        6: 0xffffffffffff\n    };\n    Writer.INT_RANGES = {\n        1: [-0x80, 0x7f],\n        2: [-0x8000, 0x7fff],\n        3: [-0x800000, 0x7fffff],\n        4: [-0x80000000, 0x7fffffff],\n        5: [-0x8000000000, 0x7fffffffff],\n        6: [-0x800000000000, 0x7fffffffffff]\n    };\n    return Writer;\n}());\n[1, 2, 4, 8].forEach(function (bytes) {\n    Writer.prototype['writeUInt' + bytes * 8] = function (value) {\n        this.writeUInt(value, bytes);\n    };\n    Writer.prototype['writeInt' + bytes * 8] = function (value) {\n        this.writeInt(value, bytes);\n    };\n});\nexports.default = Writer;\n//# sourceMappingURL=writer.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../buffer/index.js */ \"../../node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/oer-utils/dist/src/lib/writer.js?"
          )

          /***/
        },

      /***/ '../../node_modules/process-nextick-args/index.js':
        /*!****************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/process-nextick-args/index.js ***!
  \****************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(process) {\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"../../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/process-nextick-args/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/process/browser.js':
        /*!*****************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/process/browser.js ***!
  \*****************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            "// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/process/browser.js?"
          )

          /***/
        },

      /***/ '../../node_modules/readable-stream/duplex-browser.js':
        /*!********************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ "../../node_modules/readable-stream/lib/_stream_duplex.js");\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/duplex-browser.js?'
          )

          /***/
        },

      /***/ '../../node_modules/readable-stream/lib/_stream_duplex.js':
        /*!************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn\'t have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ "../../node_modules/process-nextick-args/index.js");\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ "../../node_modules/core-util-is/lib/util.js");\nutil.inherits = __webpack_require__(/*! inherits */ "../../node_modules/inherits/inherits_browser.js");\n/*</replacement>*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ "../../node_modules/readable-stream/lib/_stream_readable.js");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ "../../node_modules/readable-stream/lib/_stream_writable.js");\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once(\'end\', onend);\n}\n\nObject.defineProperty(Duplex.prototype, \'writableHighWaterMark\', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we\'re ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, \'destroyed\', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/_stream_duplex.js?'
          )

          /***/
        },

      /***/ '../../node_modules/readable-stream/lib/_stream_passthrough.js':
        /*!*****************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ "../../node_modules/readable-stream/lib/_stream_transform.js");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ "../../node_modules/core-util-is/lib/util.js");\nutil.inherits = __webpack_require__(/*! inherits */ "../../node_modules/inherits/inherits_browser.js");\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/_stream_passthrough.js?'
          )

          /***/
        },

      /***/ '../../node_modules/readable-stream/lib/_stream_readable.js':
        /*!**************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"../../node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = __webpack_require__(/*! isarray */ \"../../node_modules/isarray/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = __webpack_require__(/*! events */ \"../../node_modules/events/events.js\").EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"../../node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"../../node_modules/readable-stream/node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"../../node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"../../node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(/*! util */ 1);\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ \"../../node_modules/readable-stream/lib/internal/streams/BufferList.js\");\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"../../node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../../node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"../../node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../../node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"../../node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"../../node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../process/browser.js */ \"../../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/_stream_readable.js?"
          )

          /***/
        },

      /***/ '../../node_modules/readable-stream/lib/_stream_transform.js':
        /*!***************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"../../node_modules/readable-stream/lib/_stream_duplex.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"../../node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"../../node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/_stream_transform.js?"
          )

          /***/
        },

      /***/ '../../node_modules/readable-stream/lib/_stream_writable.js':
        /*!**************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"../../node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"../../node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"../../node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"../../node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"../../node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"../../node_modules/readable-stream/node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"../../node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../../node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../../node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"../../node_modules/process/browser.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"../../node_modules/timers-browserify/main.js\").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"../../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/_stream_writable.js?"
          )

          /***/
        },

      /***/ '../../node_modules/readable-stream/lib/internal/streams/BufferList.js':
        /*!*************************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"../../node_modules/readable-stream/node_modules/safe-buffer/index.js\").Buffer;\nvar util = __webpack_require__(/*! util */ 2);\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/internal/streams/BufferList.js?"
          )

          /***/
        },

      /***/ '../../node_modules/readable-stream/lib/internal/streams/destroy.js':
        /*!**********************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ "../../node_modules/process-nextick-args/index.js");\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit(\'error\', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/internal/streams/destroy.js?'
          )

          /***/
        },

      /***/ '../../node_modules/readable-stream/lib/internal/streams/stream-browser.js':
        /*!*****************************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'module.exports = __webpack_require__(/*! events */ "../../node_modules/events/events.js").EventEmitter;\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/lib/internal/streams/stream-browser.js?'
          )

          /***/
        },

      /***/ '../../node_modules/readable-stream/node_modules/safe-buffer/index.js':
        /*!************************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/node_modules/safe-buffer/index.js ***!
  \************************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            "/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"../../node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/node_modules/safe-buffer/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/readable-stream/passthrough.js':
        /*!*****************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/passthrough.js ***!
  \*****************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'module.exports = __webpack_require__(/*! ./readable */ "../../node_modules/readable-stream/readable-browser.js").PassThrough\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/passthrough.js?'
          )

          /***/
        },

      /***/ '../../node_modules/readable-stream/readable-browser.js':
        /*!**********************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "../../node_modules/readable-stream/lib/_stream_readable.js");\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "../../node_modules/readable-stream/lib/_stream_writable.js");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "../../node_modules/readable-stream/lib/_stream_duplex.js");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "../../node_modules/readable-stream/lib/_stream_transform.js");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "../../node_modules/readable-stream/lib/_stream_passthrough.js");\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/readable-browser.js?'
          )

          /***/
        },

      /***/ '../../node_modules/readable-stream/transform.js':
        /*!***************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/transform.js ***!
  \***************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'module.exports = __webpack_require__(/*! ./readable */ "../../node_modules/readable-stream/readable-browser.js").Transform\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/transform.js?'
          )

          /***/
        },

      /***/ '../../node_modules/readable-stream/writable-browser.js':
        /*!**********************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ "../../node_modules/readable-stream/lib/_stream_writable.js");\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/readable-stream/writable-browser.js?'
          )

          /***/
        },

      /***/ '../../node_modules/reduct/dist/index.js':
        /*!*******************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/reduct/dist/index.js ***!
  \*******************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utility = __webpack_require__(/*! ./util */ \"../../node_modules/reduct/dist/util.js\");\nconst createContainer = function (parent) {\n    let parentInjector;\n    if (parent instanceof Map) {\n        parentInjector = key => parent.get(key);\n    }\n    else if (typeof parent === 'object') {\n        parentInjector = key => parent[key.name];\n    }\n    else if (typeof parent === 'function') {\n        parentInjector = parent;\n    }\n    else if (typeof parent === 'undefined') {\n        parentInjector = () => undefined;\n    }\n    else {\n        throw new TypeError('Parent injector must be a Map, object or function');\n    }\n    const cache = new Map();\n    const mapping = new Map();\n    let stack = new Set();\n    let queue = [];\n    const construct = (Constructor) => {\n        const OverrideConstructor = mapping.get(Constructor);\n        return new (OverrideConstructor || Constructor)(reduct);\n    };\n    const reduct = (Constructor) => {\n        if (typeof Constructor !== 'function') {\n            throw new TypeError('Dependencies must be constructors/factories, but got: ' + typeof Constructor);\n        }\n        if (stack.has(Constructor)) {\n            const stackArray = utility.convertSetToArray(stack);\n            stackArray.push(Constructor);\n            const prettyStack = stackArray.map(utility.printPrettyConstructor).join(' => ');\n            throw new Error('Circular dependency detected: ' + prettyStack);\n        }\n        const cachedInstance = cache.get(Constructor);\n        if (cachedInstance) {\n            return cachedInstance;\n        }\n        stack.add(Constructor);\n        const instance = parentInjector(Constructor) ||\n            construct(Constructor);\n        stack.delete(Constructor);\n        cache.set(Constructor, instance);\n        if (queue.length) {\n            stack.add(utility.printPrettyConstructor(Constructor) + ' (post)');\n            const lastQueue = queue;\n            queue = [];\n            lastQueue.forEach((fn) => fn());\n        }\n        return instance;\n    };\n    reduct.setOverride = (Constructor, OverrideConstructor) => {\n        mapping.set(Constructor, OverrideConstructor);\n    };\n    reduct.later = (fn) => queue.push(fn);\n    return reduct;\n};\ncreateContainer.default = createContainer;\ncreateContainer.util = utility;\nexports.default = createContainer;\nmodule.exports = createContainer;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/reduct/dist/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/reduct/dist/util.js':
        /*!******************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/reduct/dist/util.js ***!
  \******************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction convertSetToArray(set) {\n    const arr = [];\n    for (let v of set) {\n        arr.push(v);\n    }\n    return arr;\n}\nexports.convertSetToArray = convertSetToArray;\nfunction isClass(candidate) {\n    return typeof candidate === 'function' && /^\\s*class\\s+/.test(candidate.toString());\n}\nexports.isClass = isClass;\nfunction printPrettyConstructor(key) {\n    if (typeof key === 'string') {\n        return key;\n    }\n    return key.name || (isClass(key) ? '[anonymous class]' : '[anonymous fn]');\n}\nexports.printPrettyConstructor = printPrettyConstructor;\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/reduct/dist/util.js?"
          )

          /***/
        },

      /***/ '../../node_modules/safe-buffer/index.js':
        /*!*******************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/safe-buffer/index.js ***!
  \*******************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            "/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"../../node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/safe-buffer/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/setimmediate/setImmediate.js':
        /*!***************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/setimmediate/setImmediate.js ***!
  \***************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            '/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "../../node_modules/process/browser.js")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/setimmediate/setImmediate.js?'
          )

          /***/
        },

      /***/ '../../node_modules/stream-browserify/index.js':
        /*!*************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/stream-browserify/index.js ***!
  \*************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = __webpack_require__(/*! events */ \"../../node_modules/events/events.js\").EventEmitter;\nvar inherits = __webpack_require__(/*! inherits */ \"../../node_modules/inherits/inherits_browser.js\");\n\ninherits(Stream, EE);\nStream.Readable = __webpack_require__(/*! readable-stream/readable.js */ \"../../node_modules/readable-stream/readable-browser.js\");\nStream.Writable = __webpack_require__(/*! readable-stream/writable.js */ \"../../node_modules/readable-stream/writable-browser.js\");\nStream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ \"../../node_modules/readable-stream/duplex-browser.js\");\nStream.Transform = __webpack_require__(/*! readable-stream/transform.js */ \"../../node_modules/readable-stream/transform.js\");\nStream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ \"../../node_modules/readable-stream/passthrough.js\");\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/stream-browserify/index.js?"
          )

          /***/
        },

      /***/ '../../node_modules/string_decoder/lib/string_decoder.js':
        /*!***********************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"../../node_modules/safe-buffer/index.js\").Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/string_decoder/lib/string_decoder.js?"
          )

          /***/
        },

      /***/ '../../node_modules/timers-browserify/main.js':
        /*!************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/timers-browserify/main.js ***!
  \************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            '/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||\n            (typeof self !== "undefined" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ "../../node_modules/setimmediate/setImmediate.js");\n// On some exotic environments, it\'s not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||\n                       (typeof global !== "undefined" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||\n                         (typeof global !== "undefined" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/timers-browserify/main.js?'
          )

          /***/
        },

      /***/ '../../node_modules/util-deprecate/browser.js':
        /*!************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/util-deprecate/browser.js ***!
  \************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            "/* WEBPACK VAR INJECTION */(function(console, global) {\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../console-browserify/index.js */ \"../../node_modules/console-browserify/index.js\"), __webpack_require__(/*! ./../webpack/buildin/global.js */ \"../../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/util-deprecate/browser.js?"
          )

          /***/
        },

      /***/ '../../node_modules/util/node_modules/inherits/inherits_browser.js':
        /*!*********************************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*********************************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            "if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/util/node_modules/inherits/inherits_browser.js?"
          )

          /***/
        },

      /***/ '../../node_modules/util/support/isBufferBrowser.js':
        /*!******************************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            "module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/util/support/isBufferBrowser.js?"
          )

          /***/
        },

      /***/ '../../node_modules/util/util.js':
        /*!***********************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/util/util.js ***!
  \***********************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            "/* WEBPACK VAR INJECTION */(function(process, console) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"../../node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"../../node_modules/util/node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"../../node_modules/process/browser.js\"), __webpack_require__(/*! ./../console-browserify/index.js */ \"../../node_modules/console-browserify/index.js\")))\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/util/util.js?"
          )

          /***/
        },

      /***/ '../../node_modules/uuid/index.js':
        /*!************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/uuid/index.js ***!
  \************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'var v1 = __webpack_require__(/*! ./v1 */ "../../node_modules/uuid/v1.js");\nvar v4 = __webpack_require__(/*! ./v4 */ "../../node_modules/uuid/v4.js");\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/uuid/index.js?'
          )

          /***/
        },

      /***/ '../../node_modules/uuid/lib/bytesToUuid.js':
        /*!**********************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            "/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/uuid/lib/bytesToUuid.js?"
          )

          /***/
        },

      /***/ '../../node_modules/uuid/lib/rng-browser.js':
        /*!**********************************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            "// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/uuid/lib/rng-browser.js?"
          )

          /***/
        },

      /***/ '../../node_modules/uuid/v1.js':
        /*!*********************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/uuid/v1.js ***!
  \*********************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            "var rng = __webpack_require__(/*! ./lib/rng */ \"../../node_modules/uuid/lib/rng-browser.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"../../node_modules/uuid/lib/bytesToUuid.js\");\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/uuid/v1.js?"
          )

          /***/
        },

      /***/ '../../node_modules/uuid/v4.js':
        /*!*********************************************************************************!*\
  !*** /Users/nicholasdudfield/projects/web-monetization/node_modules/uuid/v4.js ***!
  \*********************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'var rng = __webpack_require__(/*! ./lib/rng */ "../../node_modules/uuid/lib/rng-browser.js");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "../../node_modules/uuid/lib/bytesToUuid.js");\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == \'string\') {\n    buf = options === \'binary\' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n//# sourceURL=webpack:////Users/nicholasdudfield/projects/web-monetization/node_modules/uuid/v4.js?'
          )

          /***/
        },

      /***/ '../../node_modules/webpack/buildin/global.js':
        /*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            'var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?'
          )

          /***/
        },

      /***/ '../coil-polyfill-utils/build/BandwidthTiers.js':
        /*!******************************************************!*\
  !*** ../coil-polyfill-utils/build/BandwidthTiers.js ***!
  \******************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar portableFetch_1 = __webpack_require__(/*! ./portableFetch */ "../coil-polyfill-utils/build/portableFetch.js");\nvar TIER_CACHE_TIMEOUT = 30 * 60 * 1000;\nvar BASE_TIER = 1;\nvar BANDWIDTH_MAP = [0, 100000, 150000, 250000];\nvar BandwidthTiers = (function () {\n    function BandwidthTiers() {\n    }\n    BandwidthTiers.prototype.tierDataExpired = function () {\n        if (!this.tierDataDate) {\n            return true;\n        }\n        var dataAge = new Date().getTime() - this.tierDataDate.getTime();\n        return dataAge > TIER_CACHE_TIMEOUT;\n    };\n    BandwidthTiers.prototype.getTier = function (url) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tierData, data, parsedUrl, origin, urlSegments, i, path, data_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, this.fetchTierData()];\n                    case 1:\n                        tierData = _a.sent();\n                        data = tierData[url];\n                        if (data) {\n                            return [2, data];\n                        }\n                        parsedUrl = new URL(url);\n                        origin = parsedUrl.origin;\n                        urlSegments = parsedUrl.pathname.split(\'/\');\n                        for (i = urlSegments.length; i > 0; i--) {\n                            path = urlSegments.slice(0, i).join();\n                            data_1 = tierData[origin + path];\n                            if (data_1) {\n                                return [2, data_1];\n                            }\n                        }\n                        return [2, BASE_TIER];\n                }\n            });\n        });\n    };\n    BandwidthTiers.prototype.getBandwidth = function (url) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tier;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, this.getTier(url)];\n                    case 1:\n                        tier = _a.sent();\n                        return [2, BANDWIDTH_MAP[tier] || BANDWIDTH_MAP[BASE_TIER]];\n                }\n            });\n        });\n    };\n    BandwidthTiers.prototype.fetchTierData = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var response, tierData;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this.tierData && !this.tierDataExpired()) {\n                            return [2, this.tierData];\n                        }\n                        return [4, portableFetch_1.portableFetch(\'https://cdn.coil.com/tierdata.json\')];\n                    case 1:\n                        response = _a.sent();\n                        if (!response.ok) {\n                            throw new Error(\'failed to fetch tier data\');\n                        }\n                        return [4, response.json()];\n                    case 2:\n                        tierData = _a.sent();\n                        this.tierData = tierData;\n                        this.tierDataDate = new Date();\n                        return [2, tierData];\n                }\n            });\n        });\n    };\n    return BandwidthTiers;\n}());\nexports.BandwidthTiers = BandwidthTiers;\n//# sourceMappingURL=BandwidthTiers.js.map\n\n//# sourceURL=webpack:///../coil-polyfill-utils/build/BandwidthTiers.js?'
          )

          /***/
        },

      /***/ '../coil-polyfill-utils/build/index.js':
        /*!*********************************************!*\
  !*** ../coil-polyfill-utils/build/index.js ***!
  \*********************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nObject.defineProperty(exports, "__esModule", { value: true });\nvar BandwidthTiers_1 = __webpack_require__(/*! ./BandwidthTiers */ "../coil-polyfill-utils/build/BandwidthTiers.js");\nexports.BandwidthTiers = BandwidthTiers_1.BandwidthTiers;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///../coil-polyfill-utils/build/index.js?'
          )

          /***/
        },

      /***/ '../coil-polyfill-utils/build/portableFetch.js':
        /*!*****************************************************!*\
  !*** ../coil-polyfill-utils/build/portableFetch.js ***!
  \*****************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar fetchFn = __webpack_require__(/*! node-fetch */ "../../node_modules/node-fetch/browser.js");\nfunction portableFetch(input, init) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2, fetchFn(input, init)];\n        });\n    });\n}\nexports.portableFetch = portableFetch;\n//# sourceMappingURL=portableFetch.js.map\n\n//# sourceURL=webpack:///../coil-polyfill-utils/build/portableFetch.js?'
          )

          /***/
        },

      /***/ '../web-monetization-polyfill-utils/build/index.js':
        /*!*********************************************************!*\
  !*** ../web-monetization-polyfill-utils/build/index.js ***!
  \*********************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result["default"] = mod;\n    return result;\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar asyncUtils = __importStar(__webpack_require__(/*! ./lib/asyncUtils */ "../web-monetization-polyfill-utils/build/lib/asyncUtils.js"));\nexports.asyncUtils = asyncUtils;\nvar MonetizationTagObserver_1 = __webpack_require__(/*! ./lib/MonetizationTagObserver */ "../web-monetization-polyfill-utils/build/lib/MonetizationTagObserver.js");\nexports.MonetizationTagObserver = MonetizationTagObserver_1.MonetizationTagObserver;\nvar idle_1 = __webpack_require__(/*! ./lib/idle */ "../web-monetization-polyfill-utils/build/lib/idle.js");\nexports.watchMouseMovement = idle_1.watchMouseMovement;\nexports.watchVisibility = idle_1.watchVisibility;\nvar whenDocumentReady_1 = __webpack_require__(/*! ./lib/whenDocumentReady */ "../web-monetization-polyfill-utils/build/lib/whenDocumentReady.js");\nexports.whenDocumentReady = whenDocumentReady_1.whenDocumentReady;\nvar getSPSPResponse_1 = __webpack_require__(/*! ./lib/getSPSPResponse */ "../web-monetization-polyfill-utils/build/lib/getSPSPResponse.js");\nexports.getSPSPResponse = getSPSPResponse_1.getSPSPResponse;\nexports.SPSPError = getSPSPResponse_1.SPSPError;\nvar portableFetch_1 = __webpack_require__(/*! ./lib/portableFetch */ "../web-monetization-polyfill-utils/build/lib/portableFetch.js");\nexports.portableFetch = portableFetch_1.portableFetch;\nvar AdaptiveBandwidth_1 = __webpack_require__(/*! ./lib/AdaptiveBandwidth */ "../web-monetization-polyfill-utils/build/lib/AdaptiveBandwidth.js");\nexports.AdaptiveBandwidth = AdaptiveBandwidth_1.AdaptiveBandwidth;\nvar idle_2 = __webpack_require__(/*! ./lib/idle */ "../web-monetization-polyfill-utils/build/lib/idle.js");\nexports.watchPageEvents = idle_2.watchPageEvents;\nvar BackoffWaiter_1 = __webpack_require__(/*! ./lib/BackoffWaiter */ "../web-monetization-polyfill-utils/build/lib/BackoffWaiter.js");\nexports.BackoffWaiter = BackoffWaiter_1.BackoffWaiter;\nvar resolvePaymentEndpoint_1 = __webpack_require__(/*! ./lib/resolvePaymentEndpoint */ "../web-monetization-polyfill-utils/build/lib/resolvePaymentEndpoint.js");\nexports.resolvePaymentEndpoint = resolvePaymentEndpoint_1.resolvePaymentEndpoint;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///../web-monetization-polyfill-utils/build/index.js?'
          )

          /***/
        },

      /***/ '../web-monetization-polyfill-utils/build/lib/AdaptiveBandwidth.js':
        /*!*************************************************************************!*\
  !*** ../web-monetization-polyfill-utils/build/lib/AdaptiveBandwidth.js ***!
  \*************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '/* WEBPACK VAR INJECTION */(function(console) {\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar defaultLogger = console.log.bind(console, \'adaptive-bandwidth:\');\nvar AdaptiveBandwidth = (function () {\n    function AdaptiveBandwidth(_pageUrl, _tiers, _debug) {\n        if (_debug === void 0) { _debug = defaultLogger; }\n        this._pageUrl = _pageUrl;\n        this._tiers = _tiers;\n        this._debug = _debug;\n        this.reset();\n    }\n    AdaptiveBandwidth.prototype.reset = function () {\n        this._timeStarted = Date.now();\n        this._sentAmount = 0;\n        this._debug(\'reset amount parameters to 0\');\n    };\n    AdaptiveBandwidth.prototype.addSentAmount = function (amount) {\n        this._debug(\'adding sent amount of\', amount);\n        this._sentAmount += Number(amount) || 0;\n    };\n    AdaptiveBandwidth.prototype.getStreamSendMax = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var time, timeElapsed, secondsElapsed, bandwidth, sendAmount;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        time = Date.now();\n                        timeElapsed = time - this._timeStarted;\n                        secondsElapsed = timeElapsed / 1000;\n                        return [4, this._tiers.getBandwidth(this._pageUrl)];\n                    case 1:\n                        bandwidth = _a.sent();\n                        sendAmount = Math.floor(secondsElapsed * bandwidth - this._sentAmount);\n                        this._debug(\'current send amount is\', sendAmount);\n                        return [2, sendAmount];\n                }\n            });\n        });\n    };\n    return AdaptiveBandwidth;\n}());\nexports.AdaptiveBandwidth = AdaptiveBandwidth;\n//# sourceMappingURL=AdaptiveBandwidth.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/console-browserify/index.js */ "../../node_modules/console-browserify/index.js")))\n\n//# sourceURL=webpack:///../web-monetization-polyfill-utils/build/lib/AdaptiveBandwidth.js?'
          )

          /***/
        },

      /***/ '../web-monetization-polyfill-utils/build/lib/BackoffWaiter.js':
        /*!*********************************************************************!*\
  !*** ../web-monetization-polyfill-utils/build/lib/BackoffWaiter.js ***!
  \*********************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar asyncUtils_1 = __webpack_require__(/*! ./asyncUtils */ "../web-monetization-polyfill-utils/build/lib/asyncUtils.js");\nvar BackoffWaiter = (function () {\n    function BackoffWaiter(defaultBackoff, backoff, maxBackoff) {\n        if (defaultBackoff === void 0) { defaultBackoff = 50; }\n        if (backoff === void 0) { backoff = defaultBackoff; }\n        if (maxBackoff === void 0) { maxBackoff = 5000; }\n        this.defaultBackoff = defaultBackoff;\n        this.backoff = backoff;\n        this.maxBackoff = maxBackoff;\n    }\n    BackoffWaiter.prototype.reset = function () {\n        this.backoff = this.defaultBackoff;\n    };\n    BackoffWaiter.prototype.waitAndBackoff = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, asyncUtils_1.timeout(this.backoff)];\n                    case 1:\n                        _a.sent();\n                        this.backoff = Math.floor(Math.pow(this.backoff, 1.05));\n                        if (this.backoff > this.maxBackoff) {\n                            this.backoff = this.maxBackoff;\n                        }\n                        return [2];\n                }\n            });\n        });\n    };\n    return BackoffWaiter;\n}());\nexports.BackoffWaiter = BackoffWaiter;\n//# sourceMappingURL=BackoffWaiter.js.map\n\n//# sourceURL=webpack:///../web-monetization-polyfill-utils/build/lib/BackoffWaiter.js?'
          )

          /***/
        },

      /***/ '../web-monetization-polyfill-utils/build/lib/CustomError.js':
        /*!*******************************************************************!*\
  !*** ../web-monetization-polyfill-utils/build/lib/CustomError.js ***!
  \*******************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, "__esModule", { value: true });\nvar CustomError = (function (_super) {\n    __extends(CustomError, _super);\n    function CustomError(message) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, message) || this;\n        var actualProto = _newTarget.prototype;\n        if (Object.setPrototypeOf) {\n            Object.setPrototypeOf(_this, actualProto);\n        }\n        else {\n            ;\n            _this.__proto__ = actualProto;\n        }\n        return _this;\n    }\n    return CustomError;\n}(Error));\nexports.CustomError = CustomError;\n//# sourceMappingURL=CustomError.js.map\n\n//# sourceURL=webpack:///../web-monetization-polyfill-utils/build/lib/CustomError.js?'
          )

          /***/
        },

      /***/ '../web-monetization-polyfill-utils/build/lib/MonetizationTagObserver.js':
        /*!*******************************************************************************!*\
  !*** ../web-monetization-polyfill-utils/build/lib/MonetizationTagObserver.js ***!
  \*******************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar uuid_1 = __webpack_require__(/*! uuid */ \"../../node_modules/uuid/index.js\");\nvar whenDocumentReady_1 = __webpack_require__(/*! ./whenDocumentReady */ \"../web-monetization-polyfill-utils/build/lib/whenDocumentReady.js\");\nvar debug = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n};\nvar IDGenerationStrategy;\n(function (IDGenerationStrategy) {\n    IDGenerationStrategy[IDGenerationStrategy[\"PAGE_LOAD\"] = 0] = \"PAGE_LOAD\";\n    IDGenerationStrategy[IDGenerationStrategy[\"META_ADDED_CHANGED\"] = 1] = \"META_ADDED_CHANGED\";\n})(IDGenerationStrategy = exports.IDGenerationStrategy || (exports.IDGenerationStrategy = {}));\nvar MonetizationTagObserver = (function () {\n    function MonetizationTagObserver(document, callback, maxMetas, idGenerationStrategy) {\n        if (maxMetas === void 0) { maxMetas = 1; }\n        if (idGenerationStrategy === void 0) { idGenerationStrategy = IDGenerationStrategy.META_ADDED_CHANGED; }\n        this.document = document;\n        this.callback = callback;\n        this.maxMetas = maxMetas;\n        this.idGenerationStrategy = idGenerationStrategy;\n        this.pageLoadId = uuid_1.v4();\n        this.head = null;\n        this.metaTags = new Map();\n        this.headObserver = new MutationObserver(this.onHeadChildListObserved.bind(this));\n    }\n    MonetizationTagObserver.prototype.startWhenDocumentReady = function () {\n        whenDocumentReady_1.whenDocumentReady(this.document, this.start.bind(this));\n    };\n    MonetizationTagObserver.prototype.start = function () {\n        this.head = this.document.head;\n        var metas = this.head.querySelectorAll('meta[name=\"monetization\"]');\n        metas.forEach(this.onAddedMeta.bind(this));\n        this.headObserver.observe(this.head, { childList: true });\n    };\n    MonetizationTagObserver.prototype.onHeadChildListObserved = function (records) {\n        var e_1, _a, e_2, _b;\n        var _this = this;\n        debug('head mutation records.length=', records.length);\n        var check = function (op, node) {\n            debug('head node', op, node);\n            if (node instanceof HTMLMetaElement && node.name === 'monetization') {\n                if (op === 'added') {\n                    _this.onAddedMeta(node);\n                }\n                else if (op === 'removed') {\n                    _this.onRemovedMeta(node);\n                }\n            }\n        };\n        try {\n            for (var records_1 = __values(records), records_1_1 = records_1.next(); !records_1_1.done; records_1_1 = records_1.next()) {\n                var record = records_1_1.value;\n                debug('Record', record.type, record.target);\n                if (record.type === 'childList') {\n                    record.removedNodes.forEach(check.bind(null, 'removed'));\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (records_1_1 && !records_1_1.done && (_a = records_1.return)) _a.call(records_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        try {\n            for (var records_2 = __values(records), records_2_1 = records_2.next(); !records_2_1.done; records_2_1 = records_2.next()) {\n                var record = records_2_1.value;\n                debug('Record', record.type, record.target);\n                if (record.type === 'childList') {\n                    record.addedNodes.forEach(check.bind(null, 'added'));\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (records_2_1 && !records_2_1.done && (_b = records_2.return)) _b.call(records_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    };\n    MonetizationTagObserver.prototype.onMetaContentChangeObserved = function (records) {\n        var e_3, _a;\n        try {\n            for (var records_3 = __values(records), records_3_1 = records_3.next(); !records_3_1.done; records_3_1 = records_3.next()) {\n                var record = records_3_1.value;\n                if (record.type === 'attributes' &&\n                    record.attributeName === 'content' &&\n                    record.target instanceof HTMLMetaElement &&\n                    record.target['content'] !== record.oldValue) {\n                    var meta = record.target;\n                    this.onChangedMetaContent(meta);\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (records_3_1 && !records_3_1.done && (_a = records_3.return)) _a.call(records_3);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n    };\n    MonetizationTagObserver.prototype.onAddedMeta = function (meta) {\n        var details = this.getPaymentDetails(meta);\n        var observer = new MutationObserver(this.onMetaContentChangeObserved.bind(this));\n        observer.observe(meta, {\n            attributeOldValue: true,\n            childList: false,\n            attributeFilter: ['content']\n        });\n        this.metaTags.set(meta, { observer: observer, details: details });\n        if (this.metaTags.size > this.maxMetas) {\n            throw new Error(\"Only \" + this.maxMetas + \" monetization tags supported\");\n        }\n        this.callback({ stopped: null, started: details });\n    };\n    MonetizationTagObserver.prototype.onRemovedMeta = function (meta) {\n        var entry = this.getEntry(meta);\n        entry.observer.disconnect();\n        this.metaTags.delete(meta);\n        this.callback({ started: null, stopped: entry.details });\n    };\n    MonetizationTagObserver.prototype.getEntry = function (meta) {\n        var entry = this.metaTags.get(meta);\n        if (!entry) {\n            throw new Error('meta not tracked: ' + meta.outerHTML);\n        }\n        return entry;\n    };\n    MonetizationTagObserver.prototype.onChangedMetaContent = function (meta) {\n        var entry = this.getEntry(meta);\n        var stopped = entry.details;\n        var started = this.getPaymentDetails(meta);\n        entry.details = started;\n        this.callback({ started: started, stopped: stopped });\n    };\n    MonetizationTagObserver.prototype.getPaymentDetails = function (meta) {\n        return {\n            requestId: this.getWebMonetizationId(),\n            paymentPointer: meta.content\n        };\n    };\n    MonetizationTagObserver.prototype.getWebMonetizationId = function () {\n        if (this.idGenerationStrategy === IDGenerationStrategy.PAGE_LOAD) {\n            return this.pageLoadId;\n        }\n        else if (this.idGenerationStrategy === IDGenerationStrategy.META_ADDED_CHANGED) {\n            return uuid_1.v4();\n        }\n        else {\n            throw new Error();\n        }\n    };\n    return MonetizationTagObserver;\n}());\nexports.MonetizationTagObserver = MonetizationTagObserver;\n//# sourceMappingURL=MonetizationTagObserver.js.map\n\n//# sourceURL=webpack:///../web-monetization-polyfill-utils/build/lib/MonetizationTagObserver.js?"
          )

          /***/
        },

      /***/ '../web-monetization-polyfill-utils/build/lib/asyncUtils.js':
        /*!******************************************************************!*\
  !*** ../web-monetization-polyfill-utils/build/lib/asyncUtils.js ***!
  \******************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.timeout = function (ms) {\n    return new Promise(function (resolve) { return setTimeout(resolve, ms); });\n};\nexports.onlyOnce = function (block) {\n    var ran = false;\n    return function () {\n        if (!ran) {\n            ran = true;\n            block();\n        }\n    };\n};\n//# sourceMappingURL=asyncUtils.js.map\n\n//# sourceURL=webpack:///../web-monetization-polyfill-utils/build/lib/asyncUtils.js?'
          )

          /***/
        },

      /***/ '../web-monetization-polyfill-utils/build/lib/getSPSPResponse.js':
        /*!***********************************************************************!*\
  !*** ../web-monetization-polyfill-utils/build/lib/getSPSPResponse.js ***!
  \***********************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar portableFetch_1 = __webpack_require__(/*! ./portableFetch */ "../web-monetization-polyfill-utils/build/lib/portableFetch.js");\nvar CustomError_1 = __webpack_require__(/*! ./CustomError */ "../web-monetization-polyfill-utils/build/lib/CustomError.js");\nvar SPSPError = (function (_super) {\n    __extends(SPSPError, _super);\n    function SPSPError(message, response) {\n        var _this = _super.call(this, message) || this;\n        _this.response = response;\n        return _this;\n    }\n    return SPSPError;\n}(CustomError_1.CustomError));\nexports.SPSPError = SPSPError;\nfunction getSPSPResponse(spspUrl, monetizationId) {\n    return __awaiter(this, void 0, void 0, function () {\n        var response, e_1, details;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4, portableFetch_1.portableFetch(spspUrl, {\n                            method: \'GET\',\n                            credentials: \'omit\',\n                            cache: \'no-cache\',\n                            headers: {\n                                accept: \'application/spsp4+json\',\n                                \'Web-Monetization-Id\': monetizationId\n                            }\n                        })];\n                case 1:\n                    response = _a.sent();\n                    return [3, 3];\n                case 2:\n                    e_1 = _a.sent();\n                    throw new SPSPError(\'failed_to_fetch\');\n                case 3:\n                    if (!response.ok) {\n                        throw new SPSPError("spsp request failed. status=" + response.status, response);\n                    }\n                    return [4, response.json()];\n                case 4:\n                    details = _a.sent();\n                    return [2, {\n                            destinationAccount: details.destination_account,\n                            sharedSecret: Buffer.from(details.shared_secret, \'base64\')\n                        }];\n            }\n        });\n    });\n}\nexports.getSPSPResponse = getSPSPResponse;\n//# sourceMappingURL=getSPSPResponse.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/buffer/index.js */ "../../node_modules/buffer/index.js").Buffer))\n\n//# sourceURL=webpack:///../web-monetization-polyfill-utils/build/lib/getSPSPResponse.js?'
          )

          /***/
        },

      /***/ '../web-monetization-polyfill-utils/build/lib/idle.js':
        /*!************************************************************!*\
  !*** ../web-monetization-polyfill-utils/build/lib/idle.js ***!
  \************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar IDLE_TIMEOUT = 30 * 60 * 1000;\nfunction watchVisibility(_a) {\n    var pause = _a.pause, resume = _a.resume;\n    if (document.visibilityState === 'hidden') {\n        pause();\n    }\n    var listener = function () {\n        if (document.visibilityState === 'visible') {\n            resume();\n        }\n        else {\n            pause();\n        }\n    };\n    document.addEventListener('visibilitychange', listener);\n    return function () {\n        document.removeEventListener('visibilitychange', listener);\n    };\n}\nexports.watchVisibility = watchVisibility;\nfunction watchMouseMovement(_a) {\n    var pause = _a.pause, resume = _a.resume;\n    var idle = false;\n    var lastMovement = Date.now();\n    var handle;\n    handle = setTimeout(idleTimerReached, IDLE_TIMEOUT);\n    function idleTimerReached() {\n        var now = Date.now();\n        var idleTimeLeft = lastMovement + IDLE_TIMEOUT - now;\n        if (idleTimeLeft > 0) {\n            handle = setTimeout(idleTimerReached, idleTimeLeft);\n        }\n        else {\n            idle = true;\n            pause();\n        }\n    }\n    var listener = function () {\n        lastMovement = Date.now();\n        if (idle) {\n            idle = false;\n            handle = setTimeout(idleTimerReached, IDLE_TIMEOUT);\n            resume();\n        }\n    };\n    document.addEventListener('mousemove', listener);\n    return function () {\n        clearTimeout(handle);\n        document.removeEventListener('mousemove', listener);\n    };\n}\nexports.watchMouseMovement = watchMouseMovement;\nfunction watchPageEvents() {\n    var cleanups = [];\n    return {\n        clearWatch: function () {\n            while (typeof cleanups[0] === 'function') {\n                cleanups[0]();\n                cleanups.pop();\n            }\n        },\n        setWatch: function (stream) {\n            cleanups.push(watchVisibility(stream));\n            cleanups.push(watchMouseMovement(stream));\n        }\n    };\n}\nexports.watchPageEvents = watchPageEvents;\n//# sourceMappingURL=idle.js.map\n\n//# sourceURL=webpack:///../web-monetization-polyfill-utils/build/lib/idle.js?"
          )

          /***/
        },

      /***/ '../web-monetization-polyfill-utils/build/lib/portableFetch.js':
        /*!*********************************************************************!*\
  !*** ../web-monetization-polyfill-utils/build/lib/portableFetch.js ***!
  \*********************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar fetchFn = __webpack_require__(/*! node-fetch */ "../../node_modules/node-fetch/browser.js");\nfunction portableFetch(input, init) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2, fetchFn(input, init)];\n        });\n    });\n}\nexports.portableFetch = portableFetch;\n//# sourceMappingURL=portableFetch.js.map\n\n//# sourceURL=webpack:///../web-monetization-polyfill-utils/build/lib/portableFetch.js?'
          )

          /***/
        },

      /***/ '../web-monetization-polyfill-utils/build/lib/resolvePaymentEndpoint.js':
        /*!******************************************************************************!*\
  !*** ../web-monetization-polyfill-utils/build/lib/resolvePaymentEndpoint.js ***!
  \******************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction resolvePaymentEndpoint(pointerOrUrl) {\n    var httpUrl = pointerOrUrl.replace(/^\\$/, 'https://');\n    var url;\n    try {\n        url = new URL(httpUrl);\n    }\n    catch (e) {\n        throw new Error(\"Invalid payment pointer/url: \" + JSON.stringify(pointerOrUrl));\n    }\n    var isPaymentPointer = pointerOrUrl.startsWith('$');\n    if (isPaymentPointer &&\n        (url.hash || url.search || url.port || url.username || url.password)) {\n        throw new Error('Payment pointer must not contain ' +\n            'query/fragment/port/username elements: ' +\n            JSON.stringify({\n                hash: url.hash,\n                search: url.search,\n                port: url.port,\n                username: url.username,\n                password: url.password\n            }));\n    }\n    return isPaymentPointer && url.pathname === '/'\n        ? url.href + '.well-known/pay'\n        : url.href;\n}\nexports.resolvePaymentEndpoint = resolvePaymentEndpoint;\n//# sourceMappingURL=resolvePaymentEndpoint.js.map\n\n//# sourceURL=webpack:///../web-monetization-polyfill-utils/build/lib/resolvePaymentEndpoint.js?"
          )

          /***/
        },

      /***/ '../web-monetization-polyfill-utils/build/lib/whenDocumentReady.js':
        /*!*************************************************************************!*\
  !*** ../web-monetization-polyfill-utils/build/lib/whenDocumentReady.js ***!
  \*************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction whenDocumentReady(document, start) {\n    if (document.readyState === 'interactive' ||\n        document.readyState === 'complete') {\n        start();\n    }\n    else {\n        document.addEventListener('readystatechange', function () {\n            if (document.readyState === 'interactive') {\n                start();\n            }\n        }, { once: true });\n    }\n}\nexports.whenDocumentReady = whenDocumentReady;\n//# sourceMappingURL=whenDocumentReady.js.map\n\n//# sourceURL=webpack:///../web-monetization-polyfill-utils/build/lib/whenDocumentReady.js?"
          )

          /***/
        },

      /***/ './src/DocumentMonetization.ts':
        /*!*************************************!*\
  !*** ./src/DocumentMonetization.ts ***!
  \*************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar documentExtensions_1 = __webpack_require__(/*! ./documentExtensions */ \"./src/documentExtensions.ts\");\nvar logging_1 = __webpack_require__(/*! ./logging */ \"./src/logging.ts\");\nvar DocumentMonetization = (function () {\n    function DocumentMonetization(doc) {\n        this.doc = doc;\n        this.finalized = true;\n        this.state = 'stopped';\n    }\n    DocumentMonetization.prototype.setMonetizationRequest = function (request) {\n        this.request = request;\n        this.finalized = true;\n    };\n    DocumentMonetization.prototype.setState = function (_a) {\n        var state = _a.state, finalized = _a.finalized;\n        logging_1.debug('SET STATE', 'new:', { state: state, finalized: finalized }, 'old:', {\n            state: this.state,\n            finalized: this.finalized\n        });\n        if (typeof finalized !== 'undefined' && state !== 'stopped') {\n            throw new Error('invalid_state: finalized set when not stopped state');\n        }\n        finalized = Boolean(finalized);\n        var changedFinalized = finalized != this.finalized;\n        var changedState = this.state != state;\n        var changed = changedState || changedFinalized;\n        this.state = state;\n        this.finalized = finalized;\n        if (changed) {\n            if (changedState) {\n                documentExtensions_1.getDoc(this.doc).monetization.state = state;\n            }\n            if (this.request && (state === 'stopped' || state === 'pending')) {\n                this.dispatchMonetizationEvent(state === 'pending' ? 'monetizationpending' : 'monetizationstop', this.request, finalized);\n            }\n        }\n        return changed;\n    };\n    DocumentMonetization.prototype.dispatchMonetizationStartEventAndSetMonetizationState = function (detail) {\n        var changed = this.setState({ state: 'started' });\n        if (!changed) {\n            throw new Error(\"expecting state transition\");\n        }\n        this.dispatchMonetizationEvent('monetizationstart', detail);\n    };\n    DocumentMonetization.prototype.dispatchMonetizationEvent = function (type, detailSource, finalized) {\n        var detail = __assign({}, detailSource);\n        if (type === 'monetizationstop') {\n            ;\n            detail.finalized = Boolean(finalized);\n        }\n        documentExtensions_1.getDoc(this.doc).monetization.dispatchEvent(new CustomEvent(type, { detail: detail }));\n    };\n    DocumentMonetization.prototype.dispatchMonetizationProgressEvent = function (detail) {\n        this.dispatchMonetizationEvent('monetizationprogress', detail);\n    };\n    return DocumentMonetization;\n}());\nexports.DocumentMonetization = DocumentMonetization;\n\n\n//# sourceURL=webpack:///./src/DocumentMonetization.ts?"
          )

          /***/
        },

      /***/ './src/MonetizationPolyfill.ts':
        /*!*************************************!*\
  !*** ./src/MonetizationPolyfill.ts ***!
  \*************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '/* WEBPACK VAR INJECTION */(function(console) {\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar polyfill_utils_1 = __webpack_require__(/*! @web-monetization/polyfill-utils */ "../web-monetization-polyfill-utils/build/index.js");\nvar Stream_1 = __webpack_require__(/*! ./Stream */ "./src/Stream.ts");\nvar documentExtensions_1 = __webpack_require__(/*! ./documentExtensions */ "./src/documentExtensions.ts");\nvar logging_1 = __webpack_require__(/*! ./logging */ "./src/logging.ts");\nvar InitState;\n(function (InitState) {\n    InitState[InitState["STOPPED"] = 0] = "STOPPED";\n    InitState[InitState["STARTED"] = 1] = "STARTED";\n})(InitState = exports.InitState || (exports.InitState = {}));\nvar MonetizationPolyfill = (function () {\n    function MonetizationPolyfill(deps) {\n        this.state = InitState.STOPPED;\n        logging_1.debug(\'MonetizationPolyfill constructor!\');\n        this.stream = deps(Stream_1.Stream);\n    }\n    MonetizationPolyfill.prototype.init = function (opts) {\n        var _this = this;\n        if (this.state === InitState.STARTED) {\n            throw new Error(\'coil monetization polyfill has already been initialized\');\n        }\n        if (!documentExtensions_1.getDoc().monetization) {\n            throw new Error(\'document.monetization must be set outside of this script\');\n        }\n        if (documentExtensions_1.getDoc().monetizationExtensionInstalled) {\n            console.error(\'monetization enabled via extension; aborting\');\n            return;\n        }\n        this.state = InitState.STARTED;\n        this.refreshBtpToken(opts.btpToken);\n        this.btpEndpoint = opts.btpEndpoint;\n        var streamControl = {\n            pause: function () { return _this.stream.pause(); },\n            resume: function () {\n                var selector = \'meta[name="monetization"]\';\n                if (!document.head.querySelector(selector)) {\n                    throw new Error("invalid_state: no \\"" + selector + "\\" found");\n                }\n                _this.stream.start({\n                    paymentPointer: _this.paymentPointer,\n                    requestId: _this.requestId,\n                    pageUrl: window.location.href,\n                    btpToken: _this.btpToken,\n                    btpEndpoint: _this.btpEndpoint,\n                    spspEndpoint: _this.resolvedEndpoint\n                });\n            }\n        };\n        var _a = polyfill_utils_1.watchPageEvents(), clearWatch = _a.clearWatch, setWatch = _a.setWatch;\n        var monitor = new polyfill_utils_1.MonetizationTagObserver(document, function (_a) {\n            var started = _a.started, stopped = _a.stopped;\n            return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_b) {\n                    logging_1.debug({ started: started, stopped: stopped });\n                    if (stopped) {\n                        clearWatch();\n                        void this.stream.stop();\n                    }\n                    if (started) {\n                        this.resolvedEndpoint = polyfill_utils_1.resolvePaymentEndpoint(started.paymentPointer);\n                        setWatch(streamControl);\n                        this.requestId = started.requestId;\n                        this.paymentPointer = started.paymentPointer;\n                        streamControl.resume();\n                    }\n                    return [2];\n                });\n            });\n        });\n        monitor.startWhenDocumentReady();\n    };\n    MonetizationPolyfill.prototype.refreshBtpToken = function (btpToken) {\n        if (btpToken == null) {\n            throw new Error("btpToken is null, is the user subscribed?");\n        }\n        this.btpToken = btpToken;\n        this.stream.refreshBtpToken(btpToken);\n    };\n    return MonetizationPolyfill;\n}());\nexports.MonetizationPolyfill = MonetizationPolyfill;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/console-browserify/index.js */ "../../node_modules/console-browserify/index.js")))\n\n//# sourceURL=webpack:///./src/MonetizationPolyfill.ts?'
          )

          /***/
        },

      /***/ './src/Stream.ts':
        /*!***********************!*\
  !*** ./src/Stream.ts ***!
  \***********************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '/* WEBPACK VAR INJECTION */(function(console, setImmediate) {\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result["default"] = mod;\n    return result;\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar events_1 = __webpack_require__(/*! events */ "../../node_modules/events/events.js");\nvar ilp_plugin_btp_1 = __importDefault(__webpack_require__(/*! ilp-plugin-btp */ "../../node_modules/ilp-plugin-btp/index.js"));\nvar IlpStream = __importStar(__webpack_require__(/*! ilp-protocol-stream */ "../../node_modules/ilp-protocol-stream/dist/src/index.js"));\nvar polyfill_utils_1 = __webpack_require__(/*! @web-monetization/polyfill-utils */ "../web-monetization-polyfill-utils/build/index.js");\nvar polyfill_utils_2 = __webpack_require__(/*! @coil/polyfill-utils */ "../coil-polyfill-utils/build/index.js");\nvar DocumentMonetization_1 = __webpack_require__(/*! ./DocumentMonetization */ "./src/DocumentMonetization.ts");\nvar logging_1 = __webpack_require__(/*! ./logging */ "./src/logging.ts");\nvar UPDATE_AMOUNT_INTERVAL = 2000;\nvar MonetizationStateEnum;\n(function (MonetizationStateEnum) {\n    MonetizationStateEnum[MonetizationStateEnum["STOPPED"] = 0] = "STOPPED";\n    MonetizationStateEnum[MonetizationStateEnum["STARTED"] = 1] = "STARTED";\n})(MonetizationStateEnum = exports.MonetizationStateEnum || (exports.MonetizationStateEnum = {}));\nvar BTP_ENDPOINT_DEFAULT = \'btp+wss://coil.com/btp\';\nvar Stream = (function () {\n    function Stream(deps) {\n        this.btpEndpoint = BTP_ENDPOINT_DEFAULT;\n        this.state = MonetizationStateEnum.STOPPED;\n        this.active = false;\n        this.activeChanges = new events_1.EventEmitter();\n        this.backoff = new polyfill_utils_1.BackoffWaiter();\n        this.lastDelivered = 0;\n        this.loop = null;\n        this.tiers = deps(polyfill_utils_2.BandwidthTiers);\n        this.monetization = new DocumentMonetization_1.DocumentMonetization(document);\n    }\n    Stream.prototype.refreshBtpToken = function (btpToken) {\n        this.btpToken = btpToken;\n    };\n    Stream.prototype.start = function (opts) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, this.finalizeExisting()];\n                    case 1:\n                        _a.sent();\n                        this.active = true;\n                        this.btpToken = opts.btpToken;\n                        this.btpEndpoint = opts.btpEndpoint || BTP_ENDPOINT_DEFAULT;\n                        this.requestId = opts.requestId;\n                        this.paymentPointer = opts.paymentPointer;\n                        this.spspEndpoint = opts.spspEndpoint;\n                        this.pageUrl = opts.pageUrl;\n                        this.adaptiveBandwidth = new polyfill_utils_1.AdaptiveBandwidth(opts.pageUrl, this.tiers);\n                        this.monetization.setMonetizationRequest({\n                            paymentPointer: opts.paymentPointer,\n                            requestId: opts.requestId\n                        });\n                        if (!this.loop) {\n                            this.loop = this.streamRetryLoop();\n                        }\n                        this.activeChanges.emit(\'start\');\n                        return [2];\n                }\n            });\n        });\n    };\n    Stream.prototype.finalizeExisting = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var e_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.existing) return [3, 5];\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, 4, 5]);\n                        return [4, this.existing];\n                    case 2:\n                        _a.sent();\n                        return [3, 5];\n                    case 3:\n                        e_1 = _a.sent();\n                        return [3, 5];\n                    case 4:\n                        this.existing = undefined;\n                        return [7];\n                    case 5: return [2];\n                }\n            });\n        });\n    };\n    Stream.prototype.stop = function (finalized) {\n        if (finalized === void 0) { finalized = true; }\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                this.active = false;\n                this.monetization.setState({ state: \'stopped\', finalized: finalized });\n                if (finalized) {\n                    this.monetization.setMonetizationRequest(undefined);\n                }\n                this.state = MonetizationStateEnum.STOPPED;\n                this.activeChanges.emit(\'stop\');\n                return [2];\n            });\n        });\n    };\n    Stream.prototype.isActive = function () {\n        return this.active;\n    };\n    Stream.prototype.streamRetryLoop = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var promise, _a, _b, e_2;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (!this.spspEndpoint) {\n                            throw new Error(\'no spspEndpoint; was init called?\');\n                        }\n                        if (!this.requestId) {\n                            throw new Error(\'no streamId; was init called?\');\n                        }\n                        _c.label = 1;\n                    case 1:\n                        if (false) {}\n                        if (!!this.isActive()) return [3, 3];\n                        return [4, new Promise(function (resolve) { return _this.activeChanges.once(\'start\', resolve); })];\n                    case 2:\n                        _c.sent();\n                        _c.label = 3;\n                    case 3:\n                        _c.trys.push([3, 6, , 8]);\n                        this.monetization.setState({ state: \'pending\' });\n                        logging_1.debug(\'Start streamPayment()\');\n                        _a = this;\n                        _b = this.streamPayment;\n                        return [4, polyfill_utils_1.getSPSPResponse(this.spspEndpoint, this.requestId)];\n                    case 4:\n                        promise = (_a.existing = _b.apply(this, [_c.sent()]));\n                        return [4, promise];\n                    case 5:\n                        _c.sent();\n                        logging_1.debug(\'End streamPayment()\');\n                        return [3, 8];\n                    case 6:\n                        e_2 = _c.sent();\n                        console.error("streaming error; retry in " + this.backoff + " ms. error=", e_2);\n                        return [4, this.backoff.waitAndBackoff()];\n                    case 7:\n                        _c.sent();\n                        return [3, 8];\n                    case 8: return [3, 1];\n                    case 9: return [2];\n                }\n            });\n        });\n    };\n    Stream.prototype.streamPayment = function (details) {\n        return __awaiter(this, void 0, void 0, function () {\n            var plugin, connection_1, adaptiveBandwidth_1, initialSendMaxAmount, stream_1, promise;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.btpToken) {\n                            throw new Error(\'no btpToken; was init called?\');\n                        }\n                        if (!this.spspEndpoint) {\n                            throw new Error(\'no spspEndpoint; was init called?\');\n                        }\n                        if (!this.isActive()) {\n                            return [2];\n                        }\n                        plugin = new ilp_plugin_btp_1.default({\n                            server: this.btpEndpoint,\n                            btpToken: this.btpToken\n                        });\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, , 8, 10]);\n                        return [4, plugin.connect()];\n                    case 2:\n                        _a.sent();\n                        this.backoff.reset();\n                        if (!this.isActive()) {\n                            return [2];\n                        }\n                        return [4, IlpStream.createConnection(__assign({ plugin: plugin, slippage: 1.0, exchangeRate: 1.0, maximumPacketAmount: \'10000000\' }, details))];\n                    case 3:\n                        connection_1 = _a.sent();\n                        if (!!this.isActive()) return [3, 5];\n                        return [4, connection_1.destroy()];\n                    case 4:\n                        _a.sent();\n                        return [2];\n                    case 5:\n                        adaptiveBandwidth_1 = this.adaptiveBandwidth;\n                        return [4, adaptiveBandwidth_1.getStreamSendMax()];\n                    case 6:\n                        initialSendMaxAmount = _a.sent();\n                        stream_1 = connection_1.createStream();\n                        stream_1.setSendMax(initialSendMaxAmount);\n                        promise = new Promise(function (resolve, reject) {\n                            var boundOutgoingMoney = function (sentAmount) {\n                                setImmediate(_this.onOutgoingMoney.bind(_this), connection_1, sentAmount);\n                            };\n                            var onPluginDisconnect = function () { return __awaiter(_this, void 0, void 0, function () {\n                                return __generator(this, function (_a) {\n                                    cleanUp();\n                                    resolve();\n                                    return [2];\n                                });\n                            }); };\n                            var onConnectionClose = function () {\n                                cleanUp();\n                                reject(new Error(\'connection closed\'));\n                            };\n                            var onStop = onPluginDisconnect;\n                            var onUpdateAmountInterval = function () { return __awaiter(_this, void 0, void 0, function () {\n                                var sendMaxAmount;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0: return [4, adaptiveBandwidth_1.getStreamSendMax()];\n                                        case 1:\n                                            sendMaxAmount = _a.sent();\n                                            if (stream_1.isOpen()) {\n                                                stream_1.setSendMax(sendMaxAmount);\n                                            }\n                                            return [2];\n                                    }\n                                });\n                            }); };\n                            var addSentAmount = polyfill_utils_1.asyncUtils.onlyOnce(function () {\n                                adaptiveBandwidth_1.addSentAmount(stream_1.totalSent);\n                            });\n                            var cleanUp = polyfill_utils_1.asyncUtils.onlyOnce(function () {\n                                logging_1.debug(\'cleanUp()\');\n                                plugin.removeListener(\'disconnect\', onPluginDisconnect);\n                                stream_1.removeListener(\'outgoing_money\', boundOutgoingMoney);\n                                connection_1.removeListener(\'close\', onConnectionClose);\n                                addSentAmount();\n                                _this.activeChanges.removeListener(\'stop\', onStop);\n                                _this.lastDelivered = 0;\n                                _this.monetization.setState({ state: \'stopped\' });\n                                _this.state = MonetizationStateEnum.STOPPED;\n                                clearInterval(updateAmountInterval);\n                            });\n                            plugin.on(\'disconnect\', onPluginDisconnect);\n                            stream_1.on(\'outgoing_money\', boundOutgoingMoney);\n                            connection_1.on(\'close\', onConnectionClose);\n                            _this.activeChanges.once(\'stop\', function () {\n                                logging_1.debug(\'activeChanges on stop!\');\n                                onStop();\n                            });\n                            var updateAmountInterval = setInterval(onUpdateAmountInterval, UPDATE_AMOUNT_INTERVAL);\n                        });\n                        return [4, promise];\n                    case 7:\n                        _a.sent();\n                        return [3, 10];\n                    case 8: return [4, plugin.disconnect()];\n                    case 9:\n                        _a.sent();\n                        return [7];\n                    case 10: return [2];\n                }\n            });\n        });\n    };\n    Stream.prototype.onOutgoingMoney = function (connection, _) {\n        if (this.state === MonetizationStateEnum.STOPPED) {\n            this.state = MonetizationStateEnum.STARTED;\n            this.dispatchMonetizationStart();\n        }\n        var deliveredAmount = Number(connection.totalDelivered) - this.lastDelivered;\n        this.lastDelivered = Number(connection.totalDelivered);\n        this.dispatchMonetizationProgress(connection, deliveredAmount.toString());\n    };\n    Stream.prototype.dispatchMonetizationStart = function () {\n        var detail = {\n            paymentPointer: this.paymentPointer,\n            requestId: this.requestId\n        };\n        this.monetization.dispatchMonetizationStartEventAndSetMonetizationState(detail);\n    };\n    Stream.prototype.dispatchMonetizationProgress = function (connection, amount) {\n        var detail = {\n            amount: amount,\n            assetCode: connection.destinationAssetCode,\n            assetScale: connection.destinationAssetScale,\n            paymentPointer: this.paymentPointer,\n            requestId: this.requestId\n        };\n        this.monetization.dispatchMonetizationProgressEvent(detail);\n    };\n    Stream.prototype.pause = function () {\n        return this.stop(false);\n    };\n    return Stream;\n}());\nexports.Stream = Stream;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/console-browserify/index.js */ "../../node_modules/console-browserify/index.js"), __webpack_require__(/*! ./../../../node_modules/timers-browserify/main.js */ "../../node_modules/timers-browserify/main.js").setImmediate))\n\n//# sourceURL=webpack:///./src/Stream.ts?'
          )

          /***/
        },

      /***/ './src/bundle.ts':
        /*!***********************!*\
  !*** ./src/bundle.ts ***!
  \***********************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar reduct_1 = __importDefault(__webpack_require__(/*! reduct */ "../../node_modules/reduct/dist/index.js"));\nvar MonetizationPolyfill_1 = __webpack_require__(/*! ./MonetizationPolyfill */ "./src/MonetizationPolyfill.ts");\nvar documentExtensions_1 = __webpack_require__(/*! ./documentExtensions */ "./src/documentExtensions.ts");\ndocumentExtensions_1.getDoc().coilMonetizationPolyfill = reduct_1.default()(MonetizationPolyfill_1.MonetizationPolyfill);\n\n\n//# sourceURL=webpack:///./src/bundle.ts?'
          )

          /***/
        },

      /***/ './src/documentExtensions.ts':
        /*!***********************************!*\
  !*** ./src/documentExtensions.ts ***!
  \***********************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            '\nObject.defineProperty(exports, "__esModule", { value: true });\nfunction getDoc(doc) {\n    if (doc === void 0) { doc = document; }\n    return doc;\n}\nexports.getDoc = getDoc;\n\n\n//# sourceURL=webpack:///./src/documentExtensions.ts?'
          )

          /***/
        },

      /***/ './src/logging.ts':
        /*!************************!*\
  !*** ./src/logging.ts ***!
  \************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict'
          eval(
            "/* WEBPACK VAR INJECTION */(function(console) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar documentExtensions_1 = __webpack_require__(/*! ./documentExtensions */ \"./src/documentExtensions.ts\");\nexports.debug = localStorage.WM_DEBUG\n    ?\n        console.log.bind(console, 'oauth-scripts:')\n    :\n        function () { };\nfunction logEvents() {\n    var events = [\n        'monetizationstart',\n        'monetizationstop',\n        'monetizationpending'\n    ];\n    events.forEach(function (e) {\n        documentExtensions_1.getDoc(document).monetization.addEventListener(e, function (ev) {\n            exports.debug('WM EVENT: ', e, ev.detail);\n        });\n    });\n}\nexports.logEvents = logEvents;\nlogEvents();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/console-browserify/index.js */ \"../../node_modules/console-browserify/index.js\")))\n\n//# sourceURL=webpack:///./src/logging.ts?"
          )

          /***/
        },

      /***/ 0:
        /*!*****************************!*\
  !*** multi ./src/bundle.ts ***!
  \*****************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'module.exports = __webpack_require__(/*! ./src/bundle.ts */"./src/bundle.ts");\n\n\n//# sourceURL=webpack:///multi_./src/bundle.ts?'
          )

          /***/
        },

      /***/ 1:
        /*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval('/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?')

          /***/
        },

      /***/ 2:
        /*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval('/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?')

          /***/
        },

      /***/ 3:
        /*!**************************!*\
  !*** ./server (ignored) ***!
  \**************************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            '/* (ignored) */\n\n//# sourceURL=webpack:///./server_(ignored)?'
          )

          /***/
        }

      /******/
    }
  )
})
